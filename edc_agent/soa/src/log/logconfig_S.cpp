/****************************************************************
 Generated by ChangAn Code Generator,Do Not Modify
 AppVersion： GW_ALL-V1.1.1
 CmVersion： v2.0.3
 Generate Time: Nov 30, 2023 12:26:12 PM
 *****************************************************************/
#include "changan/logconfig_S.hpp"
#include "changan/dds_server.hpp"
#include <iostream>
#include <thread>
#include <string.h>
#include "changan/string_util.hpp"
#include "changan/business_util.h"

namespace com
{
	namespace changan
	{
		namespace soa_log
		{
			namespace skeleton
			{
				class MySkeleton1 : public logconfig_service_interface
				{
				public:
					std::string SETSOALOG(const std::string &logLevel, const std::string &logDir)
					{
						std::string ret;
						ret = logLevel + ":" + logDir;
						return ret;
					}
				};

				using namespace com::changan::rpc_service;
				void carDrive_logconfig_SETSOALOG(carDrive_logconfig_Request *request)
				{
					// logconfig_Skeleton * skeleton = (logconfig_Skeleton*)DDSServer::get_service("logconfig_skeleton");
					logconfig_Skeleton *skeleton = &logconfig_Skeleton::get_instance();
					if (NULL == skeleton)
					{
						return;
					}
				  	ASF_LOG_DEBUG_ARGS("request->data._u.SETSOALOG.logLevel is [%s], request->data._u.SETSOALOG.logDir[%s]",
						   request->data._u.SETSOALOG.logLevel, request->data._u.SETSOALOG.logDir);
					Soa_log *pSoaLog = &Soa_log::Instance();
					pSoaLog->modify_soalog_config(request->data._u.SETSOALOG.logLevel, request->data._u.SETSOALOG.logDir);
					std::string logJsonConfig = pSoaLog->get_log_json_config();
					// std::string ret = skeleton->SETSOALOG(request->data._u.SETSOALOG.logLevel,request->data._u.SETSOALOG.logDir);
					carDrive_logconfig_Reply *reply_msg = carDrive_logconfig_Reply__alloc();
					reply_msg->header.relatedRequestId = request->header.requestId;
					reply_msg->data._d = carDrive_logconfig_SETSOALOG_Hash;
					reply_msg->header.remoteEx = DDS_RPC_REMOTE_EX_OK;
					StringUtil::string_copy(reply_msg->data._u.SETSOALOG.return_, logJsonConfig.data());
					skeleton->send_reply(reply_msg);
					carDrive_logconfig_Reply_free(reply_msg, DDS_FREE_ALL);
					carDrive_logconfig_Request_free(request, DDS_FREE_ALL);
				}
				void carDrive_logconfig_Deal_Invalid_Method(carDrive_logconfig_Request *request)
				{
					if (BussinessUtil::isEventType(request->data._d))
					{
						return;
					}
					// logconfig_Skeleton * skeleton = (logconfig_Skeleton*)DDSServer::get_service("logconfig_skeleton");
					logconfig_Skeleton *skeleton = &logconfig_Skeleton::get_instance();
					if (NULL == skeleton)
					{
						return;
					}
					carDrive_logconfig_Reply *reply_msg = carDrive_logconfig_Reply__alloc();
					reply_msg->header.relatedRequestId = request->header.requestId;
					reply_msg->header.remoteEx = DDS_RPC_REMOTE_METHOD_NOT_FOUND;
					skeleton->send_reply(reply_msg);
					carDrive_logconfig_Reply_free(reply_msg, DDS_FREE_ALL);
					carDrive_logconfig_Request_free(request, DDS_FREE_ALL);
				}
				void on_carDrive_logconfig_request_data_available(int32_t reader, void *arg)
				{
					dds_return_t rc;
					//printf("on_carDrive_logconfig_request_data_available\n");
					void *samples[1];
					samples[0] = carDrive_logconfig_Request__alloc();
					dds_sample_info_t infos[1];
					rc = dds_take_next(reader, samples, infos);
					if (rc < 0)
						DDS_FATAL("dds_take_next failed!\n");

					if (infos[0].valid_data)
					{
						carDrive_logconfig_Request *request = (carDrive_logconfig_Request *)samples[0];
						int32_t funID = request->data._d;
						switch (funID)
						{
						case carDrive_logconfig_SETSOALOG_Hash:
						{
							DDSServer::execute(carDrive_logconfig_SETSOALOG, request);
							break;
						}
						default:
						{
							DDSServer::execute(carDrive_logconfig_Deal_Invalid_Method, request);
							break;
						}
						}
						return;
					}
					carDrive_logconfig_Request_free(samples[0], DDS_FREE_ALL);
				}
				logconfig_Skeleton::logconfig_Skeleton(logconfig_service_interface *service, std::string config) : _config(config), _service(service) {}

				void on_logconfig_request_subscription_matched_cb(dds_entity_t reader, const dds_subscription_matched_status_t status, void *arg)
				{
					logconfig_Skeleton *skeleton = (logconfig_Skeleton *)com::changan::rpc_service::DDSServer::get_service("logconfig_skeleton");
					if (NULL == skeleton)
					{
						return;
					}
					auto handler = skeleton->get_consumer_matched_handler();
					if (NULL != handler)
					{
						ConsumerMatchedStatus data = DDSUtil::get_consumer_matched_status(reader, status);
						handler(data);
					}
				}

				void logconfig_Skeleton::wait_client_online()
				{
					this->wait_for_pub_online(dds_rpc_reply_handle.writer);
				}

				bool logconfig_Skeleton::init(std::string config)
				{
					//printf("logconfig_Skeleton::init\r\n");
					std::lock_guard<std::mutex> guard(init_mutex);
					if (this->init_flag)
					{
						return true;
					}
					Soa_log::Instance().init_soaLog();
					DDSUtil::event_pub_init(DDS_DOMAIN_ID,
											string("GW_ALL") + "_reply",
											&carDrive_logconfig_Reply_desc,
											&dds_rpc_reply_handle,
											NULL, {PROXY_TOKEN, PROXY_TOKEN, ""}, config);
					DDSUtil::event_sub_init(DDS_DOMAIN_ID,
											string("GW_ALL") + "_request",
											&carDrive_logconfig_Request_desc,
											&on_carDrive_logconfig_request_data_available,
											NULL,
											&dds_rpc_request_handle,
											&on_logconfig_request_subscription_matched_cb, {PROXY_TOKEN, PROXY_TOKEN, ""}, {}, config);
					// DDSServer::register_service(&(logconfig_Skeleton::get_instance()));
					this->init_flag = true;
					return true;
				}

				bool logconfig_Skeleton::destroy()
				{
					std::lock_guard<std::mutex> guard(init_mutex);
					if (!this->init_flag)
					{
						return true;
					}
					if (!DDSUtil::dds_client_destroy(&dds_rpc_request_handle))
					{
						return false;
					}
					if (!DDSUtil::dds_client_destroy(&dds_rpc_reply_handle))
					{
						return false;
					}
					this->init_flag = false;
					return true;
				}

				dds_return_t logconfig_Skeleton::send_reply(carDrive_logconfig_Reply *reply)
				{
					return DDSUtil::send(dds_rpc_reply_handle.writer, reply);
				}

				logconfig_Skeleton &logconfig_Skeleton::get_instance()
				{
					static MySkeleton1 mySkt;
					static logconfig_Skeleton m_pSoaServerLog(&mySkt);
					return m_pSoaServerLog;
				}
			}
		}
	}
}


// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: hmi_basic_statefusion.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_hmi_5fbasic_5fstatefusion_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_hmi_5fbasic_5fstatefusion_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019002 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_hmi_5fbasic_5fstatefusion_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_hmi_5fbasic_5fstatefusion_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[9]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_hmi_5fbasic_5fstatefusion_2eproto;
namespace HmiInterface {
class ACCIACCNIDStatus;
struct ACCIACCNIDStatusDefaultTypeInternal;
extern ACCIACCNIDStatusDefaultTypeInternal _ACCIACCNIDStatus_default_instance_;
class AutoLightStatus;
struct AutoLightStatusDefaultTypeInternal;
extern AutoLightStatusDefaultTypeInternal _AutoLightStatus_default_instance_;
class BasicStateFusion;
struct BasicStateFusionDefaultTypeInternal;
extern BasicStateFusionDefaultTypeInternal _BasicStateFusion_default_instance_;
class FollowCarDis;
struct FollowCarDisDefaultTypeInternal;
extern FollowCarDisDefaultTypeInternal _FollowCarDis_default_instance_;
class Gatewaystatus;
struct GatewaystatusDefaultTypeInternal;
extern GatewaystatusDefaultTypeInternal _Gatewaystatus_default_instance_;
class LeftBSDStatus;
struct LeftBSDStatusDefaultTypeInternal;
extern LeftBSDStatusDefaultTypeInternal _LeftBSDStatus_default_instance_;
class SensorStatus;
struct SensorStatusDefaultTypeInternal;
extern SensorStatusDefaultTypeInternal _SensorStatus_default_instance_;
class Statefusion;
struct StatefusionDefaultTypeInternal;
extern StatefusionDefaultTypeInternal _Statefusion_default_instance_;
class TakeOverEyeWarning;
struct TakeOverEyeWarningDefaultTypeInternal;
extern TakeOverEyeWarningDefaultTypeInternal _TakeOverEyeWarning_default_instance_;
}  // namespace HmiInterface
PROTOBUF_NAMESPACE_OPEN
template<> ::HmiInterface::ACCIACCNIDStatus* Arena::CreateMaybeMessage<::HmiInterface::ACCIACCNIDStatus>(Arena*);
template<> ::HmiInterface::AutoLightStatus* Arena::CreateMaybeMessage<::HmiInterface::AutoLightStatus>(Arena*);
template<> ::HmiInterface::BasicStateFusion* Arena::CreateMaybeMessage<::HmiInterface::BasicStateFusion>(Arena*);
template<> ::HmiInterface::FollowCarDis* Arena::CreateMaybeMessage<::HmiInterface::FollowCarDis>(Arena*);
template<> ::HmiInterface::Gatewaystatus* Arena::CreateMaybeMessage<::HmiInterface::Gatewaystatus>(Arena*);
template<> ::HmiInterface::LeftBSDStatus* Arena::CreateMaybeMessage<::HmiInterface::LeftBSDStatus>(Arena*);
template<> ::HmiInterface::SensorStatus* Arena::CreateMaybeMessage<::HmiInterface::SensorStatus>(Arena*);
template<> ::HmiInterface::Statefusion* Arena::CreateMaybeMessage<::HmiInterface::Statefusion>(Arena*);
template<> ::HmiInterface::TakeOverEyeWarning* Arena::CreateMaybeMessage<::HmiInterface::TakeOverEyeWarning>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace HmiInterface {

// ===================================================================

class ACCIACCNIDStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HmiInterface.ACCIACCNIDStatus) */ {
 public:
  inline ACCIACCNIDStatus() : ACCIACCNIDStatus(nullptr) {}
  ~ACCIACCNIDStatus() override;
  explicit constexpr ACCIACCNIDStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ACCIACCNIDStatus(const ACCIACCNIDStatus& from);
  ACCIACCNIDStatus(ACCIACCNIDStatus&& from) noexcept
    : ACCIACCNIDStatus() {
    *this = ::std::move(from);
  }

  inline ACCIACCNIDStatus& operator=(const ACCIACCNIDStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline ACCIACCNIDStatus& operator=(ACCIACCNIDStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ACCIACCNIDStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const ACCIACCNIDStatus* internal_default_instance() {
    return reinterpret_cast<const ACCIACCNIDStatus*>(
               &_ACCIACCNIDStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ACCIACCNIDStatus& a, ACCIACCNIDStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(ACCIACCNIDStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ACCIACCNIDStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ACCIACCNIDStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ACCIACCNIDStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ACCIACCNIDStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ACCIACCNIDStatus& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ACCIACCNIDStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HmiInterface.ACCIACCNIDStatus";
  }
  protected:
  explicit ACCIACCNIDStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAdNdastatusFieldNumber = 1,
    kAdIacchwamodeFieldNumber = 2,
    kAdTjpstatusFieldNumber = 3,
    kAdAccmodeFieldNumber = 4,
  };
  // uint32 ad_ndastatus = 1;
  void clear_ad_ndastatus();
  uint32_t ad_ndastatus() const;
  void set_ad_ndastatus(uint32_t value);
  private:
  uint32_t _internal_ad_ndastatus() const;
  void _internal_set_ad_ndastatus(uint32_t value);
  public:

  // uint32 ad_iacchwamode = 2;
  void clear_ad_iacchwamode();
  uint32_t ad_iacchwamode() const;
  void set_ad_iacchwamode(uint32_t value);
  private:
  uint32_t _internal_ad_iacchwamode() const;
  void _internal_set_ad_iacchwamode(uint32_t value);
  public:

  // uint32 ad_tjpstatus = 3;
  void clear_ad_tjpstatus();
  uint32_t ad_tjpstatus() const;
  void set_ad_tjpstatus(uint32_t value);
  private:
  uint32_t _internal_ad_tjpstatus() const;
  void _internal_set_ad_tjpstatus(uint32_t value);
  public:

  // uint32 ad_accmode = 4;
  void clear_ad_accmode();
  uint32_t ad_accmode() const;
  void set_ad_accmode(uint32_t value);
  private:
  uint32_t _internal_ad_accmode() const;
  void _internal_set_ad_accmode(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:HmiInterface.ACCIACCNIDStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint32_t ad_ndastatus_;
  uint32_t ad_iacchwamode_;
  uint32_t ad_tjpstatus_;
  uint32_t ad_accmode_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_hmi_5fbasic_5fstatefusion_2eproto;
};
// -------------------------------------------------------------------

class TakeOverEyeWarning final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HmiInterface.TakeOverEyeWarning) */ {
 public:
  inline TakeOverEyeWarning() : TakeOverEyeWarning(nullptr) {}
  ~TakeOverEyeWarning() override;
  explicit constexpr TakeOverEyeWarning(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TakeOverEyeWarning(const TakeOverEyeWarning& from);
  TakeOverEyeWarning(TakeOverEyeWarning&& from) noexcept
    : TakeOverEyeWarning() {
    *this = ::std::move(from);
  }

  inline TakeOverEyeWarning& operator=(const TakeOverEyeWarning& from) {
    CopyFrom(from);
    return *this;
  }
  inline TakeOverEyeWarning& operator=(TakeOverEyeWarning&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TakeOverEyeWarning& default_instance() {
    return *internal_default_instance();
  }
  static inline const TakeOverEyeWarning* internal_default_instance() {
    return reinterpret_cast<const TakeOverEyeWarning*>(
               &_TakeOverEyeWarning_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(TakeOverEyeWarning& a, TakeOverEyeWarning& b) {
    a.Swap(&b);
  }
  inline void Swap(TakeOverEyeWarning* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TakeOverEyeWarning* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TakeOverEyeWarning* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TakeOverEyeWarning>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TakeOverEyeWarning& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TakeOverEyeWarning& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TakeOverEyeWarning* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HmiInterface.TakeOverEyeWarning";
  }
  protected:
  explicit TakeOverEyeWarning(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAdHandsonreqFieldNumber = 1,
    kAdSafetynoticeFieldNumber = 2,
    kAdLngtakeoverreqFieldNumber = 3,
    kAdDynamicwarninglevelFieldNumber = 4,
    kAdLattakeoverreqFieldNumber = 5,
    kAdsEomwarnningFieldNumber = 6,
  };
  // uint32 ad_handsonreq = 1;
  void clear_ad_handsonreq();
  uint32_t ad_handsonreq() const;
  void set_ad_handsonreq(uint32_t value);
  private:
  uint32_t _internal_ad_handsonreq() const;
  void _internal_set_ad_handsonreq(uint32_t value);
  public:

  // uint32 ad_safetynotice = 2;
  void clear_ad_safetynotice();
  uint32_t ad_safetynotice() const;
  void set_ad_safetynotice(uint32_t value);
  private:
  uint32_t _internal_ad_safetynotice() const;
  void _internal_set_ad_safetynotice(uint32_t value);
  public:

  // uint32 ad_lngtakeoverreq = 3;
  void clear_ad_lngtakeoverreq();
  uint32_t ad_lngtakeoverreq() const;
  void set_ad_lngtakeoverreq(uint32_t value);
  private:
  uint32_t _internal_ad_lngtakeoverreq() const;
  void _internal_set_ad_lngtakeoverreq(uint32_t value);
  public:

  // uint32 ad_dynamicwarninglevel = 4;
  void clear_ad_dynamicwarninglevel();
  uint32_t ad_dynamicwarninglevel() const;
  void set_ad_dynamicwarninglevel(uint32_t value);
  private:
  uint32_t _internal_ad_dynamicwarninglevel() const;
  void _internal_set_ad_dynamicwarninglevel(uint32_t value);
  public:

  // uint32 ad_lattakeoverreq = 5;
  void clear_ad_lattakeoverreq();
  uint32_t ad_lattakeoverreq() const;
  void set_ad_lattakeoverreq(uint32_t value);
  private:
  uint32_t _internal_ad_lattakeoverreq() const;
  void _internal_set_ad_lattakeoverreq(uint32_t value);
  public:

  // uint32 ads_eomwarnning = 6;
  void clear_ads_eomwarnning();
  uint32_t ads_eomwarnning() const;
  void set_ads_eomwarnning(uint32_t value);
  private:
  uint32_t _internal_ads_eomwarnning() const;
  void _internal_set_ads_eomwarnning(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:HmiInterface.TakeOverEyeWarning)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint32_t ad_handsonreq_;
  uint32_t ad_safetynotice_;
  uint32_t ad_lngtakeoverreq_;
  uint32_t ad_dynamicwarninglevel_;
  uint32_t ad_lattakeoverreq_;
  uint32_t ads_eomwarnning_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_hmi_5fbasic_5fstatefusion_2eproto;
};
// -------------------------------------------------------------------

class FollowCarDis final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HmiInterface.FollowCarDis) */ {
 public:
  inline FollowCarDis() : FollowCarDis(nullptr) {}
  ~FollowCarDis() override;
  explicit constexpr FollowCarDis(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FollowCarDis(const FollowCarDis& from);
  FollowCarDis(FollowCarDis&& from) noexcept
    : FollowCarDis() {
    *this = ::std::move(from);
  }

  inline FollowCarDis& operator=(const FollowCarDis& from) {
    CopyFrom(from);
    return *this;
  }
  inline FollowCarDis& operator=(FollowCarDis&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FollowCarDis& default_instance() {
    return *internal_default_instance();
  }
  static inline const FollowCarDis* internal_default_instance() {
    return reinterpret_cast<const FollowCarDis*>(
               &_FollowCarDis_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(FollowCarDis& a, FollowCarDis& b) {
    a.Swap(&b);
  }
  inline void Swap(FollowCarDis* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FollowCarDis* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FollowCarDis* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FollowCarDis>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FollowCarDis& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FollowCarDis& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FollowCarDis* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HmiInterface.FollowCarDis";
  }
  protected:
  explicit FollowCarDis(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccDistancelevelFieldNumber = 1,
  };
  // uint32 acc_distancelevel = 1;
  void clear_acc_distancelevel();
  uint32_t acc_distancelevel() const;
  void set_acc_distancelevel(uint32_t value);
  private:
  uint32_t _internal_acc_distancelevel() const;
  void _internal_set_acc_distancelevel(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:HmiInterface.FollowCarDis)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint32_t acc_distancelevel_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_hmi_5fbasic_5fstatefusion_2eproto;
};
// -------------------------------------------------------------------

class LeftBSDStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HmiInterface.LeftBSDStatus) */ {
 public:
  inline LeftBSDStatus() : LeftBSDStatus(nullptr) {}
  ~LeftBSDStatus() override;
  explicit constexpr LeftBSDStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LeftBSDStatus(const LeftBSDStatus& from);
  LeftBSDStatus(LeftBSDStatus&& from) noexcept
    : LeftBSDStatus() {
    *this = ::std::move(from);
  }

  inline LeftBSDStatus& operator=(const LeftBSDStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline LeftBSDStatus& operator=(LeftBSDStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LeftBSDStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const LeftBSDStatus* internal_default_instance() {
    return reinterpret_cast<const LeftBSDStatus*>(
               &_LeftBSDStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(LeftBSDStatus& a, LeftBSDStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(LeftBSDStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LeftBSDStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LeftBSDStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LeftBSDStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LeftBSDStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LeftBSDStatus& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LeftBSDStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HmiInterface.LeftBSDStatus";
  }
  protected:
  explicit LeftBSDStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLcdarLeftBsdLcaalertFieldNumber = 1,
    kLcdarBsdLcaalertFieldNumber = 2,
  };
  // uint32 lcdar_left_bsd_lcaalert = 1;
  void clear_lcdar_left_bsd_lcaalert();
  uint32_t lcdar_left_bsd_lcaalert() const;
  void set_lcdar_left_bsd_lcaalert(uint32_t value);
  private:
  uint32_t _internal_lcdar_left_bsd_lcaalert() const;
  void _internal_set_lcdar_left_bsd_lcaalert(uint32_t value);
  public:

  // uint32 lcdar_bsd_lcaalert = 2;
  void clear_lcdar_bsd_lcaalert();
  uint32_t lcdar_bsd_lcaalert() const;
  void set_lcdar_bsd_lcaalert(uint32_t value);
  private:
  uint32_t _internal_lcdar_bsd_lcaalert() const;
  void _internal_set_lcdar_bsd_lcaalert(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:HmiInterface.LeftBSDStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint32_t lcdar_left_bsd_lcaalert_;
  uint32_t lcdar_bsd_lcaalert_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_hmi_5fbasic_5fstatefusion_2eproto;
};
// -------------------------------------------------------------------

class SensorStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HmiInterface.SensorStatus) */ {
 public:
  inline SensorStatus() : SensorStatus(nullptr) {}
  ~SensorStatus() override;
  explicit constexpr SensorStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SensorStatus(const SensorStatus& from);
  SensorStatus(SensorStatus&& from) noexcept
    : SensorStatus() {
    *this = ::std::move(from);
  }

  inline SensorStatus& operator=(const SensorStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline SensorStatus& operator=(SensorStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SensorStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const SensorStatus* internal_default_instance() {
    return reinterpret_cast<const SensorStatus*>(
               &_SensorStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(SensorStatus& a, SensorStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(SensorStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SensorStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SensorStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SensorStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SensorStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SensorStatus& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SensorStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HmiInterface.SensorStatus";
  }
  protected:
  explicit SensorStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccFradarfailurestatusFieldNumber = 1,
    kAccFradarcalibrationstatusFieldNumber = 2,
    kLasFrontcamerafailurestatusFieldNumber = 3,
    kLasFrontcameracalibrationstatusFieldNumber = 4,
    kAdsFlcSystemstatusFieldNumber = 5,
    kAdsFrcSystemstatusFieldNumber = 6,
    kLcdalSystemstatusFieldNumber = 7,
    kLcdarSystemstatusFieldNumber = 8,
  };
  // uint32 acc_fradarfailurestatus = 1;
  void clear_acc_fradarfailurestatus();
  uint32_t acc_fradarfailurestatus() const;
  void set_acc_fradarfailurestatus(uint32_t value);
  private:
  uint32_t _internal_acc_fradarfailurestatus() const;
  void _internal_set_acc_fradarfailurestatus(uint32_t value);
  public:

  // uint32 acc_fradarcalibrationstatus = 2;
  void clear_acc_fradarcalibrationstatus();
  uint32_t acc_fradarcalibrationstatus() const;
  void set_acc_fradarcalibrationstatus(uint32_t value);
  private:
  uint32_t _internal_acc_fradarcalibrationstatus() const;
  void _internal_set_acc_fradarcalibrationstatus(uint32_t value);
  public:

  // uint32 las_frontcamerafailurestatus = 3;
  void clear_las_frontcamerafailurestatus();
  uint32_t las_frontcamerafailurestatus() const;
  void set_las_frontcamerafailurestatus(uint32_t value);
  private:
  uint32_t _internal_las_frontcamerafailurestatus() const;
  void _internal_set_las_frontcamerafailurestatus(uint32_t value);
  public:

  // uint32 las_frontcameracalibrationstatus = 4;
  void clear_las_frontcameracalibrationstatus();
  uint32_t las_frontcameracalibrationstatus() const;
  void set_las_frontcameracalibrationstatus(uint32_t value);
  private:
  uint32_t _internal_las_frontcameracalibrationstatus() const;
  void _internal_set_las_frontcameracalibrationstatus(uint32_t value);
  public:

  // uint32 ads_flc_systemstatus = 5;
  void clear_ads_flc_systemstatus();
  uint32_t ads_flc_systemstatus() const;
  void set_ads_flc_systemstatus(uint32_t value);
  private:
  uint32_t _internal_ads_flc_systemstatus() const;
  void _internal_set_ads_flc_systemstatus(uint32_t value);
  public:

  // uint32 ads_frc_systemstatus = 6;
  void clear_ads_frc_systemstatus();
  uint32_t ads_frc_systemstatus() const;
  void set_ads_frc_systemstatus(uint32_t value);
  private:
  uint32_t _internal_ads_frc_systemstatus() const;
  void _internal_set_ads_frc_systemstatus(uint32_t value);
  public:

  // uint32 lcdal_systemstatus = 7;
  void clear_lcdal_systemstatus();
  uint32_t lcdal_systemstatus() const;
  void set_lcdal_systemstatus(uint32_t value);
  private:
  uint32_t _internal_lcdal_systemstatus() const;
  void _internal_set_lcdal_systemstatus(uint32_t value);
  public:

  // uint32 lcdar_systemstatus = 8;
  void clear_lcdar_systemstatus();
  uint32_t lcdar_systemstatus() const;
  void set_lcdar_systemstatus(uint32_t value);
  private:
  uint32_t _internal_lcdar_systemstatus() const;
  void _internal_set_lcdar_systemstatus(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:HmiInterface.SensorStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint32_t acc_fradarfailurestatus_;
  uint32_t acc_fradarcalibrationstatus_;
  uint32_t las_frontcamerafailurestatus_;
  uint32_t las_frontcameracalibrationstatus_;
  uint32_t ads_flc_systemstatus_;
  uint32_t ads_frc_systemstatus_;
  uint32_t lcdal_systemstatus_;
  uint32_t lcdar_systemstatus_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_hmi_5fbasic_5fstatefusion_2eproto;
};
// -------------------------------------------------------------------

class Gatewaystatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HmiInterface.Gatewaystatus) */ {
 public:
  inline Gatewaystatus() : Gatewaystatus(nullptr) {}
  ~Gatewaystatus() override;
  explicit constexpr Gatewaystatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Gatewaystatus(const Gatewaystatus& from);
  Gatewaystatus(Gatewaystatus&& from) noexcept
    : Gatewaystatus() {
    *this = ::std::move(from);
  }

  inline Gatewaystatus& operator=(const Gatewaystatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline Gatewaystatus& operator=(Gatewaystatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Gatewaystatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const Gatewaystatus* internal_default_instance() {
    return reinterpret_cast<const Gatewaystatus*>(
               &_Gatewaystatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Gatewaystatus& a, Gatewaystatus& b) {
    a.Swap(&b);
  }
  inline void Swap(Gatewaystatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Gatewaystatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Gatewaystatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Gatewaystatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Gatewaystatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Gatewaystatus& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Gatewaystatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HmiInterface.Gatewaystatus";
  }
  protected:
  explicit Gatewaystatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWAdssecocverifyfailureflagFieldNumber = 1,
  };
  // uint32 w_adssecocverifyfailureflag = 1;
  void clear_w_adssecocverifyfailureflag();
  uint32_t w_adssecocverifyfailureflag() const;
  void set_w_adssecocverifyfailureflag(uint32_t value);
  private:
  uint32_t _internal_w_adssecocverifyfailureflag() const;
  void _internal_set_w_adssecocverifyfailureflag(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:HmiInterface.Gatewaystatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint32_t w_adssecocverifyfailureflag_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_hmi_5fbasic_5fstatefusion_2eproto;
};
// -------------------------------------------------------------------

class AutoLightStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HmiInterface.AutoLightStatus) */ {
 public:
  inline AutoLightStatus() : AutoLightStatus(nullptr) {}
  ~AutoLightStatus() override;
  explicit constexpr AutoLightStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AutoLightStatus(const AutoLightStatus& from);
  AutoLightStatus(AutoLightStatus&& from) noexcept
    : AutoLightStatus() {
    *this = ::std::move(from);
  }

  inline AutoLightStatus& operator=(const AutoLightStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline AutoLightStatus& operator=(AutoLightStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AutoLightStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const AutoLightStatus* internal_default_instance() {
    return reinterpret_cast<const AutoLightStatus*>(
               &_AutoLightStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(AutoLightStatus& a, AutoLightStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(AutoLightStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AutoLightStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AutoLightStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AutoLightStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AutoLightStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AutoLightStatus& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AutoLightStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HmiInterface.AutoLightStatus";
  }
  protected:
  explicit AutoLightStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLasHmastatusFieldNumber = 1,
  };
  // uint32 las_hmastatus = 1;
  void clear_las_hmastatus();
  uint32_t las_hmastatus() const;
  void set_las_hmastatus(uint32_t value);
  private:
  uint32_t _internal_las_hmastatus() const;
  void _internal_set_las_hmastatus(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:HmiInterface.AutoLightStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint32_t las_hmastatus_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_hmi_5fbasic_5fstatefusion_2eproto;
};
// -------------------------------------------------------------------

class Statefusion final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HmiInterface.Statefusion) */ {
 public:
  inline Statefusion() : Statefusion(nullptr) {}
  ~Statefusion() override;
  explicit constexpr Statefusion(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Statefusion(const Statefusion& from);
  Statefusion(Statefusion&& from) noexcept
    : Statefusion() {
    *this = ::std::move(from);
  }

  inline Statefusion& operator=(const Statefusion& from) {
    CopyFrom(from);
    return *this;
  }
  inline Statefusion& operator=(Statefusion&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Statefusion& default_instance() {
    return *internal_default_instance();
  }
  static inline const Statefusion* internal_default_instance() {
    return reinterpret_cast<const Statefusion*>(
               &_Statefusion_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Statefusion& a, Statefusion& b) {
    a.Swap(&b);
  }
  inline void Swap(Statefusion* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Statefusion* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Statefusion* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Statefusion>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Statefusion& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Statefusion& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Statefusion* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HmiInterface.Statefusion";
  }
  protected:
  explicit Statefusion(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAutolightstatusFieldNumber = 1,
    kGatewaystatusFieldNumber = 2,
    kSensorstatusFieldNumber = 3,
    kLrbsdstatusFieldNumber = 4,
    kAccdislevelFieldNumber = 5,
    kTakeovereyewarningFieldNumber = 6,
    kAcciaccnidstatusFieldNumber = 7,
  };
  // .HmiInterface.AutoLightStatus autolightstatus = 1;
  bool has_autolightstatus() const;
  private:
  bool _internal_has_autolightstatus() const;
  public:
  void clear_autolightstatus();
  const ::HmiInterface::AutoLightStatus& autolightstatus() const;
  PROTOBUF_NODISCARD ::HmiInterface::AutoLightStatus* release_autolightstatus();
  ::HmiInterface::AutoLightStatus* mutable_autolightstatus();
  void set_allocated_autolightstatus(::HmiInterface::AutoLightStatus* autolightstatus);
  private:
  const ::HmiInterface::AutoLightStatus& _internal_autolightstatus() const;
  ::HmiInterface::AutoLightStatus* _internal_mutable_autolightstatus();
  public:
  void unsafe_arena_set_allocated_autolightstatus(
      ::HmiInterface::AutoLightStatus* autolightstatus);
  ::HmiInterface::AutoLightStatus* unsafe_arena_release_autolightstatus();

  // .HmiInterface.Gatewaystatus gatewaystatus = 2;
  bool has_gatewaystatus() const;
  private:
  bool _internal_has_gatewaystatus() const;
  public:
  void clear_gatewaystatus();
  const ::HmiInterface::Gatewaystatus& gatewaystatus() const;
  PROTOBUF_NODISCARD ::HmiInterface::Gatewaystatus* release_gatewaystatus();
  ::HmiInterface::Gatewaystatus* mutable_gatewaystatus();
  void set_allocated_gatewaystatus(::HmiInterface::Gatewaystatus* gatewaystatus);
  private:
  const ::HmiInterface::Gatewaystatus& _internal_gatewaystatus() const;
  ::HmiInterface::Gatewaystatus* _internal_mutable_gatewaystatus();
  public:
  void unsafe_arena_set_allocated_gatewaystatus(
      ::HmiInterface::Gatewaystatus* gatewaystatus);
  ::HmiInterface::Gatewaystatus* unsafe_arena_release_gatewaystatus();

  // .HmiInterface.SensorStatus sensorstatus = 3;
  bool has_sensorstatus() const;
  private:
  bool _internal_has_sensorstatus() const;
  public:
  void clear_sensorstatus();
  const ::HmiInterface::SensorStatus& sensorstatus() const;
  PROTOBUF_NODISCARD ::HmiInterface::SensorStatus* release_sensorstatus();
  ::HmiInterface::SensorStatus* mutable_sensorstatus();
  void set_allocated_sensorstatus(::HmiInterface::SensorStatus* sensorstatus);
  private:
  const ::HmiInterface::SensorStatus& _internal_sensorstatus() const;
  ::HmiInterface::SensorStatus* _internal_mutable_sensorstatus();
  public:
  void unsafe_arena_set_allocated_sensorstatus(
      ::HmiInterface::SensorStatus* sensorstatus);
  ::HmiInterface::SensorStatus* unsafe_arena_release_sensorstatus();

  // .HmiInterface.LeftBSDStatus lrbsdstatus = 4;
  bool has_lrbsdstatus() const;
  private:
  bool _internal_has_lrbsdstatus() const;
  public:
  void clear_lrbsdstatus();
  const ::HmiInterface::LeftBSDStatus& lrbsdstatus() const;
  PROTOBUF_NODISCARD ::HmiInterface::LeftBSDStatus* release_lrbsdstatus();
  ::HmiInterface::LeftBSDStatus* mutable_lrbsdstatus();
  void set_allocated_lrbsdstatus(::HmiInterface::LeftBSDStatus* lrbsdstatus);
  private:
  const ::HmiInterface::LeftBSDStatus& _internal_lrbsdstatus() const;
  ::HmiInterface::LeftBSDStatus* _internal_mutable_lrbsdstatus();
  public:
  void unsafe_arena_set_allocated_lrbsdstatus(
      ::HmiInterface::LeftBSDStatus* lrbsdstatus);
  ::HmiInterface::LeftBSDStatus* unsafe_arena_release_lrbsdstatus();

  // .HmiInterface.FollowCarDis accdislevel = 5;
  bool has_accdislevel() const;
  private:
  bool _internal_has_accdislevel() const;
  public:
  void clear_accdislevel();
  const ::HmiInterface::FollowCarDis& accdislevel() const;
  PROTOBUF_NODISCARD ::HmiInterface::FollowCarDis* release_accdislevel();
  ::HmiInterface::FollowCarDis* mutable_accdislevel();
  void set_allocated_accdislevel(::HmiInterface::FollowCarDis* accdislevel);
  private:
  const ::HmiInterface::FollowCarDis& _internal_accdislevel() const;
  ::HmiInterface::FollowCarDis* _internal_mutable_accdislevel();
  public:
  void unsafe_arena_set_allocated_accdislevel(
      ::HmiInterface::FollowCarDis* accdislevel);
  ::HmiInterface::FollowCarDis* unsafe_arena_release_accdislevel();

  // .HmiInterface.TakeOverEyeWarning takeovereyewarning = 6;
  bool has_takeovereyewarning() const;
  private:
  bool _internal_has_takeovereyewarning() const;
  public:
  void clear_takeovereyewarning();
  const ::HmiInterface::TakeOverEyeWarning& takeovereyewarning() const;
  PROTOBUF_NODISCARD ::HmiInterface::TakeOverEyeWarning* release_takeovereyewarning();
  ::HmiInterface::TakeOverEyeWarning* mutable_takeovereyewarning();
  void set_allocated_takeovereyewarning(::HmiInterface::TakeOverEyeWarning* takeovereyewarning);
  private:
  const ::HmiInterface::TakeOverEyeWarning& _internal_takeovereyewarning() const;
  ::HmiInterface::TakeOverEyeWarning* _internal_mutable_takeovereyewarning();
  public:
  void unsafe_arena_set_allocated_takeovereyewarning(
      ::HmiInterface::TakeOverEyeWarning* takeovereyewarning);
  ::HmiInterface::TakeOverEyeWarning* unsafe_arena_release_takeovereyewarning();

  // .HmiInterface.ACCIACCNIDStatus acciaccnidstatus = 7;
  bool has_acciaccnidstatus() const;
  private:
  bool _internal_has_acciaccnidstatus() const;
  public:
  void clear_acciaccnidstatus();
  const ::HmiInterface::ACCIACCNIDStatus& acciaccnidstatus() const;
  PROTOBUF_NODISCARD ::HmiInterface::ACCIACCNIDStatus* release_acciaccnidstatus();
  ::HmiInterface::ACCIACCNIDStatus* mutable_acciaccnidstatus();
  void set_allocated_acciaccnidstatus(::HmiInterface::ACCIACCNIDStatus* acciaccnidstatus);
  private:
  const ::HmiInterface::ACCIACCNIDStatus& _internal_acciaccnidstatus() const;
  ::HmiInterface::ACCIACCNIDStatus* _internal_mutable_acciaccnidstatus();
  public:
  void unsafe_arena_set_allocated_acciaccnidstatus(
      ::HmiInterface::ACCIACCNIDStatus* acciaccnidstatus);
  ::HmiInterface::ACCIACCNIDStatus* unsafe_arena_release_acciaccnidstatus();

  // @@protoc_insertion_point(class_scope:HmiInterface.Statefusion)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::HmiInterface::AutoLightStatus* autolightstatus_;
  ::HmiInterface::Gatewaystatus* gatewaystatus_;
  ::HmiInterface::SensorStatus* sensorstatus_;
  ::HmiInterface::LeftBSDStatus* lrbsdstatus_;
  ::HmiInterface::FollowCarDis* accdislevel_;
  ::HmiInterface::TakeOverEyeWarning* takeovereyewarning_;
  ::HmiInterface::ACCIACCNIDStatus* acciaccnidstatus_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_hmi_5fbasic_5fstatefusion_2eproto;
};
// -------------------------------------------------------------------

class BasicStateFusion final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HmiInterface.BasicStateFusion) */ {
 public:
  inline BasicStateFusion() : BasicStateFusion(nullptr) {}
  ~BasicStateFusion() override;
  explicit constexpr BasicStateFusion(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BasicStateFusion(const BasicStateFusion& from);
  BasicStateFusion(BasicStateFusion&& from) noexcept
    : BasicStateFusion() {
    *this = ::std::move(from);
  }

  inline BasicStateFusion& operator=(const BasicStateFusion& from) {
    CopyFrom(from);
    return *this;
  }
  inline BasicStateFusion& operator=(BasicStateFusion&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BasicStateFusion& default_instance() {
    return *internal_default_instance();
  }
  static inline const BasicStateFusion* internal_default_instance() {
    return reinterpret_cast<const BasicStateFusion*>(
               &_BasicStateFusion_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(BasicStateFusion& a, BasicStateFusion& b) {
    a.Swap(&b);
  }
  inline void Swap(BasicStateFusion* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BasicStateFusion* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BasicStateFusion* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BasicStateFusion>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BasicStateFusion& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BasicStateFusion& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BasicStateFusion* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HmiInterface.BasicStateFusion";
  }
  protected:
  explicit BasicStateFusion(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFusionFieldNumber = 1,
  };
  // .HmiInterface.Statefusion status_fusion = 1;
  bool has_status_fusion() const;
  private:
  bool _internal_has_status_fusion() const;
  public:
  void clear_status_fusion();
  const ::HmiInterface::Statefusion& status_fusion() const;
  PROTOBUF_NODISCARD ::HmiInterface::Statefusion* release_status_fusion();
  ::HmiInterface::Statefusion* mutable_status_fusion();
  void set_allocated_status_fusion(::HmiInterface::Statefusion* status_fusion);
  private:
  const ::HmiInterface::Statefusion& _internal_status_fusion() const;
  ::HmiInterface::Statefusion* _internal_mutable_status_fusion();
  public:
  void unsafe_arena_set_allocated_status_fusion(
      ::HmiInterface::Statefusion* status_fusion);
  ::HmiInterface::Statefusion* unsafe_arena_release_status_fusion();

  // @@protoc_insertion_point(class_scope:HmiInterface.BasicStateFusion)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::HmiInterface::Statefusion* status_fusion_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_hmi_5fbasic_5fstatefusion_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ACCIACCNIDStatus

// uint32 ad_ndastatus = 1;
inline void ACCIACCNIDStatus::clear_ad_ndastatus() {
  ad_ndastatus_ = 0u;
}
inline uint32_t ACCIACCNIDStatus::_internal_ad_ndastatus() const {
  return ad_ndastatus_;
}
inline uint32_t ACCIACCNIDStatus::ad_ndastatus() const {
  // @@protoc_insertion_point(field_get:HmiInterface.ACCIACCNIDStatus.ad_ndastatus)
  return _internal_ad_ndastatus();
}
inline void ACCIACCNIDStatus::_internal_set_ad_ndastatus(uint32_t value) {
  
  ad_ndastatus_ = value;
}
inline void ACCIACCNIDStatus::set_ad_ndastatus(uint32_t value) {
  _internal_set_ad_ndastatus(value);
  // @@protoc_insertion_point(field_set:HmiInterface.ACCIACCNIDStatus.ad_ndastatus)
}

// uint32 ad_iacchwamode = 2;
inline void ACCIACCNIDStatus::clear_ad_iacchwamode() {
  ad_iacchwamode_ = 0u;
}
inline uint32_t ACCIACCNIDStatus::_internal_ad_iacchwamode() const {
  return ad_iacchwamode_;
}
inline uint32_t ACCIACCNIDStatus::ad_iacchwamode() const {
  // @@protoc_insertion_point(field_get:HmiInterface.ACCIACCNIDStatus.ad_iacchwamode)
  return _internal_ad_iacchwamode();
}
inline void ACCIACCNIDStatus::_internal_set_ad_iacchwamode(uint32_t value) {
  
  ad_iacchwamode_ = value;
}
inline void ACCIACCNIDStatus::set_ad_iacchwamode(uint32_t value) {
  _internal_set_ad_iacchwamode(value);
  // @@protoc_insertion_point(field_set:HmiInterface.ACCIACCNIDStatus.ad_iacchwamode)
}

// uint32 ad_tjpstatus = 3;
inline void ACCIACCNIDStatus::clear_ad_tjpstatus() {
  ad_tjpstatus_ = 0u;
}
inline uint32_t ACCIACCNIDStatus::_internal_ad_tjpstatus() const {
  return ad_tjpstatus_;
}
inline uint32_t ACCIACCNIDStatus::ad_tjpstatus() const {
  // @@protoc_insertion_point(field_get:HmiInterface.ACCIACCNIDStatus.ad_tjpstatus)
  return _internal_ad_tjpstatus();
}
inline void ACCIACCNIDStatus::_internal_set_ad_tjpstatus(uint32_t value) {
  
  ad_tjpstatus_ = value;
}
inline void ACCIACCNIDStatus::set_ad_tjpstatus(uint32_t value) {
  _internal_set_ad_tjpstatus(value);
  // @@protoc_insertion_point(field_set:HmiInterface.ACCIACCNIDStatus.ad_tjpstatus)
}

// uint32 ad_accmode = 4;
inline void ACCIACCNIDStatus::clear_ad_accmode() {
  ad_accmode_ = 0u;
}
inline uint32_t ACCIACCNIDStatus::_internal_ad_accmode() const {
  return ad_accmode_;
}
inline uint32_t ACCIACCNIDStatus::ad_accmode() const {
  // @@protoc_insertion_point(field_get:HmiInterface.ACCIACCNIDStatus.ad_accmode)
  return _internal_ad_accmode();
}
inline void ACCIACCNIDStatus::_internal_set_ad_accmode(uint32_t value) {
  
  ad_accmode_ = value;
}
inline void ACCIACCNIDStatus::set_ad_accmode(uint32_t value) {
  _internal_set_ad_accmode(value);
  // @@protoc_insertion_point(field_set:HmiInterface.ACCIACCNIDStatus.ad_accmode)
}

// -------------------------------------------------------------------

// TakeOverEyeWarning

// uint32 ad_handsonreq = 1;
inline void TakeOverEyeWarning::clear_ad_handsonreq() {
  ad_handsonreq_ = 0u;
}
inline uint32_t TakeOverEyeWarning::_internal_ad_handsonreq() const {
  return ad_handsonreq_;
}
inline uint32_t TakeOverEyeWarning::ad_handsonreq() const {
  // @@protoc_insertion_point(field_get:HmiInterface.TakeOverEyeWarning.ad_handsonreq)
  return _internal_ad_handsonreq();
}
inline void TakeOverEyeWarning::_internal_set_ad_handsonreq(uint32_t value) {
  
  ad_handsonreq_ = value;
}
inline void TakeOverEyeWarning::set_ad_handsonreq(uint32_t value) {
  _internal_set_ad_handsonreq(value);
  // @@protoc_insertion_point(field_set:HmiInterface.TakeOverEyeWarning.ad_handsonreq)
}

// uint32 ad_safetynotice = 2;
inline void TakeOverEyeWarning::clear_ad_safetynotice() {
  ad_safetynotice_ = 0u;
}
inline uint32_t TakeOverEyeWarning::_internal_ad_safetynotice() const {
  return ad_safetynotice_;
}
inline uint32_t TakeOverEyeWarning::ad_safetynotice() const {
  // @@protoc_insertion_point(field_get:HmiInterface.TakeOverEyeWarning.ad_safetynotice)
  return _internal_ad_safetynotice();
}
inline void TakeOverEyeWarning::_internal_set_ad_safetynotice(uint32_t value) {
  
  ad_safetynotice_ = value;
}
inline void TakeOverEyeWarning::set_ad_safetynotice(uint32_t value) {
  _internal_set_ad_safetynotice(value);
  // @@protoc_insertion_point(field_set:HmiInterface.TakeOverEyeWarning.ad_safetynotice)
}

// uint32 ad_lngtakeoverreq = 3;
inline void TakeOverEyeWarning::clear_ad_lngtakeoverreq() {
  ad_lngtakeoverreq_ = 0u;
}
inline uint32_t TakeOverEyeWarning::_internal_ad_lngtakeoverreq() const {
  return ad_lngtakeoverreq_;
}
inline uint32_t TakeOverEyeWarning::ad_lngtakeoverreq() const {
  // @@protoc_insertion_point(field_get:HmiInterface.TakeOverEyeWarning.ad_lngtakeoverreq)
  return _internal_ad_lngtakeoverreq();
}
inline void TakeOverEyeWarning::_internal_set_ad_lngtakeoverreq(uint32_t value) {
  
  ad_lngtakeoverreq_ = value;
}
inline void TakeOverEyeWarning::set_ad_lngtakeoverreq(uint32_t value) {
  _internal_set_ad_lngtakeoverreq(value);
  // @@protoc_insertion_point(field_set:HmiInterface.TakeOverEyeWarning.ad_lngtakeoverreq)
}

// uint32 ad_dynamicwarninglevel = 4;
inline void TakeOverEyeWarning::clear_ad_dynamicwarninglevel() {
  ad_dynamicwarninglevel_ = 0u;
}
inline uint32_t TakeOverEyeWarning::_internal_ad_dynamicwarninglevel() const {
  return ad_dynamicwarninglevel_;
}
inline uint32_t TakeOverEyeWarning::ad_dynamicwarninglevel() const {
  // @@protoc_insertion_point(field_get:HmiInterface.TakeOverEyeWarning.ad_dynamicwarninglevel)
  return _internal_ad_dynamicwarninglevel();
}
inline void TakeOverEyeWarning::_internal_set_ad_dynamicwarninglevel(uint32_t value) {
  
  ad_dynamicwarninglevel_ = value;
}
inline void TakeOverEyeWarning::set_ad_dynamicwarninglevel(uint32_t value) {
  _internal_set_ad_dynamicwarninglevel(value);
  // @@protoc_insertion_point(field_set:HmiInterface.TakeOverEyeWarning.ad_dynamicwarninglevel)
}

// uint32 ad_lattakeoverreq = 5;
inline void TakeOverEyeWarning::clear_ad_lattakeoverreq() {
  ad_lattakeoverreq_ = 0u;
}
inline uint32_t TakeOverEyeWarning::_internal_ad_lattakeoverreq() const {
  return ad_lattakeoverreq_;
}
inline uint32_t TakeOverEyeWarning::ad_lattakeoverreq() const {
  // @@protoc_insertion_point(field_get:HmiInterface.TakeOverEyeWarning.ad_lattakeoverreq)
  return _internal_ad_lattakeoverreq();
}
inline void TakeOverEyeWarning::_internal_set_ad_lattakeoverreq(uint32_t value) {
  
  ad_lattakeoverreq_ = value;
}
inline void TakeOverEyeWarning::set_ad_lattakeoverreq(uint32_t value) {
  _internal_set_ad_lattakeoverreq(value);
  // @@protoc_insertion_point(field_set:HmiInterface.TakeOverEyeWarning.ad_lattakeoverreq)
}

// uint32 ads_eomwarnning = 6;
inline void TakeOverEyeWarning::clear_ads_eomwarnning() {
  ads_eomwarnning_ = 0u;
}
inline uint32_t TakeOverEyeWarning::_internal_ads_eomwarnning() const {
  return ads_eomwarnning_;
}
inline uint32_t TakeOverEyeWarning::ads_eomwarnning() const {
  // @@protoc_insertion_point(field_get:HmiInterface.TakeOverEyeWarning.ads_eomwarnning)
  return _internal_ads_eomwarnning();
}
inline void TakeOverEyeWarning::_internal_set_ads_eomwarnning(uint32_t value) {
  
  ads_eomwarnning_ = value;
}
inline void TakeOverEyeWarning::set_ads_eomwarnning(uint32_t value) {
  _internal_set_ads_eomwarnning(value);
  // @@protoc_insertion_point(field_set:HmiInterface.TakeOverEyeWarning.ads_eomwarnning)
}

// -------------------------------------------------------------------

// FollowCarDis

// uint32 acc_distancelevel = 1;
inline void FollowCarDis::clear_acc_distancelevel() {
  acc_distancelevel_ = 0u;
}
inline uint32_t FollowCarDis::_internal_acc_distancelevel() const {
  return acc_distancelevel_;
}
inline uint32_t FollowCarDis::acc_distancelevel() const {
  // @@protoc_insertion_point(field_get:HmiInterface.FollowCarDis.acc_distancelevel)
  return _internal_acc_distancelevel();
}
inline void FollowCarDis::_internal_set_acc_distancelevel(uint32_t value) {
  
  acc_distancelevel_ = value;
}
inline void FollowCarDis::set_acc_distancelevel(uint32_t value) {
  _internal_set_acc_distancelevel(value);
  // @@protoc_insertion_point(field_set:HmiInterface.FollowCarDis.acc_distancelevel)
}

// -------------------------------------------------------------------

// LeftBSDStatus

// uint32 lcdar_left_bsd_lcaalert = 1;
inline void LeftBSDStatus::clear_lcdar_left_bsd_lcaalert() {
  lcdar_left_bsd_lcaalert_ = 0u;
}
inline uint32_t LeftBSDStatus::_internal_lcdar_left_bsd_lcaalert() const {
  return lcdar_left_bsd_lcaalert_;
}
inline uint32_t LeftBSDStatus::lcdar_left_bsd_lcaalert() const {
  // @@protoc_insertion_point(field_get:HmiInterface.LeftBSDStatus.lcdar_left_bsd_lcaalert)
  return _internal_lcdar_left_bsd_lcaalert();
}
inline void LeftBSDStatus::_internal_set_lcdar_left_bsd_lcaalert(uint32_t value) {
  
  lcdar_left_bsd_lcaalert_ = value;
}
inline void LeftBSDStatus::set_lcdar_left_bsd_lcaalert(uint32_t value) {
  _internal_set_lcdar_left_bsd_lcaalert(value);
  // @@protoc_insertion_point(field_set:HmiInterface.LeftBSDStatus.lcdar_left_bsd_lcaalert)
}

// uint32 lcdar_bsd_lcaalert = 2;
inline void LeftBSDStatus::clear_lcdar_bsd_lcaalert() {
  lcdar_bsd_lcaalert_ = 0u;
}
inline uint32_t LeftBSDStatus::_internal_lcdar_bsd_lcaalert() const {
  return lcdar_bsd_lcaalert_;
}
inline uint32_t LeftBSDStatus::lcdar_bsd_lcaalert() const {
  // @@protoc_insertion_point(field_get:HmiInterface.LeftBSDStatus.lcdar_bsd_lcaalert)
  return _internal_lcdar_bsd_lcaalert();
}
inline void LeftBSDStatus::_internal_set_lcdar_bsd_lcaalert(uint32_t value) {
  
  lcdar_bsd_lcaalert_ = value;
}
inline void LeftBSDStatus::set_lcdar_bsd_lcaalert(uint32_t value) {
  _internal_set_lcdar_bsd_lcaalert(value);
  // @@protoc_insertion_point(field_set:HmiInterface.LeftBSDStatus.lcdar_bsd_lcaalert)
}

// -------------------------------------------------------------------

// SensorStatus

// uint32 acc_fradarfailurestatus = 1;
inline void SensorStatus::clear_acc_fradarfailurestatus() {
  acc_fradarfailurestatus_ = 0u;
}
inline uint32_t SensorStatus::_internal_acc_fradarfailurestatus() const {
  return acc_fradarfailurestatus_;
}
inline uint32_t SensorStatus::acc_fradarfailurestatus() const {
  // @@protoc_insertion_point(field_get:HmiInterface.SensorStatus.acc_fradarfailurestatus)
  return _internal_acc_fradarfailurestatus();
}
inline void SensorStatus::_internal_set_acc_fradarfailurestatus(uint32_t value) {
  
  acc_fradarfailurestatus_ = value;
}
inline void SensorStatus::set_acc_fradarfailurestatus(uint32_t value) {
  _internal_set_acc_fradarfailurestatus(value);
  // @@protoc_insertion_point(field_set:HmiInterface.SensorStatus.acc_fradarfailurestatus)
}

// uint32 acc_fradarcalibrationstatus = 2;
inline void SensorStatus::clear_acc_fradarcalibrationstatus() {
  acc_fradarcalibrationstatus_ = 0u;
}
inline uint32_t SensorStatus::_internal_acc_fradarcalibrationstatus() const {
  return acc_fradarcalibrationstatus_;
}
inline uint32_t SensorStatus::acc_fradarcalibrationstatus() const {
  // @@protoc_insertion_point(field_get:HmiInterface.SensorStatus.acc_fradarcalibrationstatus)
  return _internal_acc_fradarcalibrationstatus();
}
inline void SensorStatus::_internal_set_acc_fradarcalibrationstatus(uint32_t value) {
  
  acc_fradarcalibrationstatus_ = value;
}
inline void SensorStatus::set_acc_fradarcalibrationstatus(uint32_t value) {
  _internal_set_acc_fradarcalibrationstatus(value);
  // @@protoc_insertion_point(field_set:HmiInterface.SensorStatus.acc_fradarcalibrationstatus)
}

// uint32 las_frontcamerafailurestatus = 3;
inline void SensorStatus::clear_las_frontcamerafailurestatus() {
  las_frontcamerafailurestatus_ = 0u;
}
inline uint32_t SensorStatus::_internal_las_frontcamerafailurestatus() const {
  return las_frontcamerafailurestatus_;
}
inline uint32_t SensorStatus::las_frontcamerafailurestatus() const {
  // @@protoc_insertion_point(field_get:HmiInterface.SensorStatus.las_frontcamerafailurestatus)
  return _internal_las_frontcamerafailurestatus();
}
inline void SensorStatus::_internal_set_las_frontcamerafailurestatus(uint32_t value) {
  
  las_frontcamerafailurestatus_ = value;
}
inline void SensorStatus::set_las_frontcamerafailurestatus(uint32_t value) {
  _internal_set_las_frontcamerafailurestatus(value);
  // @@protoc_insertion_point(field_set:HmiInterface.SensorStatus.las_frontcamerafailurestatus)
}

// uint32 las_frontcameracalibrationstatus = 4;
inline void SensorStatus::clear_las_frontcameracalibrationstatus() {
  las_frontcameracalibrationstatus_ = 0u;
}
inline uint32_t SensorStatus::_internal_las_frontcameracalibrationstatus() const {
  return las_frontcameracalibrationstatus_;
}
inline uint32_t SensorStatus::las_frontcameracalibrationstatus() const {
  // @@protoc_insertion_point(field_get:HmiInterface.SensorStatus.las_frontcameracalibrationstatus)
  return _internal_las_frontcameracalibrationstatus();
}
inline void SensorStatus::_internal_set_las_frontcameracalibrationstatus(uint32_t value) {
  
  las_frontcameracalibrationstatus_ = value;
}
inline void SensorStatus::set_las_frontcameracalibrationstatus(uint32_t value) {
  _internal_set_las_frontcameracalibrationstatus(value);
  // @@protoc_insertion_point(field_set:HmiInterface.SensorStatus.las_frontcameracalibrationstatus)
}

// uint32 ads_flc_systemstatus = 5;
inline void SensorStatus::clear_ads_flc_systemstatus() {
  ads_flc_systemstatus_ = 0u;
}
inline uint32_t SensorStatus::_internal_ads_flc_systemstatus() const {
  return ads_flc_systemstatus_;
}
inline uint32_t SensorStatus::ads_flc_systemstatus() const {
  // @@protoc_insertion_point(field_get:HmiInterface.SensorStatus.ads_flc_systemstatus)
  return _internal_ads_flc_systemstatus();
}
inline void SensorStatus::_internal_set_ads_flc_systemstatus(uint32_t value) {
  
  ads_flc_systemstatus_ = value;
}
inline void SensorStatus::set_ads_flc_systemstatus(uint32_t value) {
  _internal_set_ads_flc_systemstatus(value);
  // @@protoc_insertion_point(field_set:HmiInterface.SensorStatus.ads_flc_systemstatus)
}

// uint32 ads_frc_systemstatus = 6;
inline void SensorStatus::clear_ads_frc_systemstatus() {
  ads_frc_systemstatus_ = 0u;
}
inline uint32_t SensorStatus::_internal_ads_frc_systemstatus() const {
  return ads_frc_systemstatus_;
}
inline uint32_t SensorStatus::ads_frc_systemstatus() const {
  // @@protoc_insertion_point(field_get:HmiInterface.SensorStatus.ads_frc_systemstatus)
  return _internal_ads_frc_systemstatus();
}
inline void SensorStatus::_internal_set_ads_frc_systemstatus(uint32_t value) {
  
  ads_frc_systemstatus_ = value;
}
inline void SensorStatus::set_ads_frc_systemstatus(uint32_t value) {
  _internal_set_ads_frc_systemstatus(value);
  // @@protoc_insertion_point(field_set:HmiInterface.SensorStatus.ads_frc_systemstatus)
}

// uint32 lcdal_systemstatus = 7;
inline void SensorStatus::clear_lcdal_systemstatus() {
  lcdal_systemstatus_ = 0u;
}
inline uint32_t SensorStatus::_internal_lcdal_systemstatus() const {
  return lcdal_systemstatus_;
}
inline uint32_t SensorStatus::lcdal_systemstatus() const {
  // @@protoc_insertion_point(field_get:HmiInterface.SensorStatus.lcdal_systemstatus)
  return _internal_lcdal_systemstatus();
}
inline void SensorStatus::_internal_set_lcdal_systemstatus(uint32_t value) {
  
  lcdal_systemstatus_ = value;
}
inline void SensorStatus::set_lcdal_systemstatus(uint32_t value) {
  _internal_set_lcdal_systemstatus(value);
  // @@protoc_insertion_point(field_set:HmiInterface.SensorStatus.lcdal_systemstatus)
}

// uint32 lcdar_systemstatus = 8;
inline void SensorStatus::clear_lcdar_systemstatus() {
  lcdar_systemstatus_ = 0u;
}
inline uint32_t SensorStatus::_internal_lcdar_systemstatus() const {
  return lcdar_systemstatus_;
}
inline uint32_t SensorStatus::lcdar_systemstatus() const {
  // @@protoc_insertion_point(field_get:HmiInterface.SensorStatus.lcdar_systemstatus)
  return _internal_lcdar_systemstatus();
}
inline void SensorStatus::_internal_set_lcdar_systemstatus(uint32_t value) {
  
  lcdar_systemstatus_ = value;
}
inline void SensorStatus::set_lcdar_systemstatus(uint32_t value) {
  _internal_set_lcdar_systemstatus(value);
  // @@protoc_insertion_point(field_set:HmiInterface.SensorStatus.lcdar_systemstatus)
}

// -------------------------------------------------------------------

// Gatewaystatus

// uint32 w_adssecocverifyfailureflag = 1;
inline void Gatewaystatus::clear_w_adssecocverifyfailureflag() {
  w_adssecocverifyfailureflag_ = 0u;
}
inline uint32_t Gatewaystatus::_internal_w_adssecocverifyfailureflag() const {
  return w_adssecocverifyfailureflag_;
}
inline uint32_t Gatewaystatus::w_adssecocverifyfailureflag() const {
  // @@protoc_insertion_point(field_get:HmiInterface.Gatewaystatus.w_adssecocverifyfailureflag)
  return _internal_w_adssecocverifyfailureflag();
}
inline void Gatewaystatus::_internal_set_w_adssecocverifyfailureflag(uint32_t value) {
  
  w_adssecocverifyfailureflag_ = value;
}
inline void Gatewaystatus::set_w_adssecocverifyfailureflag(uint32_t value) {
  _internal_set_w_adssecocverifyfailureflag(value);
  // @@protoc_insertion_point(field_set:HmiInterface.Gatewaystatus.w_adssecocverifyfailureflag)
}

// -------------------------------------------------------------------

// AutoLightStatus

// uint32 las_hmastatus = 1;
inline void AutoLightStatus::clear_las_hmastatus() {
  las_hmastatus_ = 0u;
}
inline uint32_t AutoLightStatus::_internal_las_hmastatus() const {
  return las_hmastatus_;
}
inline uint32_t AutoLightStatus::las_hmastatus() const {
  // @@protoc_insertion_point(field_get:HmiInterface.AutoLightStatus.las_hmastatus)
  return _internal_las_hmastatus();
}
inline void AutoLightStatus::_internal_set_las_hmastatus(uint32_t value) {
  
  las_hmastatus_ = value;
}
inline void AutoLightStatus::set_las_hmastatus(uint32_t value) {
  _internal_set_las_hmastatus(value);
  // @@protoc_insertion_point(field_set:HmiInterface.AutoLightStatus.las_hmastatus)
}

// -------------------------------------------------------------------

// Statefusion

// .HmiInterface.AutoLightStatus autolightstatus = 1;
inline bool Statefusion::_internal_has_autolightstatus() const {
  return this != internal_default_instance() && autolightstatus_ != nullptr;
}
inline bool Statefusion::has_autolightstatus() const {
  return _internal_has_autolightstatus();
}
inline void Statefusion::clear_autolightstatus() {
  if (GetArenaForAllocation() == nullptr && autolightstatus_ != nullptr) {
    delete autolightstatus_;
  }
  autolightstatus_ = nullptr;
}
inline const ::HmiInterface::AutoLightStatus& Statefusion::_internal_autolightstatus() const {
  const ::HmiInterface::AutoLightStatus* p = autolightstatus_;
  return p != nullptr ? *p : reinterpret_cast<const ::HmiInterface::AutoLightStatus&>(
      ::HmiInterface::_AutoLightStatus_default_instance_);
}
inline const ::HmiInterface::AutoLightStatus& Statefusion::autolightstatus() const {
  // @@protoc_insertion_point(field_get:HmiInterface.Statefusion.autolightstatus)
  return _internal_autolightstatus();
}
inline void Statefusion::unsafe_arena_set_allocated_autolightstatus(
    ::HmiInterface::AutoLightStatus* autolightstatus) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(autolightstatus_);
  }
  autolightstatus_ = autolightstatus;
  if (autolightstatus) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HmiInterface.Statefusion.autolightstatus)
}
inline ::HmiInterface::AutoLightStatus* Statefusion::release_autolightstatus() {
  
  ::HmiInterface::AutoLightStatus* temp = autolightstatus_;
  autolightstatus_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::HmiInterface::AutoLightStatus* Statefusion::unsafe_arena_release_autolightstatus() {
  // @@protoc_insertion_point(field_release:HmiInterface.Statefusion.autolightstatus)
  
  ::HmiInterface::AutoLightStatus* temp = autolightstatus_;
  autolightstatus_ = nullptr;
  return temp;
}
inline ::HmiInterface::AutoLightStatus* Statefusion::_internal_mutable_autolightstatus() {
  
  if (autolightstatus_ == nullptr) {
    auto* p = CreateMaybeMessage<::HmiInterface::AutoLightStatus>(GetArenaForAllocation());
    autolightstatus_ = p;
  }
  return autolightstatus_;
}
inline ::HmiInterface::AutoLightStatus* Statefusion::mutable_autolightstatus() {
  ::HmiInterface::AutoLightStatus* _msg = _internal_mutable_autolightstatus();
  // @@protoc_insertion_point(field_mutable:HmiInterface.Statefusion.autolightstatus)
  return _msg;
}
inline void Statefusion::set_allocated_autolightstatus(::HmiInterface::AutoLightStatus* autolightstatus) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete autolightstatus_;
  }
  if (autolightstatus) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::HmiInterface::AutoLightStatus>::GetOwningArena(autolightstatus);
    if (message_arena != submessage_arena) {
      autolightstatus = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, autolightstatus, submessage_arena);
    }
    
  } else {
    
  }
  autolightstatus_ = autolightstatus;
  // @@protoc_insertion_point(field_set_allocated:HmiInterface.Statefusion.autolightstatus)
}

// .HmiInterface.Gatewaystatus gatewaystatus = 2;
inline bool Statefusion::_internal_has_gatewaystatus() const {
  return this != internal_default_instance() && gatewaystatus_ != nullptr;
}
inline bool Statefusion::has_gatewaystatus() const {
  return _internal_has_gatewaystatus();
}
inline void Statefusion::clear_gatewaystatus() {
  if (GetArenaForAllocation() == nullptr && gatewaystatus_ != nullptr) {
    delete gatewaystatus_;
  }
  gatewaystatus_ = nullptr;
}
inline const ::HmiInterface::Gatewaystatus& Statefusion::_internal_gatewaystatus() const {
  const ::HmiInterface::Gatewaystatus* p = gatewaystatus_;
  return p != nullptr ? *p : reinterpret_cast<const ::HmiInterface::Gatewaystatus&>(
      ::HmiInterface::_Gatewaystatus_default_instance_);
}
inline const ::HmiInterface::Gatewaystatus& Statefusion::gatewaystatus() const {
  // @@protoc_insertion_point(field_get:HmiInterface.Statefusion.gatewaystatus)
  return _internal_gatewaystatus();
}
inline void Statefusion::unsafe_arena_set_allocated_gatewaystatus(
    ::HmiInterface::Gatewaystatus* gatewaystatus) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(gatewaystatus_);
  }
  gatewaystatus_ = gatewaystatus;
  if (gatewaystatus) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HmiInterface.Statefusion.gatewaystatus)
}
inline ::HmiInterface::Gatewaystatus* Statefusion::release_gatewaystatus() {
  
  ::HmiInterface::Gatewaystatus* temp = gatewaystatus_;
  gatewaystatus_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::HmiInterface::Gatewaystatus* Statefusion::unsafe_arena_release_gatewaystatus() {
  // @@protoc_insertion_point(field_release:HmiInterface.Statefusion.gatewaystatus)
  
  ::HmiInterface::Gatewaystatus* temp = gatewaystatus_;
  gatewaystatus_ = nullptr;
  return temp;
}
inline ::HmiInterface::Gatewaystatus* Statefusion::_internal_mutable_gatewaystatus() {
  
  if (gatewaystatus_ == nullptr) {
    auto* p = CreateMaybeMessage<::HmiInterface::Gatewaystatus>(GetArenaForAllocation());
    gatewaystatus_ = p;
  }
  return gatewaystatus_;
}
inline ::HmiInterface::Gatewaystatus* Statefusion::mutable_gatewaystatus() {
  ::HmiInterface::Gatewaystatus* _msg = _internal_mutable_gatewaystatus();
  // @@protoc_insertion_point(field_mutable:HmiInterface.Statefusion.gatewaystatus)
  return _msg;
}
inline void Statefusion::set_allocated_gatewaystatus(::HmiInterface::Gatewaystatus* gatewaystatus) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete gatewaystatus_;
  }
  if (gatewaystatus) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::HmiInterface::Gatewaystatus>::GetOwningArena(gatewaystatus);
    if (message_arena != submessage_arena) {
      gatewaystatus = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, gatewaystatus, submessage_arena);
    }
    
  } else {
    
  }
  gatewaystatus_ = gatewaystatus;
  // @@protoc_insertion_point(field_set_allocated:HmiInterface.Statefusion.gatewaystatus)
}

// .HmiInterface.SensorStatus sensorstatus = 3;
inline bool Statefusion::_internal_has_sensorstatus() const {
  return this != internal_default_instance() && sensorstatus_ != nullptr;
}
inline bool Statefusion::has_sensorstatus() const {
  return _internal_has_sensorstatus();
}
inline void Statefusion::clear_sensorstatus() {
  if (GetArenaForAllocation() == nullptr && sensorstatus_ != nullptr) {
    delete sensorstatus_;
  }
  sensorstatus_ = nullptr;
}
inline const ::HmiInterface::SensorStatus& Statefusion::_internal_sensorstatus() const {
  const ::HmiInterface::SensorStatus* p = sensorstatus_;
  return p != nullptr ? *p : reinterpret_cast<const ::HmiInterface::SensorStatus&>(
      ::HmiInterface::_SensorStatus_default_instance_);
}
inline const ::HmiInterface::SensorStatus& Statefusion::sensorstatus() const {
  // @@protoc_insertion_point(field_get:HmiInterface.Statefusion.sensorstatus)
  return _internal_sensorstatus();
}
inline void Statefusion::unsafe_arena_set_allocated_sensorstatus(
    ::HmiInterface::SensorStatus* sensorstatus) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(sensorstatus_);
  }
  sensorstatus_ = sensorstatus;
  if (sensorstatus) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HmiInterface.Statefusion.sensorstatus)
}
inline ::HmiInterface::SensorStatus* Statefusion::release_sensorstatus() {
  
  ::HmiInterface::SensorStatus* temp = sensorstatus_;
  sensorstatus_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::HmiInterface::SensorStatus* Statefusion::unsafe_arena_release_sensorstatus() {
  // @@protoc_insertion_point(field_release:HmiInterface.Statefusion.sensorstatus)
  
  ::HmiInterface::SensorStatus* temp = sensorstatus_;
  sensorstatus_ = nullptr;
  return temp;
}
inline ::HmiInterface::SensorStatus* Statefusion::_internal_mutable_sensorstatus() {
  
  if (sensorstatus_ == nullptr) {
    auto* p = CreateMaybeMessage<::HmiInterface::SensorStatus>(GetArenaForAllocation());
    sensorstatus_ = p;
  }
  return sensorstatus_;
}
inline ::HmiInterface::SensorStatus* Statefusion::mutable_sensorstatus() {
  ::HmiInterface::SensorStatus* _msg = _internal_mutable_sensorstatus();
  // @@protoc_insertion_point(field_mutable:HmiInterface.Statefusion.sensorstatus)
  return _msg;
}
inline void Statefusion::set_allocated_sensorstatus(::HmiInterface::SensorStatus* sensorstatus) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete sensorstatus_;
  }
  if (sensorstatus) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::HmiInterface::SensorStatus>::GetOwningArena(sensorstatus);
    if (message_arena != submessage_arena) {
      sensorstatus = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sensorstatus, submessage_arena);
    }
    
  } else {
    
  }
  sensorstatus_ = sensorstatus;
  // @@protoc_insertion_point(field_set_allocated:HmiInterface.Statefusion.sensorstatus)
}

// .HmiInterface.LeftBSDStatus lrbsdstatus = 4;
inline bool Statefusion::_internal_has_lrbsdstatus() const {
  return this != internal_default_instance() && lrbsdstatus_ != nullptr;
}
inline bool Statefusion::has_lrbsdstatus() const {
  return _internal_has_lrbsdstatus();
}
inline void Statefusion::clear_lrbsdstatus() {
  if (GetArenaForAllocation() == nullptr && lrbsdstatus_ != nullptr) {
    delete lrbsdstatus_;
  }
  lrbsdstatus_ = nullptr;
}
inline const ::HmiInterface::LeftBSDStatus& Statefusion::_internal_lrbsdstatus() const {
  const ::HmiInterface::LeftBSDStatus* p = lrbsdstatus_;
  return p != nullptr ? *p : reinterpret_cast<const ::HmiInterface::LeftBSDStatus&>(
      ::HmiInterface::_LeftBSDStatus_default_instance_);
}
inline const ::HmiInterface::LeftBSDStatus& Statefusion::lrbsdstatus() const {
  // @@protoc_insertion_point(field_get:HmiInterface.Statefusion.lrbsdstatus)
  return _internal_lrbsdstatus();
}
inline void Statefusion::unsafe_arena_set_allocated_lrbsdstatus(
    ::HmiInterface::LeftBSDStatus* lrbsdstatus) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(lrbsdstatus_);
  }
  lrbsdstatus_ = lrbsdstatus;
  if (lrbsdstatus) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HmiInterface.Statefusion.lrbsdstatus)
}
inline ::HmiInterface::LeftBSDStatus* Statefusion::release_lrbsdstatus() {
  
  ::HmiInterface::LeftBSDStatus* temp = lrbsdstatus_;
  lrbsdstatus_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::HmiInterface::LeftBSDStatus* Statefusion::unsafe_arena_release_lrbsdstatus() {
  // @@protoc_insertion_point(field_release:HmiInterface.Statefusion.lrbsdstatus)
  
  ::HmiInterface::LeftBSDStatus* temp = lrbsdstatus_;
  lrbsdstatus_ = nullptr;
  return temp;
}
inline ::HmiInterface::LeftBSDStatus* Statefusion::_internal_mutable_lrbsdstatus() {
  
  if (lrbsdstatus_ == nullptr) {
    auto* p = CreateMaybeMessage<::HmiInterface::LeftBSDStatus>(GetArenaForAllocation());
    lrbsdstatus_ = p;
  }
  return lrbsdstatus_;
}
inline ::HmiInterface::LeftBSDStatus* Statefusion::mutable_lrbsdstatus() {
  ::HmiInterface::LeftBSDStatus* _msg = _internal_mutable_lrbsdstatus();
  // @@protoc_insertion_point(field_mutable:HmiInterface.Statefusion.lrbsdstatus)
  return _msg;
}
inline void Statefusion::set_allocated_lrbsdstatus(::HmiInterface::LeftBSDStatus* lrbsdstatus) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete lrbsdstatus_;
  }
  if (lrbsdstatus) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::HmiInterface::LeftBSDStatus>::GetOwningArena(lrbsdstatus);
    if (message_arena != submessage_arena) {
      lrbsdstatus = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lrbsdstatus, submessage_arena);
    }
    
  } else {
    
  }
  lrbsdstatus_ = lrbsdstatus;
  // @@protoc_insertion_point(field_set_allocated:HmiInterface.Statefusion.lrbsdstatus)
}

// .HmiInterface.FollowCarDis accdislevel = 5;
inline bool Statefusion::_internal_has_accdislevel() const {
  return this != internal_default_instance() && accdislevel_ != nullptr;
}
inline bool Statefusion::has_accdislevel() const {
  return _internal_has_accdislevel();
}
inline void Statefusion::clear_accdislevel() {
  if (GetArenaForAllocation() == nullptr && accdislevel_ != nullptr) {
    delete accdislevel_;
  }
  accdislevel_ = nullptr;
}
inline const ::HmiInterface::FollowCarDis& Statefusion::_internal_accdislevel() const {
  const ::HmiInterface::FollowCarDis* p = accdislevel_;
  return p != nullptr ? *p : reinterpret_cast<const ::HmiInterface::FollowCarDis&>(
      ::HmiInterface::_FollowCarDis_default_instance_);
}
inline const ::HmiInterface::FollowCarDis& Statefusion::accdislevel() const {
  // @@protoc_insertion_point(field_get:HmiInterface.Statefusion.accdislevel)
  return _internal_accdislevel();
}
inline void Statefusion::unsafe_arena_set_allocated_accdislevel(
    ::HmiInterface::FollowCarDis* accdislevel) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(accdislevel_);
  }
  accdislevel_ = accdislevel;
  if (accdislevel) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HmiInterface.Statefusion.accdislevel)
}
inline ::HmiInterface::FollowCarDis* Statefusion::release_accdislevel() {
  
  ::HmiInterface::FollowCarDis* temp = accdislevel_;
  accdislevel_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::HmiInterface::FollowCarDis* Statefusion::unsafe_arena_release_accdislevel() {
  // @@protoc_insertion_point(field_release:HmiInterface.Statefusion.accdislevel)
  
  ::HmiInterface::FollowCarDis* temp = accdislevel_;
  accdislevel_ = nullptr;
  return temp;
}
inline ::HmiInterface::FollowCarDis* Statefusion::_internal_mutable_accdislevel() {
  
  if (accdislevel_ == nullptr) {
    auto* p = CreateMaybeMessage<::HmiInterface::FollowCarDis>(GetArenaForAllocation());
    accdislevel_ = p;
  }
  return accdislevel_;
}
inline ::HmiInterface::FollowCarDis* Statefusion::mutable_accdislevel() {
  ::HmiInterface::FollowCarDis* _msg = _internal_mutable_accdislevel();
  // @@protoc_insertion_point(field_mutable:HmiInterface.Statefusion.accdislevel)
  return _msg;
}
inline void Statefusion::set_allocated_accdislevel(::HmiInterface::FollowCarDis* accdislevel) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete accdislevel_;
  }
  if (accdislevel) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::HmiInterface::FollowCarDis>::GetOwningArena(accdislevel);
    if (message_arena != submessage_arena) {
      accdislevel = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, accdislevel, submessage_arena);
    }
    
  } else {
    
  }
  accdislevel_ = accdislevel;
  // @@protoc_insertion_point(field_set_allocated:HmiInterface.Statefusion.accdislevel)
}

// .HmiInterface.TakeOverEyeWarning takeovereyewarning = 6;
inline bool Statefusion::_internal_has_takeovereyewarning() const {
  return this != internal_default_instance() && takeovereyewarning_ != nullptr;
}
inline bool Statefusion::has_takeovereyewarning() const {
  return _internal_has_takeovereyewarning();
}
inline void Statefusion::clear_takeovereyewarning() {
  if (GetArenaForAllocation() == nullptr && takeovereyewarning_ != nullptr) {
    delete takeovereyewarning_;
  }
  takeovereyewarning_ = nullptr;
}
inline const ::HmiInterface::TakeOverEyeWarning& Statefusion::_internal_takeovereyewarning() const {
  const ::HmiInterface::TakeOverEyeWarning* p = takeovereyewarning_;
  return p != nullptr ? *p : reinterpret_cast<const ::HmiInterface::TakeOverEyeWarning&>(
      ::HmiInterface::_TakeOverEyeWarning_default_instance_);
}
inline const ::HmiInterface::TakeOverEyeWarning& Statefusion::takeovereyewarning() const {
  // @@protoc_insertion_point(field_get:HmiInterface.Statefusion.takeovereyewarning)
  return _internal_takeovereyewarning();
}
inline void Statefusion::unsafe_arena_set_allocated_takeovereyewarning(
    ::HmiInterface::TakeOverEyeWarning* takeovereyewarning) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(takeovereyewarning_);
  }
  takeovereyewarning_ = takeovereyewarning;
  if (takeovereyewarning) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HmiInterface.Statefusion.takeovereyewarning)
}
inline ::HmiInterface::TakeOverEyeWarning* Statefusion::release_takeovereyewarning() {
  
  ::HmiInterface::TakeOverEyeWarning* temp = takeovereyewarning_;
  takeovereyewarning_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::HmiInterface::TakeOverEyeWarning* Statefusion::unsafe_arena_release_takeovereyewarning() {
  // @@protoc_insertion_point(field_release:HmiInterface.Statefusion.takeovereyewarning)
  
  ::HmiInterface::TakeOverEyeWarning* temp = takeovereyewarning_;
  takeovereyewarning_ = nullptr;
  return temp;
}
inline ::HmiInterface::TakeOverEyeWarning* Statefusion::_internal_mutable_takeovereyewarning() {
  
  if (takeovereyewarning_ == nullptr) {
    auto* p = CreateMaybeMessage<::HmiInterface::TakeOverEyeWarning>(GetArenaForAllocation());
    takeovereyewarning_ = p;
  }
  return takeovereyewarning_;
}
inline ::HmiInterface::TakeOverEyeWarning* Statefusion::mutable_takeovereyewarning() {
  ::HmiInterface::TakeOverEyeWarning* _msg = _internal_mutable_takeovereyewarning();
  // @@protoc_insertion_point(field_mutable:HmiInterface.Statefusion.takeovereyewarning)
  return _msg;
}
inline void Statefusion::set_allocated_takeovereyewarning(::HmiInterface::TakeOverEyeWarning* takeovereyewarning) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete takeovereyewarning_;
  }
  if (takeovereyewarning) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::HmiInterface::TakeOverEyeWarning>::GetOwningArena(takeovereyewarning);
    if (message_arena != submessage_arena) {
      takeovereyewarning = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, takeovereyewarning, submessage_arena);
    }
    
  } else {
    
  }
  takeovereyewarning_ = takeovereyewarning;
  // @@protoc_insertion_point(field_set_allocated:HmiInterface.Statefusion.takeovereyewarning)
}

// .HmiInterface.ACCIACCNIDStatus acciaccnidstatus = 7;
inline bool Statefusion::_internal_has_acciaccnidstatus() const {
  return this != internal_default_instance() && acciaccnidstatus_ != nullptr;
}
inline bool Statefusion::has_acciaccnidstatus() const {
  return _internal_has_acciaccnidstatus();
}
inline void Statefusion::clear_acciaccnidstatus() {
  if (GetArenaForAllocation() == nullptr && acciaccnidstatus_ != nullptr) {
    delete acciaccnidstatus_;
  }
  acciaccnidstatus_ = nullptr;
}
inline const ::HmiInterface::ACCIACCNIDStatus& Statefusion::_internal_acciaccnidstatus() const {
  const ::HmiInterface::ACCIACCNIDStatus* p = acciaccnidstatus_;
  return p != nullptr ? *p : reinterpret_cast<const ::HmiInterface::ACCIACCNIDStatus&>(
      ::HmiInterface::_ACCIACCNIDStatus_default_instance_);
}
inline const ::HmiInterface::ACCIACCNIDStatus& Statefusion::acciaccnidstatus() const {
  // @@protoc_insertion_point(field_get:HmiInterface.Statefusion.acciaccnidstatus)
  return _internal_acciaccnidstatus();
}
inline void Statefusion::unsafe_arena_set_allocated_acciaccnidstatus(
    ::HmiInterface::ACCIACCNIDStatus* acciaccnidstatus) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(acciaccnidstatus_);
  }
  acciaccnidstatus_ = acciaccnidstatus;
  if (acciaccnidstatus) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HmiInterface.Statefusion.acciaccnidstatus)
}
inline ::HmiInterface::ACCIACCNIDStatus* Statefusion::release_acciaccnidstatus() {
  
  ::HmiInterface::ACCIACCNIDStatus* temp = acciaccnidstatus_;
  acciaccnidstatus_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::HmiInterface::ACCIACCNIDStatus* Statefusion::unsafe_arena_release_acciaccnidstatus() {
  // @@protoc_insertion_point(field_release:HmiInterface.Statefusion.acciaccnidstatus)
  
  ::HmiInterface::ACCIACCNIDStatus* temp = acciaccnidstatus_;
  acciaccnidstatus_ = nullptr;
  return temp;
}
inline ::HmiInterface::ACCIACCNIDStatus* Statefusion::_internal_mutable_acciaccnidstatus() {
  
  if (acciaccnidstatus_ == nullptr) {
    auto* p = CreateMaybeMessage<::HmiInterface::ACCIACCNIDStatus>(GetArenaForAllocation());
    acciaccnidstatus_ = p;
  }
  return acciaccnidstatus_;
}
inline ::HmiInterface::ACCIACCNIDStatus* Statefusion::mutable_acciaccnidstatus() {
  ::HmiInterface::ACCIACCNIDStatus* _msg = _internal_mutable_acciaccnidstatus();
  // @@protoc_insertion_point(field_mutable:HmiInterface.Statefusion.acciaccnidstatus)
  return _msg;
}
inline void Statefusion::set_allocated_acciaccnidstatus(::HmiInterface::ACCIACCNIDStatus* acciaccnidstatus) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete acciaccnidstatus_;
  }
  if (acciaccnidstatus) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::HmiInterface::ACCIACCNIDStatus>::GetOwningArena(acciaccnidstatus);
    if (message_arena != submessage_arena) {
      acciaccnidstatus = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, acciaccnidstatus, submessage_arena);
    }
    
  } else {
    
  }
  acciaccnidstatus_ = acciaccnidstatus;
  // @@protoc_insertion_point(field_set_allocated:HmiInterface.Statefusion.acciaccnidstatus)
}

// -------------------------------------------------------------------

// BasicStateFusion

// .HmiInterface.Statefusion status_fusion = 1;
inline bool BasicStateFusion::_internal_has_status_fusion() const {
  return this != internal_default_instance() && status_fusion_ != nullptr;
}
inline bool BasicStateFusion::has_status_fusion() const {
  return _internal_has_status_fusion();
}
inline void BasicStateFusion::clear_status_fusion() {
  if (GetArenaForAllocation() == nullptr && status_fusion_ != nullptr) {
    delete status_fusion_;
  }
  status_fusion_ = nullptr;
}
inline const ::HmiInterface::Statefusion& BasicStateFusion::_internal_status_fusion() const {
  const ::HmiInterface::Statefusion* p = status_fusion_;
  return p != nullptr ? *p : reinterpret_cast<const ::HmiInterface::Statefusion&>(
      ::HmiInterface::_Statefusion_default_instance_);
}
inline const ::HmiInterface::Statefusion& BasicStateFusion::status_fusion() const {
  // @@protoc_insertion_point(field_get:HmiInterface.BasicStateFusion.status_fusion)
  return _internal_status_fusion();
}
inline void BasicStateFusion::unsafe_arena_set_allocated_status_fusion(
    ::HmiInterface::Statefusion* status_fusion) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_fusion_);
  }
  status_fusion_ = status_fusion;
  if (status_fusion) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HmiInterface.BasicStateFusion.status_fusion)
}
inline ::HmiInterface::Statefusion* BasicStateFusion::release_status_fusion() {
  
  ::HmiInterface::Statefusion* temp = status_fusion_;
  status_fusion_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::HmiInterface::Statefusion* BasicStateFusion::unsafe_arena_release_status_fusion() {
  // @@protoc_insertion_point(field_release:HmiInterface.BasicStateFusion.status_fusion)
  
  ::HmiInterface::Statefusion* temp = status_fusion_;
  status_fusion_ = nullptr;
  return temp;
}
inline ::HmiInterface::Statefusion* BasicStateFusion::_internal_mutable_status_fusion() {
  
  if (status_fusion_ == nullptr) {
    auto* p = CreateMaybeMessage<::HmiInterface::Statefusion>(GetArenaForAllocation());
    status_fusion_ = p;
  }
  return status_fusion_;
}
inline ::HmiInterface::Statefusion* BasicStateFusion::mutable_status_fusion() {
  ::HmiInterface::Statefusion* _msg = _internal_mutable_status_fusion();
  // @@protoc_insertion_point(field_mutable:HmiInterface.BasicStateFusion.status_fusion)
  return _msg;
}
inline void BasicStateFusion::set_allocated_status_fusion(::HmiInterface::Statefusion* status_fusion) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete status_fusion_;
  }
  if (status_fusion) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::HmiInterface::Statefusion>::GetOwningArena(status_fusion);
    if (message_arena != submessage_arena) {
      status_fusion = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status_fusion, submessage_arena);
    }
    
  } else {
    
  }
  status_fusion_ = status_fusion;
  // @@protoc_insertion_point(field_set_allocated:HmiInterface.BasicStateFusion.status_fusion)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace HmiInterface

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_hmi_5fbasic_5fstatefusion_2eproto

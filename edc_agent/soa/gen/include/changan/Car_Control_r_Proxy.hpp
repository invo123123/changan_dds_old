/****************************************************************
  Generated by ChangAn Code Generator,Do Not Modify
  AppVersion： mADC_Application_Service-V1.5
  ServiceVersion: 
  CmVersion： v2.0.3
  ServiceLatestModifyTime: 
  Generate Time: 2023-12-11 18:07:58
*****************************************************************/
#ifndef CAR_CONTROL_R_PROXY_HPP
#define CAR_CONTROL_R_PROXY_HPP
#include <unordered_map>
#include <future>
#include <mutex>
#include "changan/common_data_types.h"
#include "changan/global_config.hpp"
#include "changan/dds_util.h"
namespace com {
	namespace changan {
		namespace carControl {
			namespace proxy {
				extern void on_carControl_r_rpc_reply_data_available(int32_t reader, void* arg);
				extern void on_carControl_r_notify_data_available(int32_t reader, void* arg);
				
				template <typename T>
				void send_viu_link_status_to_upper(uint16_t serviceId, ViuStatus &vs, std::unordered_map<uint16_t, ViuStatus>& handlers)
				{
                    ProviderMatchedStatus pms;
					if(T::get_instance().get_link_count() == 2 && T::get_instance().get_topicdata_online(serviceId))
					{
                        pms.is_online = true;
					}
					else
					{
                        pms.is_online = false;
					}

                    //printf("serviceId[%u] vs.preOnline[%s]  pms.is_online[%s]\n",serviceId, vs.preOnline? "online" : "offline", pms.is_online? "online" : "offline");
					//在线状态未改变时无需重复上报(现在状态与以前状态相比较)
					if(handlers[serviceId].preOnline ==  pms.is_online)
					{
						return;
					}
					    
					//T::get_instance().set_last_provider_match_status(pms);
					//printf("serviceId %u %s\n", serviceId, pms.is_online ? "online" : "offline");
					handlers[serviceId].preOnline = pms.is_online;
					vs.handler(pms);
					return;
				}
				
				template <typename T>
				void get_provider_match_status()
				{
                    ProviderMatchedStatus pms1;
					if(T::get_instance().get_link_count() == 2)
					{
						pms1.is_online = true;
						T::get_instance().set_last_provider_match_status(pms1);
					}
					else
					{
						pms1.is_online = false;
						T::get_instance().set_last_provider_match_status(pms1);
					}

					std::unordered_map<uint16_t, ViuStatus>& handlers = T::get_instance().get_registered_topicdata_checkable_handler();
					for (auto it = handlers.begin(); it != handlers.end(); ++it) 
					{
						uint16_t serviceId = it->first;
						//printf("send_viu_link_status_to_upper serviceId=[%u]11111111111\n", serviceId);
						ViuStatus vs = it->second;
						if (!vs.handler) 
						{
							continue;
						}

						send_viu_link_status_to_upper<T>(serviceId, vs, handlers);
					}
					return;
				}
				
				template <typename T>
				void on_CarControlRProxy_request_publication_matched_cb(dds_entity_t writer, const dds_publication_matched_status_t  status, void* arg) {
					ASF_LOG_DEBUG_ARGS("on_CarControlRProxy_request_publication_matched_cb, writer=[%d], current_count=[%d]", writer, status.current_count);
					ProviderMatchedStatus data = DDSUtil::get_provider_matched_status(writer, status);
					//printf("on_CarControlRProxy_request_publication_matched_cb, data.is_online[%d]777777\n",data.is_online);
					if (data.is_online) 
					{
						T::get_instance().add_link_count();
					}
					else
					{
						T::get_instance().subtract_link_count();
					}

					get_provider_match_status<T>();
				}
				
				template <typename T>
                void on_CarControlRProxy_reply_sublication_matched_cb(dds_entity_t reader, const dds_subscription_matched_status_t status, void* arg) {
					ASF_LOG_DEBUG_ARGS("on_CarControlRProxy_reply_sublication_matched_cb, reader=[%d], current_count=[%d]", reader, status.current_count);
                    ConsumerMatchedStatus data = DDSUtil::get_consumer_matched_status(reader, status);
                    //printf("on_CarControlRProxy_reply_sublication_matched_cb 8888888888 data.is_online[%d]8888888\n",data.is_online);
					if (data.is_online) {
                        T::get_instance().add_link_count();
                    }

					else
					{
						T::get_instance().subtract_link_count();
					}
                    
					get_provider_match_status<T>();
                }

				template <typename T>
				bool on_CarControlRProxy_request_topicdata_checkable_cb(dds_entity_t entity, const uint8_t guid[DDS_GUID_LENGTH], const unsigned char* topicdata_value, uint32_t topicdata_len, void* arg) {
					ASF_LOG_DEBUG_ARGS("on_CarControlRProxy_request_topicdata_checkable_cb");
					//printf("on_CarControlRProxy_request_topicdata_checkable_cb 999999999\n");
					if (topicdata_len <= 0) {
						ASF_LOG_DEBUG_ARGS("on_CarControlRProxy_request_topicdata_checkable_cb, topicdata_len %u <= 0", topicdata_len);
						//printf("topicdata_len %u <= 0\n", topicdata_len);
					}
					
					T_topicdata_bitmap *topic_bitmap = T::get_instance().get_topicdata_bitmap();
					memset(topic_bitmap->topicdata_bitmap,0,sizeof(topic_bitmap->topicdata_bitmap));
					memcpy(topic_bitmap->topicdata_bitmap,topicdata_value,topicdata_len);
                    topic_bitmap->topicdata_bitmap_len = topicdata_len;

					std::unordered_map<uint16_t, ViuStatus>& handlers = T::get_instance().get_registered_topicdata_checkable_handler();
					for (auto it = handlers.begin(); it != handlers.end(); ++it) {
						uint16_t serviceId = it->first;
						ViuStatus vs = it->second;
						if (!vs.handler) {
							continue;
						}
				
						bool bOnline = false;
						uint32_t byteIdx = (uint32_t)(serviceId + 7) / 8 - 1;
				
						if (byteIdx <= topicdata_len) {
							uint32_t bitIdx = (serviceId - 1) % 8;
							uint8_t u8 = (uint8_t)topicdata_value[byteIdx];
							bOnline = u8 & (((uint8_t)1) << (8 - bitIdx - 1));							
						}

						T::get_instance().set_topicdata_online(serviceId, bOnline);
						send_viu_link_status_to_upper<T>(serviceId, vs, handlers);
					}
				
					return true;
				}

				class CarControlRProxy:public dds_link_count
				{
				public:
					std::future<std::shared_ptr<void>> call(uint64_t fu_id,const void* data);
					dds_rpc_handle_t get_rpc_handle();
					std::unordered_map<uint16_t, ViuStatus>& get_registered_topicdata_checkable_handler();
					void register_topicdata_checkable_handler(uint16_t serviceId, EventReceiveHandler<const ProviderMatchedStatus&> handler);
				  	//std::unordered_map<std::string, EventReceiveHandler<const ProviderMatchedStatus&>> get_registered_provider_matched_handler();
					void register_provider_matched_handler(std::string name,uint16_t serviceId, EventReceiveHandler<const ProviderMatchedStatus&> handler);
					void set_last_provider_match_status(ProviderMatchedStatus status);
					bool get_topicdata_online(uint16_t serviceId);
					void set_topicdata_online(uint16_t serviceId, bool online);
					T_topicdata_bitmap *get_topicdata_bitmap();
					bool get_servive_online(uint16_t serviceId, const unsigned char* topicdata_value, uint32_t topicdata_len);
					
				protected:
				    bool init_flag = false;
					T_topicdata_bitmap topic_bitmap;
					std::mutex init_mutex;
					ProviderMatchedStatus provider_matched_status={};
					//std::unordered_map<std::string, EventReceiveHandler<const ProviderMatchedStatus&>> provider_matched_handler_map;
					std::unordered_map<uint16_t, ViuStatus> topicdata_checkable_handler_map;
					dds_rpc_handle_t dds_mcu_rpc_handle = { -1,-1,-1 };
					dds_rpc_handle_t dds_mcu_notify_handle = { -1,-1,-1 };
					CarControlRProxy();
					CarControlRProxy(const CarControlRProxy& signal);
					const CarControlRProxy& operator=(const CarControlRProxy& signal);

				};
			}
		}
	}
}
#endif // !CAR_CONTROL_PROXY_HPP


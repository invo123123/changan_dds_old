// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: hmi_basic_trafficlightscene.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_hmi_5fbasic_5ftrafficlightscene_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_hmi_5fbasic_5ftrafficlightscene_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019002 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_hmi_5fbasic_5ftrafficlightscene_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_hmi_5fbasic_5ftrafficlightscene_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[9]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_hmi_5fbasic_5ftrafficlightscene_2eproto;
namespace HmiInterface {
class BasicTrafficLightScene;
struct BasicTrafficLightSceneDefaultTypeInternal;
extern BasicTrafficLightSceneDefaultTypeInternal _BasicTrafficLightScene_default_instance_;
class Crosswork;
struct CrossworkDefaultTypeInternal;
extern CrossworkDefaultTypeInternal _Crosswork_default_instance_;
class HostLaneTRCLight;
struct HostLaneTRCLightDefaultTypeInternal;
extern HostLaneTRCLightDefaultTypeInternal _HostLaneTRCLight_default_instance_;
class LeftLaneTRCLight;
struct LeftLaneTRCLightDefaultTypeInternal;
extern LeftLaneTRCLightDefaultTypeInternal _LeftLaneTRCLight_default_instance_;
class RightLaneTRCLight;
struct RightLaneTRCLightDefaultTypeInternal;
extern RightLaneTRCLightDefaultTypeInternal _RightLaneTRCLight_default_instance_;
class RoadSign;
struct RoadSignDefaultTypeInternal;
extern RoadSignDefaultTypeInternal _RoadSign_default_instance_;
class StopLine;
struct StopLineDefaultTypeInternal;
extern StopLineDefaultTypeInternal _StopLine_default_instance_;
class TrafficLightScene;
struct TrafficLightSceneDefaultTypeInternal;
extern TrafficLightSceneDefaultTypeInternal _TrafficLightScene_default_instance_;
class YellowGLine;
struct YellowGLineDefaultTypeInternal;
extern YellowGLineDefaultTypeInternal _YellowGLine_default_instance_;
}  // namespace HmiInterface
PROTOBUF_NAMESPACE_OPEN
template<> ::HmiInterface::BasicTrafficLightScene* Arena::CreateMaybeMessage<::HmiInterface::BasicTrafficLightScene>(Arena*);
template<> ::HmiInterface::Crosswork* Arena::CreateMaybeMessage<::HmiInterface::Crosswork>(Arena*);
template<> ::HmiInterface::HostLaneTRCLight* Arena::CreateMaybeMessage<::HmiInterface::HostLaneTRCLight>(Arena*);
template<> ::HmiInterface::LeftLaneTRCLight* Arena::CreateMaybeMessage<::HmiInterface::LeftLaneTRCLight>(Arena*);
template<> ::HmiInterface::RightLaneTRCLight* Arena::CreateMaybeMessage<::HmiInterface::RightLaneTRCLight>(Arena*);
template<> ::HmiInterface::RoadSign* Arena::CreateMaybeMessage<::HmiInterface::RoadSign>(Arena*);
template<> ::HmiInterface::StopLine* Arena::CreateMaybeMessage<::HmiInterface::StopLine>(Arena*);
template<> ::HmiInterface::TrafficLightScene* Arena::CreateMaybeMessage<::HmiInterface::TrafficLightScene>(Arena*);
template<> ::HmiInterface::YellowGLine* Arena::CreateMaybeMessage<::HmiInterface::YellowGLine>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace HmiInterface {

// ===================================================================

class YellowGLine final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HmiInterface.YellowGLine) */ {
 public:
  inline YellowGLine() : YellowGLine(nullptr) {}
  ~YellowGLine() override;
  explicit constexpr YellowGLine(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  YellowGLine(const YellowGLine& from);
  YellowGLine(YellowGLine&& from) noexcept
    : YellowGLine() {
    *this = ::std::move(from);
  }

  inline YellowGLine& operator=(const YellowGLine& from) {
    CopyFrom(from);
    return *this;
  }
  inline YellowGLine& operator=(YellowGLine&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const YellowGLine& default_instance() {
    return *internal_default_instance();
  }
  static inline const YellowGLine* internal_default_instance() {
    return reinterpret_cast<const YellowGLine*>(
               &_YellowGLine_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(YellowGLine& a, YellowGLine& b) {
    a.Swap(&b);
  }
  inline void Swap(YellowGLine* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(YellowGLine* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  YellowGLine* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<YellowGLine>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const YellowGLine& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const YellowGLine& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(YellowGLine* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HmiInterface.YellowGLine";
  }
  protected:
  explicit YellowGLine(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kYellowglinerangeFieldNumber = 1,
  };
  // float yellowglinerange = 1;
  void clear_yellowglinerange();
  float yellowglinerange() const;
  void set_yellowglinerange(float value);
  private:
  float _internal_yellowglinerange() const;
  void _internal_set_yellowglinerange(float value);
  public:

  // @@protoc_insertion_point(class_scope:HmiInterface.YellowGLine)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  float yellowglinerange_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_hmi_5fbasic_5ftrafficlightscene_2eproto;
};
// -------------------------------------------------------------------

class StopLine final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HmiInterface.StopLine) */ {
 public:
  inline StopLine() : StopLine(nullptr) {}
  ~StopLine() override;
  explicit constexpr StopLine(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StopLine(const StopLine& from);
  StopLine(StopLine&& from) noexcept
    : StopLine() {
    *this = ::std::move(from);
  }

  inline StopLine& operator=(const StopLine& from) {
    CopyFrom(from);
    return *this;
  }
  inline StopLine& operator=(StopLine&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StopLine& default_instance() {
    return *internal_default_instance();
  }
  static inline const StopLine* internal_default_instance() {
    return reinterpret_cast<const StopLine*>(
               &_StopLine_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(StopLine& a, StopLine& b) {
    a.Swap(&b);
  }
  inline void Swap(StopLine* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StopLine* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StopLine* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StopLine>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StopLine& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const StopLine& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StopLine* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HmiInterface.StopLine";
  }
  protected:
  explicit StopLine(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStoplinelngrangeFieldNumber = 1,
  };
  // float stoplinelngrange = 1;
  void clear_stoplinelngrange();
  float stoplinelngrange() const;
  void set_stoplinelngrange(float value);
  private:
  float _internal_stoplinelngrange() const;
  void _internal_set_stoplinelngrange(float value);
  public:

  // @@protoc_insertion_point(class_scope:HmiInterface.StopLine)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  float stoplinelngrange_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_hmi_5fbasic_5ftrafficlightscene_2eproto;
};
// -------------------------------------------------------------------

class Crosswork final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HmiInterface.Crosswork) */ {
 public:
  inline Crosswork() : Crosswork(nullptr) {}
  ~Crosswork() override;
  explicit constexpr Crosswork(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Crosswork(const Crosswork& from);
  Crosswork(Crosswork&& from) noexcept
    : Crosswork() {
    *this = ::std::move(from);
  }

  inline Crosswork& operator=(const Crosswork& from) {
    CopyFrom(from);
    return *this;
  }
  inline Crosswork& operator=(Crosswork&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Crosswork& default_instance() {
    return *internal_default_instance();
  }
  static inline const Crosswork* internal_default_instance() {
    return reinterpret_cast<const Crosswork*>(
               &_Crosswork_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Crosswork& a, Crosswork& b) {
    a.Swap(&b);
  }
  inline void Swap(Crosswork* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Crosswork* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Crosswork* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Crosswork>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Crosswork& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Crosswork& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Crosswork* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HmiInterface.Crosswork";
  }
  protected:
  explicit Crosswork(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCrossworklngrangeFieldNumber = 1,
  };
  // float crossworklngrange = 1;
  void clear_crossworklngrange();
  float crossworklngrange() const;
  void set_crossworklngrange(float value);
  private:
  float _internal_crossworklngrange() const;
  void _internal_set_crossworklngrange(float value);
  public:

  // @@protoc_insertion_point(class_scope:HmiInterface.Crosswork)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  float crossworklngrange_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_hmi_5fbasic_5ftrafficlightscene_2eproto;
};
// -------------------------------------------------------------------

class RoadSign final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HmiInterface.RoadSign) */ {
 public:
  inline RoadSign() : RoadSign(nullptr) {}
  ~RoadSign() override;
  explicit constexpr RoadSign(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RoadSign(const RoadSign& from);
  RoadSign(RoadSign&& from) noexcept
    : RoadSign() {
    *this = ::std::move(from);
  }

  inline RoadSign& operator=(const RoadSign& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoadSign& operator=(RoadSign&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoadSign& default_instance() {
    return *internal_default_instance();
  }
  static inline const RoadSign* internal_default_instance() {
    return reinterpret_cast<const RoadSign*>(
               &_RoadSign_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(RoadSign& a, RoadSign& b) {
    a.Swap(&b);
  }
  inline void Swap(RoadSign* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoadSign* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoadSign* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RoadSign>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RoadSign& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RoadSign& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoadSign* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HmiInterface.RoadSign";
  }
  protected:
  explicit RoadSign(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLeftsigntypeFieldNumber = 1,
    kLeftsignlngrangeFieldNumber = 2,
    kHostsigntypeFieldNumber = 3,
    kHostsignlngrangeFieldNumber = 4,
    kRightsigntypeFieldNumber = 5,
    kRightsignlngrangeFieldNumber = 6,
  };
  // uint32 leftsigntype = 1;
  void clear_leftsigntype();
  uint32_t leftsigntype() const;
  void set_leftsigntype(uint32_t value);
  private:
  uint32_t _internal_leftsigntype() const;
  void _internal_set_leftsigntype(uint32_t value);
  public:

  // float leftsignlngrange = 2;
  void clear_leftsignlngrange();
  float leftsignlngrange() const;
  void set_leftsignlngrange(float value);
  private:
  float _internal_leftsignlngrange() const;
  void _internal_set_leftsignlngrange(float value);
  public:

  // uint32 hostsigntype = 3;
  void clear_hostsigntype();
  uint32_t hostsigntype() const;
  void set_hostsigntype(uint32_t value);
  private:
  uint32_t _internal_hostsigntype() const;
  void _internal_set_hostsigntype(uint32_t value);
  public:

  // float hostsignlngrange = 4;
  void clear_hostsignlngrange();
  float hostsignlngrange() const;
  void set_hostsignlngrange(float value);
  private:
  float _internal_hostsignlngrange() const;
  void _internal_set_hostsignlngrange(float value);
  public:

  // uint32 rightsigntype = 5;
  void clear_rightsigntype();
  uint32_t rightsigntype() const;
  void set_rightsigntype(uint32_t value);
  private:
  uint32_t _internal_rightsigntype() const;
  void _internal_set_rightsigntype(uint32_t value);
  public:

  // float rightsignlngrange = 6;
  void clear_rightsignlngrange();
  float rightsignlngrange() const;
  void set_rightsignlngrange(float value);
  private:
  float _internal_rightsignlngrange() const;
  void _internal_set_rightsignlngrange(float value);
  public:

  // @@protoc_insertion_point(class_scope:HmiInterface.RoadSign)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint32_t leftsigntype_;
  float leftsignlngrange_;
  uint32_t hostsigntype_;
  float hostsignlngrange_;
  uint32_t rightsigntype_;
  float rightsignlngrange_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_hmi_5fbasic_5ftrafficlightscene_2eproto;
};
// -------------------------------------------------------------------

class HostLaneTRCLight final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HmiInterface.HostLaneTRCLight) */ {
 public:
  inline HostLaneTRCLight() : HostLaneTRCLight(nullptr) {}
  ~HostLaneTRCLight() override;
  explicit constexpr HostLaneTRCLight(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HostLaneTRCLight(const HostLaneTRCLight& from);
  HostLaneTRCLight(HostLaneTRCLight&& from) noexcept
    : HostLaneTRCLight() {
    *this = ::std::move(from);
  }

  inline HostLaneTRCLight& operator=(const HostLaneTRCLight& from) {
    CopyFrom(from);
    return *this;
  }
  inline HostLaneTRCLight& operator=(HostLaneTRCLight&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HostLaneTRCLight& default_instance() {
    return *internal_default_instance();
  }
  static inline const HostLaneTRCLight* internal_default_instance() {
    return reinterpret_cast<const HostLaneTRCLight*>(
               &_HostLaneTRCLight_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(HostLaneTRCLight& a, HostLaneTRCLight& b) {
    a.Swap(&b);
  }
  inline void Swap(HostLaneTRCLight* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HostLaneTRCLight* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HostLaneTRCLight* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HostLaneTRCLight>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HostLaneTRCLight& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const HostLaneTRCLight& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HostLaneTRCLight* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HmiInterface.HostLaneTRCLight";
  }
  protected:
  explicit HostLaneTRCLight(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHostlightsituationFieldNumber = 1,
    kHostlightcolourFieldNumber = 2,
    kHostlighttypeFieldNumber = 3,
    kHostlightstatusFieldNumber = 4,
    kHostlightdirectionFieldNumber = 5,
    kHostlightwarninglevelFieldNumber = 6,
  };
  // uint32 hostlightsituation = 1;
  void clear_hostlightsituation();
  uint32_t hostlightsituation() const;
  void set_hostlightsituation(uint32_t value);
  private:
  uint32_t _internal_hostlightsituation() const;
  void _internal_set_hostlightsituation(uint32_t value);
  public:

  // uint32 hostlightcolour = 2;
  void clear_hostlightcolour();
  uint32_t hostlightcolour() const;
  void set_hostlightcolour(uint32_t value);
  private:
  uint32_t _internal_hostlightcolour() const;
  void _internal_set_hostlightcolour(uint32_t value);
  public:

  // uint32 hostlighttype = 3;
  void clear_hostlighttype();
  uint32_t hostlighttype() const;
  void set_hostlighttype(uint32_t value);
  private:
  uint32_t _internal_hostlighttype() const;
  void _internal_set_hostlighttype(uint32_t value);
  public:

  // uint32 hostlightstatus = 4;
  void clear_hostlightstatus();
  uint32_t hostlightstatus() const;
  void set_hostlightstatus(uint32_t value);
  private:
  uint32_t _internal_hostlightstatus() const;
  void _internal_set_hostlightstatus(uint32_t value);
  public:

  // uint32 hostlightdirection = 5;
  void clear_hostlightdirection();
  uint32_t hostlightdirection() const;
  void set_hostlightdirection(uint32_t value);
  private:
  uint32_t _internal_hostlightdirection() const;
  void _internal_set_hostlightdirection(uint32_t value);
  public:

  // uint32 hostlightwarninglevel = 6;
  void clear_hostlightwarninglevel();
  uint32_t hostlightwarninglevel() const;
  void set_hostlightwarninglevel(uint32_t value);
  private:
  uint32_t _internal_hostlightwarninglevel() const;
  void _internal_set_hostlightwarninglevel(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:HmiInterface.HostLaneTRCLight)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint32_t hostlightsituation_;
  uint32_t hostlightcolour_;
  uint32_t hostlighttype_;
  uint32_t hostlightstatus_;
  uint32_t hostlightdirection_;
  uint32_t hostlightwarninglevel_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_hmi_5fbasic_5ftrafficlightscene_2eproto;
};
// -------------------------------------------------------------------

class RightLaneTRCLight final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HmiInterface.RightLaneTRCLight) */ {
 public:
  inline RightLaneTRCLight() : RightLaneTRCLight(nullptr) {}
  ~RightLaneTRCLight() override;
  explicit constexpr RightLaneTRCLight(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RightLaneTRCLight(const RightLaneTRCLight& from);
  RightLaneTRCLight(RightLaneTRCLight&& from) noexcept
    : RightLaneTRCLight() {
    *this = ::std::move(from);
  }

  inline RightLaneTRCLight& operator=(const RightLaneTRCLight& from) {
    CopyFrom(from);
    return *this;
  }
  inline RightLaneTRCLight& operator=(RightLaneTRCLight&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RightLaneTRCLight& default_instance() {
    return *internal_default_instance();
  }
  static inline const RightLaneTRCLight* internal_default_instance() {
    return reinterpret_cast<const RightLaneTRCLight*>(
               &_RightLaneTRCLight_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(RightLaneTRCLight& a, RightLaneTRCLight& b) {
    a.Swap(&b);
  }
  inline void Swap(RightLaneTRCLight* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RightLaneTRCLight* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RightLaneTRCLight* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RightLaneTRCLight>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RightLaneTRCLight& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RightLaneTRCLight& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RightLaneTRCLight* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HmiInterface.RightLaneTRCLight";
  }
  protected:
  explicit RightLaneTRCLight(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRightlightsituationFieldNumber = 1,
    kRightlightcolourFieldNumber = 2,
    kRightlighttypeFieldNumber = 3,
    kRightlightstatusFieldNumber = 4,
    kRightlightdirectionFieldNumber = 5,
  };
  // uint32 rightlightsituation = 1;
  void clear_rightlightsituation();
  uint32_t rightlightsituation() const;
  void set_rightlightsituation(uint32_t value);
  private:
  uint32_t _internal_rightlightsituation() const;
  void _internal_set_rightlightsituation(uint32_t value);
  public:

  // uint32 rightlightcolour = 2;
  void clear_rightlightcolour();
  uint32_t rightlightcolour() const;
  void set_rightlightcolour(uint32_t value);
  private:
  uint32_t _internal_rightlightcolour() const;
  void _internal_set_rightlightcolour(uint32_t value);
  public:

  // uint32 rightlighttype = 3;
  void clear_rightlighttype();
  uint32_t rightlighttype() const;
  void set_rightlighttype(uint32_t value);
  private:
  uint32_t _internal_rightlighttype() const;
  void _internal_set_rightlighttype(uint32_t value);
  public:

  // uint32 rightlightstatus = 4;
  void clear_rightlightstatus();
  uint32_t rightlightstatus() const;
  void set_rightlightstatus(uint32_t value);
  private:
  uint32_t _internal_rightlightstatus() const;
  void _internal_set_rightlightstatus(uint32_t value);
  public:

  // uint32 rightlightdirection = 5;
  void clear_rightlightdirection();
  uint32_t rightlightdirection() const;
  void set_rightlightdirection(uint32_t value);
  private:
  uint32_t _internal_rightlightdirection() const;
  void _internal_set_rightlightdirection(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:HmiInterface.RightLaneTRCLight)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint32_t rightlightsituation_;
  uint32_t rightlightcolour_;
  uint32_t rightlighttype_;
  uint32_t rightlightstatus_;
  uint32_t rightlightdirection_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_hmi_5fbasic_5ftrafficlightscene_2eproto;
};
// -------------------------------------------------------------------

class LeftLaneTRCLight final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HmiInterface.LeftLaneTRCLight) */ {
 public:
  inline LeftLaneTRCLight() : LeftLaneTRCLight(nullptr) {}
  ~LeftLaneTRCLight() override;
  explicit constexpr LeftLaneTRCLight(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LeftLaneTRCLight(const LeftLaneTRCLight& from);
  LeftLaneTRCLight(LeftLaneTRCLight&& from) noexcept
    : LeftLaneTRCLight() {
    *this = ::std::move(from);
  }

  inline LeftLaneTRCLight& operator=(const LeftLaneTRCLight& from) {
    CopyFrom(from);
    return *this;
  }
  inline LeftLaneTRCLight& operator=(LeftLaneTRCLight&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LeftLaneTRCLight& default_instance() {
    return *internal_default_instance();
  }
  static inline const LeftLaneTRCLight* internal_default_instance() {
    return reinterpret_cast<const LeftLaneTRCLight*>(
               &_LeftLaneTRCLight_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(LeftLaneTRCLight& a, LeftLaneTRCLight& b) {
    a.Swap(&b);
  }
  inline void Swap(LeftLaneTRCLight* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LeftLaneTRCLight* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LeftLaneTRCLight* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LeftLaneTRCLight>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LeftLaneTRCLight& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LeftLaneTRCLight& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LeftLaneTRCLight* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HmiInterface.LeftLaneTRCLight";
  }
  protected:
  explicit LeftLaneTRCLight(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLeftlightsituationFieldNumber = 1,
    kLeftlightcolorFieldNumber = 2,
    kLeftlighttypeFieldNumber = 3,
    kLeftlightstatusFieldNumber = 4,
    kLeftlightdirectionFieldNumber = 5,
  };
  // uint32 leftlightsituation = 1;
  void clear_leftlightsituation();
  uint32_t leftlightsituation() const;
  void set_leftlightsituation(uint32_t value);
  private:
  uint32_t _internal_leftlightsituation() const;
  void _internal_set_leftlightsituation(uint32_t value);
  public:

  // uint32 leftlightcolor = 2;
  void clear_leftlightcolor();
  uint32_t leftlightcolor() const;
  void set_leftlightcolor(uint32_t value);
  private:
  uint32_t _internal_leftlightcolor() const;
  void _internal_set_leftlightcolor(uint32_t value);
  public:

  // uint32 leftlighttype = 3;
  void clear_leftlighttype();
  uint32_t leftlighttype() const;
  void set_leftlighttype(uint32_t value);
  private:
  uint32_t _internal_leftlighttype() const;
  void _internal_set_leftlighttype(uint32_t value);
  public:

  // uint32 leftlightstatus = 4;
  void clear_leftlightstatus();
  uint32_t leftlightstatus() const;
  void set_leftlightstatus(uint32_t value);
  private:
  uint32_t _internal_leftlightstatus() const;
  void _internal_set_leftlightstatus(uint32_t value);
  public:

  // uint32 leftlightdirection = 5;
  void clear_leftlightdirection();
  uint32_t leftlightdirection() const;
  void set_leftlightdirection(uint32_t value);
  private:
  uint32_t _internal_leftlightdirection() const;
  void _internal_set_leftlightdirection(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:HmiInterface.LeftLaneTRCLight)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint32_t leftlightsituation_;
  uint32_t leftlightcolor_;
  uint32_t leftlighttype_;
  uint32_t leftlightstatus_;
  uint32_t leftlightdirection_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_hmi_5fbasic_5ftrafficlightscene_2eproto;
};
// -------------------------------------------------------------------

class TrafficLightScene final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HmiInterface.TrafficLightScene) */ {
 public:
  inline TrafficLightScene() : TrafficLightScene(nullptr) {}
  ~TrafficLightScene() override;
  explicit constexpr TrafficLightScene(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TrafficLightScene(const TrafficLightScene& from);
  TrafficLightScene(TrafficLightScene&& from) noexcept
    : TrafficLightScene() {
    *this = ::std::move(from);
  }

  inline TrafficLightScene& operator=(const TrafficLightScene& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrafficLightScene& operator=(TrafficLightScene&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TrafficLightScene& default_instance() {
    return *internal_default_instance();
  }
  static inline const TrafficLightScene* internal_default_instance() {
    return reinterpret_cast<const TrafficLightScene*>(
               &_TrafficLightScene_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(TrafficLightScene& a, TrafficLightScene& b) {
    a.Swap(&b);
  }
  inline void Swap(TrafficLightScene* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TrafficLightScene* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TrafficLightScene* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TrafficLightScene>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TrafficLightScene& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TrafficLightScene& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrafficLightScene* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HmiInterface.TrafficLightScene";
  }
  protected:
  explicit TrafficLightScene(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLefttrcdataFieldNumber = 1,
    kRighttrcdataFieldNumber = 2,
    kHosttrcdataFieldNumber = 3,
    kRoadsigndataFieldNumber = 4,
    kCrossworkdataFieldNumber = 5,
    kStoplinedataFieldNumber = 6,
    kYellowglinedataFieldNumber = 7,
  };
  // .HmiInterface.LeftLaneTRCLight lefttrcdata = 1;
  bool has_lefttrcdata() const;
  private:
  bool _internal_has_lefttrcdata() const;
  public:
  void clear_lefttrcdata();
  const ::HmiInterface::LeftLaneTRCLight& lefttrcdata() const;
  PROTOBUF_NODISCARD ::HmiInterface::LeftLaneTRCLight* release_lefttrcdata();
  ::HmiInterface::LeftLaneTRCLight* mutable_lefttrcdata();
  void set_allocated_lefttrcdata(::HmiInterface::LeftLaneTRCLight* lefttrcdata);
  private:
  const ::HmiInterface::LeftLaneTRCLight& _internal_lefttrcdata() const;
  ::HmiInterface::LeftLaneTRCLight* _internal_mutable_lefttrcdata();
  public:
  void unsafe_arena_set_allocated_lefttrcdata(
      ::HmiInterface::LeftLaneTRCLight* lefttrcdata);
  ::HmiInterface::LeftLaneTRCLight* unsafe_arena_release_lefttrcdata();

  // .HmiInterface.RightLaneTRCLight righttrcdata = 2;
  bool has_righttrcdata() const;
  private:
  bool _internal_has_righttrcdata() const;
  public:
  void clear_righttrcdata();
  const ::HmiInterface::RightLaneTRCLight& righttrcdata() const;
  PROTOBUF_NODISCARD ::HmiInterface::RightLaneTRCLight* release_righttrcdata();
  ::HmiInterface::RightLaneTRCLight* mutable_righttrcdata();
  void set_allocated_righttrcdata(::HmiInterface::RightLaneTRCLight* righttrcdata);
  private:
  const ::HmiInterface::RightLaneTRCLight& _internal_righttrcdata() const;
  ::HmiInterface::RightLaneTRCLight* _internal_mutable_righttrcdata();
  public:
  void unsafe_arena_set_allocated_righttrcdata(
      ::HmiInterface::RightLaneTRCLight* righttrcdata);
  ::HmiInterface::RightLaneTRCLight* unsafe_arena_release_righttrcdata();

  // .HmiInterface.HostLaneTRCLight hosttrcdata = 3;
  bool has_hosttrcdata() const;
  private:
  bool _internal_has_hosttrcdata() const;
  public:
  void clear_hosttrcdata();
  const ::HmiInterface::HostLaneTRCLight& hosttrcdata() const;
  PROTOBUF_NODISCARD ::HmiInterface::HostLaneTRCLight* release_hosttrcdata();
  ::HmiInterface::HostLaneTRCLight* mutable_hosttrcdata();
  void set_allocated_hosttrcdata(::HmiInterface::HostLaneTRCLight* hosttrcdata);
  private:
  const ::HmiInterface::HostLaneTRCLight& _internal_hosttrcdata() const;
  ::HmiInterface::HostLaneTRCLight* _internal_mutable_hosttrcdata();
  public:
  void unsafe_arena_set_allocated_hosttrcdata(
      ::HmiInterface::HostLaneTRCLight* hosttrcdata);
  ::HmiInterface::HostLaneTRCLight* unsafe_arena_release_hosttrcdata();

  // .HmiInterface.RoadSign roadsigndata = 4;
  bool has_roadsigndata() const;
  private:
  bool _internal_has_roadsigndata() const;
  public:
  void clear_roadsigndata();
  const ::HmiInterface::RoadSign& roadsigndata() const;
  PROTOBUF_NODISCARD ::HmiInterface::RoadSign* release_roadsigndata();
  ::HmiInterface::RoadSign* mutable_roadsigndata();
  void set_allocated_roadsigndata(::HmiInterface::RoadSign* roadsigndata);
  private:
  const ::HmiInterface::RoadSign& _internal_roadsigndata() const;
  ::HmiInterface::RoadSign* _internal_mutable_roadsigndata();
  public:
  void unsafe_arena_set_allocated_roadsigndata(
      ::HmiInterface::RoadSign* roadsigndata);
  ::HmiInterface::RoadSign* unsafe_arena_release_roadsigndata();

  // .HmiInterface.Crosswork crossworkdata = 5;
  bool has_crossworkdata() const;
  private:
  bool _internal_has_crossworkdata() const;
  public:
  void clear_crossworkdata();
  const ::HmiInterface::Crosswork& crossworkdata() const;
  PROTOBUF_NODISCARD ::HmiInterface::Crosswork* release_crossworkdata();
  ::HmiInterface::Crosswork* mutable_crossworkdata();
  void set_allocated_crossworkdata(::HmiInterface::Crosswork* crossworkdata);
  private:
  const ::HmiInterface::Crosswork& _internal_crossworkdata() const;
  ::HmiInterface::Crosswork* _internal_mutable_crossworkdata();
  public:
  void unsafe_arena_set_allocated_crossworkdata(
      ::HmiInterface::Crosswork* crossworkdata);
  ::HmiInterface::Crosswork* unsafe_arena_release_crossworkdata();

  // .HmiInterface.StopLine stoplinedata = 6;
  bool has_stoplinedata() const;
  private:
  bool _internal_has_stoplinedata() const;
  public:
  void clear_stoplinedata();
  const ::HmiInterface::StopLine& stoplinedata() const;
  PROTOBUF_NODISCARD ::HmiInterface::StopLine* release_stoplinedata();
  ::HmiInterface::StopLine* mutable_stoplinedata();
  void set_allocated_stoplinedata(::HmiInterface::StopLine* stoplinedata);
  private:
  const ::HmiInterface::StopLine& _internal_stoplinedata() const;
  ::HmiInterface::StopLine* _internal_mutable_stoplinedata();
  public:
  void unsafe_arena_set_allocated_stoplinedata(
      ::HmiInterface::StopLine* stoplinedata);
  ::HmiInterface::StopLine* unsafe_arena_release_stoplinedata();

  // .HmiInterface.YellowGLine yellowglinedata = 7;
  bool has_yellowglinedata() const;
  private:
  bool _internal_has_yellowglinedata() const;
  public:
  void clear_yellowglinedata();
  const ::HmiInterface::YellowGLine& yellowglinedata() const;
  PROTOBUF_NODISCARD ::HmiInterface::YellowGLine* release_yellowglinedata();
  ::HmiInterface::YellowGLine* mutable_yellowglinedata();
  void set_allocated_yellowglinedata(::HmiInterface::YellowGLine* yellowglinedata);
  private:
  const ::HmiInterface::YellowGLine& _internal_yellowglinedata() const;
  ::HmiInterface::YellowGLine* _internal_mutable_yellowglinedata();
  public:
  void unsafe_arena_set_allocated_yellowglinedata(
      ::HmiInterface::YellowGLine* yellowglinedata);
  ::HmiInterface::YellowGLine* unsafe_arena_release_yellowglinedata();

  // @@protoc_insertion_point(class_scope:HmiInterface.TrafficLightScene)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::HmiInterface::LeftLaneTRCLight* lefttrcdata_;
  ::HmiInterface::RightLaneTRCLight* righttrcdata_;
  ::HmiInterface::HostLaneTRCLight* hosttrcdata_;
  ::HmiInterface::RoadSign* roadsigndata_;
  ::HmiInterface::Crosswork* crossworkdata_;
  ::HmiInterface::StopLine* stoplinedata_;
  ::HmiInterface::YellowGLine* yellowglinedata_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_hmi_5fbasic_5ftrafficlightscene_2eproto;
};
// -------------------------------------------------------------------

class BasicTrafficLightScene final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HmiInterface.BasicTrafficLightScene) */ {
 public:
  inline BasicTrafficLightScene() : BasicTrafficLightScene(nullptr) {}
  ~BasicTrafficLightScene() override;
  explicit constexpr BasicTrafficLightScene(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BasicTrafficLightScene(const BasicTrafficLightScene& from);
  BasicTrafficLightScene(BasicTrafficLightScene&& from) noexcept
    : BasicTrafficLightScene() {
    *this = ::std::move(from);
  }

  inline BasicTrafficLightScene& operator=(const BasicTrafficLightScene& from) {
    CopyFrom(from);
    return *this;
  }
  inline BasicTrafficLightScene& operator=(BasicTrafficLightScene&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BasicTrafficLightScene& default_instance() {
    return *internal_default_instance();
  }
  static inline const BasicTrafficLightScene* internal_default_instance() {
    return reinterpret_cast<const BasicTrafficLightScene*>(
               &_BasicTrafficLightScene_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(BasicTrafficLightScene& a, BasicTrafficLightScene& b) {
    a.Swap(&b);
  }
  inline void Swap(BasicTrafficLightScene* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BasicTrafficLightScene* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BasicTrafficLightScene* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BasicTrafficLightScene>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BasicTrafficLightScene& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BasicTrafficLightScene& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BasicTrafficLightScene* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HmiInterface.BasicTrafficLightScene";
  }
  protected:
  explicit BasicTrafficLightScene(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTrafficlightFieldNumber = 1,
  };
  // .HmiInterface.TrafficLightScene trafficlight = 1;
  bool has_trafficlight() const;
  private:
  bool _internal_has_trafficlight() const;
  public:
  void clear_trafficlight();
  const ::HmiInterface::TrafficLightScene& trafficlight() const;
  PROTOBUF_NODISCARD ::HmiInterface::TrafficLightScene* release_trafficlight();
  ::HmiInterface::TrafficLightScene* mutable_trafficlight();
  void set_allocated_trafficlight(::HmiInterface::TrafficLightScene* trafficlight);
  private:
  const ::HmiInterface::TrafficLightScene& _internal_trafficlight() const;
  ::HmiInterface::TrafficLightScene* _internal_mutable_trafficlight();
  public:
  void unsafe_arena_set_allocated_trafficlight(
      ::HmiInterface::TrafficLightScene* trafficlight);
  ::HmiInterface::TrafficLightScene* unsafe_arena_release_trafficlight();

  // @@protoc_insertion_point(class_scope:HmiInterface.BasicTrafficLightScene)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::HmiInterface::TrafficLightScene* trafficlight_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_hmi_5fbasic_5ftrafficlightscene_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// YellowGLine

// float yellowglinerange = 1;
inline void YellowGLine::clear_yellowglinerange() {
  yellowglinerange_ = 0;
}
inline float YellowGLine::_internal_yellowglinerange() const {
  return yellowglinerange_;
}
inline float YellowGLine::yellowglinerange() const {
  // @@protoc_insertion_point(field_get:HmiInterface.YellowGLine.yellowglinerange)
  return _internal_yellowglinerange();
}
inline void YellowGLine::_internal_set_yellowglinerange(float value) {
  
  yellowglinerange_ = value;
}
inline void YellowGLine::set_yellowglinerange(float value) {
  _internal_set_yellowglinerange(value);
  // @@protoc_insertion_point(field_set:HmiInterface.YellowGLine.yellowglinerange)
}

// -------------------------------------------------------------------

// StopLine

// float stoplinelngrange = 1;
inline void StopLine::clear_stoplinelngrange() {
  stoplinelngrange_ = 0;
}
inline float StopLine::_internal_stoplinelngrange() const {
  return stoplinelngrange_;
}
inline float StopLine::stoplinelngrange() const {
  // @@protoc_insertion_point(field_get:HmiInterface.StopLine.stoplinelngrange)
  return _internal_stoplinelngrange();
}
inline void StopLine::_internal_set_stoplinelngrange(float value) {
  
  stoplinelngrange_ = value;
}
inline void StopLine::set_stoplinelngrange(float value) {
  _internal_set_stoplinelngrange(value);
  // @@protoc_insertion_point(field_set:HmiInterface.StopLine.stoplinelngrange)
}

// -------------------------------------------------------------------

// Crosswork

// float crossworklngrange = 1;
inline void Crosswork::clear_crossworklngrange() {
  crossworklngrange_ = 0;
}
inline float Crosswork::_internal_crossworklngrange() const {
  return crossworklngrange_;
}
inline float Crosswork::crossworklngrange() const {
  // @@protoc_insertion_point(field_get:HmiInterface.Crosswork.crossworklngrange)
  return _internal_crossworklngrange();
}
inline void Crosswork::_internal_set_crossworklngrange(float value) {
  
  crossworklngrange_ = value;
}
inline void Crosswork::set_crossworklngrange(float value) {
  _internal_set_crossworklngrange(value);
  // @@protoc_insertion_point(field_set:HmiInterface.Crosswork.crossworklngrange)
}

// -------------------------------------------------------------------

// RoadSign

// uint32 leftsigntype = 1;
inline void RoadSign::clear_leftsigntype() {
  leftsigntype_ = 0u;
}
inline uint32_t RoadSign::_internal_leftsigntype() const {
  return leftsigntype_;
}
inline uint32_t RoadSign::leftsigntype() const {
  // @@protoc_insertion_point(field_get:HmiInterface.RoadSign.leftsigntype)
  return _internal_leftsigntype();
}
inline void RoadSign::_internal_set_leftsigntype(uint32_t value) {
  
  leftsigntype_ = value;
}
inline void RoadSign::set_leftsigntype(uint32_t value) {
  _internal_set_leftsigntype(value);
  // @@protoc_insertion_point(field_set:HmiInterface.RoadSign.leftsigntype)
}

// float leftsignlngrange = 2;
inline void RoadSign::clear_leftsignlngrange() {
  leftsignlngrange_ = 0;
}
inline float RoadSign::_internal_leftsignlngrange() const {
  return leftsignlngrange_;
}
inline float RoadSign::leftsignlngrange() const {
  // @@protoc_insertion_point(field_get:HmiInterface.RoadSign.leftsignlngrange)
  return _internal_leftsignlngrange();
}
inline void RoadSign::_internal_set_leftsignlngrange(float value) {
  
  leftsignlngrange_ = value;
}
inline void RoadSign::set_leftsignlngrange(float value) {
  _internal_set_leftsignlngrange(value);
  // @@protoc_insertion_point(field_set:HmiInterface.RoadSign.leftsignlngrange)
}

// uint32 hostsigntype = 3;
inline void RoadSign::clear_hostsigntype() {
  hostsigntype_ = 0u;
}
inline uint32_t RoadSign::_internal_hostsigntype() const {
  return hostsigntype_;
}
inline uint32_t RoadSign::hostsigntype() const {
  // @@protoc_insertion_point(field_get:HmiInterface.RoadSign.hostsigntype)
  return _internal_hostsigntype();
}
inline void RoadSign::_internal_set_hostsigntype(uint32_t value) {
  
  hostsigntype_ = value;
}
inline void RoadSign::set_hostsigntype(uint32_t value) {
  _internal_set_hostsigntype(value);
  // @@protoc_insertion_point(field_set:HmiInterface.RoadSign.hostsigntype)
}

// float hostsignlngrange = 4;
inline void RoadSign::clear_hostsignlngrange() {
  hostsignlngrange_ = 0;
}
inline float RoadSign::_internal_hostsignlngrange() const {
  return hostsignlngrange_;
}
inline float RoadSign::hostsignlngrange() const {
  // @@protoc_insertion_point(field_get:HmiInterface.RoadSign.hostsignlngrange)
  return _internal_hostsignlngrange();
}
inline void RoadSign::_internal_set_hostsignlngrange(float value) {
  
  hostsignlngrange_ = value;
}
inline void RoadSign::set_hostsignlngrange(float value) {
  _internal_set_hostsignlngrange(value);
  // @@protoc_insertion_point(field_set:HmiInterface.RoadSign.hostsignlngrange)
}

// uint32 rightsigntype = 5;
inline void RoadSign::clear_rightsigntype() {
  rightsigntype_ = 0u;
}
inline uint32_t RoadSign::_internal_rightsigntype() const {
  return rightsigntype_;
}
inline uint32_t RoadSign::rightsigntype() const {
  // @@protoc_insertion_point(field_get:HmiInterface.RoadSign.rightsigntype)
  return _internal_rightsigntype();
}
inline void RoadSign::_internal_set_rightsigntype(uint32_t value) {
  
  rightsigntype_ = value;
}
inline void RoadSign::set_rightsigntype(uint32_t value) {
  _internal_set_rightsigntype(value);
  // @@protoc_insertion_point(field_set:HmiInterface.RoadSign.rightsigntype)
}

// float rightsignlngrange = 6;
inline void RoadSign::clear_rightsignlngrange() {
  rightsignlngrange_ = 0;
}
inline float RoadSign::_internal_rightsignlngrange() const {
  return rightsignlngrange_;
}
inline float RoadSign::rightsignlngrange() const {
  // @@protoc_insertion_point(field_get:HmiInterface.RoadSign.rightsignlngrange)
  return _internal_rightsignlngrange();
}
inline void RoadSign::_internal_set_rightsignlngrange(float value) {
  
  rightsignlngrange_ = value;
}
inline void RoadSign::set_rightsignlngrange(float value) {
  _internal_set_rightsignlngrange(value);
  // @@protoc_insertion_point(field_set:HmiInterface.RoadSign.rightsignlngrange)
}

// -------------------------------------------------------------------

// HostLaneTRCLight

// uint32 hostlightsituation = 1;
inline void HostLaneTRCLight::clear_hostlightsituation() {
  hostlightsituation_ = 0u;
}
inline uint32_t HostLaneTRCLight::_internal_hostlightsituation() const {
  return hostlightsituation_;
}
inline uint32_t HostLaneTRCLight::hostlightsituation() const {
  // @@protoc_insertion_point(field_get:HmiInterface.HostLaneTRCLight.hostlightsituation)
  return _internal_hostlightsituation();
}
inline void HostLaneTRCLight::_internal_set_hostlightsituation(uint32_t value) {
  
  hostlightsituation_ = value;
}
inline void HostLaneTRCLight::set_hostlightsituation(uint32_t value) {
  _internal_set_hostlightsituation(value);
  // @@protoc_insertion_point(field_set:HmiInterface.HostLaneTRCLight.hostlightsituation)
}

// uint32 hostlightcolour = 2;
inline void HostLaneTRCLight::clear_hostlightcolour() {
  hostlightcolour_ = 0u;
}
inline uint32_t HostLaneTRCLight::_internal_hostlightcolour() const {
  return hostlightcolour_;
}
inline uint32_t HostLaneTRCLight::hostlightcolour() const {
  // @@protoc_insertion_point(field_get:HmiInterface.HostLaneTRCLight.hostlightcolour)
  return _internal_hostlightcolour();
}
inline void HostLaneTRCLight::_internal_set_hostlightcolour(uint32_t value) {
  
  hostlightcolour_ = value;
}
inline void HostLaneTRCLight::set_hostlightcolour(uint32_t value) {
  _internal_set_hostlightcolour(value);
  // @@protoc_insertion_point(field_set:HmiInterface.HostLaneTRCLight.hostlightcolour)
}

// uint32 hostlighttype = 3;
inline void HostLaneTRCLight::clear_hostlighttype() {
  hostlighttype_ = 0u;
}
inline uint32_t HostLaneTRCLight::_internal_hostlighttype() const {
  return hostlighttype_;
}
inline uint32_t HostLaneTRCLight::hostlighttype() const {
  // @@protoc_insertion_point(field_get:HmiInterface.HostLaneTRCLight.hostlighttype)
  return _internal_hostlighttype();
}
inline void HostLaneTRCLight::_internal_set_hostlighttype(uint32_t value) {
  
  hostlighttype_ = value;
}
inline void HostLaneTRCLight::set_hostlighttype(uint32_t value) {
  _internal_set_hostlighttype(value);
  // @@protoc_insertion_point(field_set:HmiInterface.HostLaneTRCLight.hostlighttype)
}

// uint32 hostlightstatus = 4;
inline void HostLaneTRCLight::clear_hostlightstatus() {
  hostlightstatus_ = 0u;
}
inline uint32_t HostLaneTRCLight::_internal_hostlightstatus() const {
  return hostlightstatus_;
}
inline uint32_t HostLaneTRCLight::hostlightstatus() const {
  // @@protoc_insertion_point(field_get:HmiInterface.HostLaneTRCLight.hostlightstatus)
  return _internal_hostlightstatus();
}
inline void HostLaneTRCLight::_internal_set_hostlightstatus(uint32_t value) {
  
  hostlightstatus_ = value;
}
inline void HostLaneTRCLight::set_hostlightstatus(uint32_t value) {
  _internal_set_hostlightstatus(value);
  // @@protoc_insertion_point(field_set:HmiInterface.HostLaneTRCLight.hostlightstatus)
}

// uint32 hostlightdirection = 5;
inline void HostLaneTRCLight::clear_hostlightdirection() {
  hostlightdirection_ = 0u;
}
inline uint32_t HostLaneTRCLight::_internal_hostlightdirection() const {
  return hostlightdirection_;
}
inline uint32_t HostLaneTRCLight::hostlightdirection() const {
  // @@protoc_insertion_point(field_get:HmiInterface.HostLaneTRCLight.hostlightdirection)
  return _internal_hostlightdirection();
}
inline void HostLaneTRCLight::_internal_set_hostlightdirection(uint32_t value) {
  
  hostlightdirection_ = value;
}
inline void HostLaneTRCLight::set_hostlightdirection(uint32_t value) {
  _internal_set_hostlightdirection(value);
  // @@protoc_insertion_point(field_set:HmiInterface.HostLaneTRCLight.hostlightdirection)
}

// uint32 hostlightwarninglevel = 6;
inline void HostLaneTRCLight::clear_hostlightwarninglevel() {
  hostlightwarninglevel_ = 0u;
}
inline uint32_t HostLaneTRCLight::_internal_hostlightwarninglevel() const {
  return hostlightwarninglevel_;
}
inline uint32_t HostLaneTRCLight::hostlightwarninglevel() const {
  // @@protoc_insertion_point(field_get:HmiInterface.HostLaneTRCLight.hostlightwarninglevel)
  return _internal_hostlightwarninglevel();
}
inline void HostLaneTRCLight::_internal_set_hostlightwarninglevel(uint32_t value) {
  
  hostlightwarninglevel_ = value;
}
inline void HostLaneTRCLight::set_hostlightwarninglevel(uint32_t value) {
  _internal_set_hostlightwarninglevel(value);
  // @@protoc_insertion_point(field_set:HmiInterface.HostLaneTRCLight.hostlightwarninglevel)
}

// -------------------------------------------------------------------

// RightLaneTRCLight

// uint32 rightlightsituation = 1;
inline void RightLaneTRCLight::clear_rightlightsituation() {
  rightlightsituation_ = 0u;
}
inline uint32_t RightLaneTRCLight::_internal_rightlightsituation() const {
  return rightlightsituation_;
}
inline uint32_t RightLaneTRCLight::rightlightsituation() const {
  // @@protoc_insertion_point(field_get:HmiInterface.RightLaneTRCLight.rightlightsituation)
  return _internal_rightlightsituation();
}
inline void RightLaneTRCLight::_internal_set_rightlightsituation(uint32_t value) {
  
  rightlightsituation_ = value;
}
inline void RightLaneTRCLight::set_rightlightsituation(uint32_t value) {
  _internal_set_rightlightsituation(value);
  // @@protoc_insertion_point(field_set:HmiInterface.RightLaneTRCLight.rightlightsituation)
}

// uint32 rightlightcolour = 2;
inline void RightLaneTRCLight::clear_rightlightcolour() {
  rightlightcolour_ = 0u;
}
inline uint32_t RightLaneTRCLight::_internal_rightlightcolour() const {
  return rightlightcolour_;
}
inline uint32_t RightLaneTRCLight::rightlightcolour() const {
  // @@protoc_insertion_point(field_get:HmiInterface.RightLaneTRCLight.rightlightcolour)
  return _internal_rightlightcolour();
}
inline void RightLaneTRCLight::_internal_set_rightlightcolour(uint32_t value) {
  
  rightlightcolour_ = value;
}
inline void RightLaneTRCLight::set_rightlightcolour(uint32_t value) {
  _internal_set_rightlightcolour(value);
  // @@protoc_insertion_point(field_set:HmiInterface.RightLaneTRCLight.rightlightcolour)
}

// uint32 rightlighttype = 3;
inline void RightLaneTRCLight::clear_rightlighttype() {
  rightlighttype_ = 0u;
}
inline uint32_t RightLaneTRCLight::_internal_rightlighttype() const {
  return rightlighttype_;
}
inline uint32_t RightLaneTRCLight::rightlighttype() const {
  // @@protoc_insertion_point(field_get:HmiInterface.RightLaneTRCLight.rightlighttype)
  return _internal_rightlighttype();
}
inline void RightLaneTRCLight::_internal_set_rightlighttype(uint32_t value) {
  
  rightlighttype_ = value;
}
inline void RightLaneTRCLight::set_rightlighttype(uint32_t value) {
  _internal_set_rightlighttype(value);
  // @@protoc_insertion_point(field_set:HmiInterface.RightLaneTRCLight.rightlighttype)
}

// uint32 rightlightstatus = 4;
inline void RightLaneTRCLight::clear_rightlightstatus() {
  rightlightstatus_ = 0u;
}
inline uint32_t RightLaneTRCLight::_internal_rightlightstatus() const {
  return rightlightstatus_;
}
inline uint32_t RightLaneTRCLight::rightlightstatus() const {
  // @@protoc_insertion_point(field_get:HmiInterface.RightLaneTRCLight.rightlightstatus)
  return _internal_rightlightstatus();
}
inline void RightLaneTRCLight::_internal_set_rightlightstatus(uint32_t value) {
  
  rightlightstatus_ = value;
}
inline void RightLaneTRCLight::set_rightlightstatus(uint32_t value) {
  _internal_set_rightlightstatus(value);
  // @@protoc_insertion_point(field_set:HmiInterface.RightLaneTRCLight.rightlightstatus)
}

// uint32 rightlightdirection = 5;
inline void RightLaneTRCLight::clear_rightlightdirection() {
  rightlightdirection_ = 0u;
}
inline uint32_t RightLaneTRCLight::_internal_rightlightdirection() const {
  return rightlightdirection_;
}
inline uint32_t RightLaneTRCLight::rightlightdirection() const {
  // @@protoc_insertion_point(field_get:HmiInterface.RightLaneTRCLight.rightlightdirection)
  return _internal_rightlightdirection();
}
inline void RightLaneTRCLight::_internal_set_rightlightdirection(uint32_t value) {
  
  rightlightdirection_ = value;
}
inline void RightLaneTRCLight::set_rightlightdirection(uint32_t value) {
  _internal_set_rightlightdirection(value);
  // @@protoc_insertion_point(field_set:HmiInterface.RightLaneTRCLight.rightlightdirection)
}

// -------------------------------------------------------------------

// LeftLaneTRCLight

// uint32 leftlightsituation = 1;
inline void LeftLaneTRCLight::clear_leftlightsituation() {
  leftlightsituation_ = 0u;
}
inline uint32_t LeftLaneTRCLight::_internal_leftlightsituation() const {
  return leftlightsituation_;
}
inline uint32_t LeftLaneTRCLight::leftlightsituation() const {
  // @@protoc_insertion_point(field_get:HmiInterface.LeftLaneTRCLight.leftlightsituation)
  return _internal_leftlightsituation();
}
inline void LeftLaneTRCLight::_internal_set_leftlightsituation(uint32_t value) {
  
  leftlightsituation_ = value;
}
inline void LeftLaneTRCLight::set_leftlightsituation(uint32_t value) {
  _internal_set_leftlightsituation(value);
  // @@protoc_insertion_point(field_set:HmiInterface.LeftLaneTRCLight.leftlightsituation)
}

// uint32 leftlightcolor = 2;
inline void LeftLaneTRCLight::clear_leftlightcolor() {
  leftlightcolor_ = 0u;
}
inline uint32_t LeftLaneTRCLight::_internal_leftlightcolor() const {
  return leftlightcolor_;
}
inline uint32_t LeftLaneTRCLight::leftlightcolor() const {
  // @@protoc_insertion_point(field_get:HmiInterface.LeftLaneTRCLight.leftlightcolor)
  return _internal_leftlightcolor();
}
inline void LeftLaneTRCLight::_internal_set_leftlightcolor(uint32_t value) {
  
  leftlightcolor_ = value;
}
inline void LeftLaneTRCLight::set_leftlightcolor(uint32_t value) {
  _internal_set_leftlightcolor(value);
  // @@protoc_insertion_point(field_set:HmiInterface.LeftLaneTRCLight.leftlightcolor)
}

// uint32 leftlighttype = 3;
inline void LeftLaneTRCLight::clear_leftlighttype() {
  leftlighttype_ = 0u;
}
inline uint32_t LeftLaneTRCLight::_internal_leftlighttype() const {
  return leftlighttype_;
}
inline uint32_t LeftLaneTRCLight::leftlighttype() const {
  // @@protoc_insertion_point(field_get:HmiInterface.LeftLaneTRCLight.leftlighttype)
  return _internal_leftlighttype();
}
inline void LeftLaneTRCLight::_internal_set_leftlighttype(uint32_t value) {
  
  leftlighttype_ = value;
}
inline void LeftLaneTRCLight::set_leftlighttype(uint32_t value) {
  _internal_set_leftlighttype(value);
  // @@protoc_insertion_point(field_set:HmiInterface.LeftLaneTRCLight.leftlighttype)
}

// uint32 leftlightstatus = 4;
inline void LeftLaneTRCLight::clear_leftlightstatus() {
  leftlightstatus_ = 0u;
}
inline uint32_t LeftLaneTRCLight::_internal_leftlightstatus() const {
  return leftlightstatus_;
}
inline uint32_t LeftLaneTRCLight::leftlightstatus() const {
  // @@protoc_insertion_point(field_get:HmiInterface.LeftLaneTRCLight.leftlightstatus)
  return _internal_leftlightstatus();
}
inline void LeftLaneTRCLight::_internal_set_leftlightstatus(uint32_t value) {
  
  leftlightstatus_ = value;
}
inline void LeftLaneTRCLight::set_leftlightstatus(uint32_t value) {
  _internal_set_leftlightstatus(value);
  // @@protoc_insertion_point(field_set:HmiInterface.LeftLaneTRCLight.leftlightstatus)
}

// uint32 leftlightdirection = 5;
inline void LeftLaneTRCLight::clear_leftlightdirection() {
  leftlightdirection_ = 0u;
}
inline uint32_t LeftLaneTRCLight::_internal_leftlightdirection() const {
  return leftlightdirection_;
}
inline uint32_t LeftLaneTRCLight::leftlightdirection() const {
  // @@protoc_insertion_point(field_get:HmiInterface.LeftLaneTRCLight.leftlightdirection)
  return _internal_leftlightdirection();
}
inline void LeftLaneTRCLight::_internal_set_leftlightdirection(uint32_t value) {
  
  leftlightdirection_ = value;
}
inline void LeftLaneTRCLight::set_leftlightdirection(uint32_t value) {
  _internal_set_leftlightdirection(value);
  // @@protoc_insertion_point(field_set:HmiInterface.LeftLaneTRCLight.leftlightdirection)
}

// -------------------------------------------------------------------

// TrafficLightScene

// .HmiInterface.LeftLaneTRCLight lefttrcdata = 1;
inline bool TrafficLightScene::_internal_has_lefttrcdata() const {
  return this != internal_default_instance() && lefttrcdata_ != nullptr;
}
inline bool TrafficLightScene::has_lefttrcdata() const {
  return _internal_has_lefttrcdata();
}
inline void TrafficLightScene::clear_lefttrcdata() {
  if (GetArenaForAllocation() == nullptr && lefttrcdata_ != nullptr) {
    delete lefttrcdata_;
  }
  lefttrcdata_ = nullptr;
}
inline const ::HmiInterface::LeftLaneTRCLight& TrafficLightScene::_internal_lefttrcdata() const {
  const ::HmiInterface::LeftLaneTRCLight* p = lefttrcdata_;
  return p != nullptr ? *p : reinterpret_cast<const ::HmiInterface::LeftLaneTRCLight&>(
      ::HmiInterface::_LeftLaneTRCLight_default_instance_);
}
inline const ::HmiInterface::LeftLaneTRCLight& TrafficLightScene::lefttrcdata() const {
  // @@protoc_insertion_point(field_get:HmiInterface.TrafficLightScene.lefttrcdata)
  return _internal_lefttrcdata();
}
inline void TrafficLightScene::unsafe_arena_set_allocated_lefttrcdata(
    ::HmiInterface::LeftLaneTRCLight* lefttrcdata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(lefttrcdata_);
  }
  lefttrcdata_ = lefttrcdata;
  if (lefttrcdata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HmiInterface.TrafficLightScene.lefttrcdata)
}
inline ::HmiInterface::LeftLaneTRCLight* TrafficLightScene::release_lefttrcdata() {
  
  ::HmiInterface::LeftLaneTRCLight* temp = lefttrcdata_;
  lefttrcdata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::HmiInterface::LeftLaneTRCLight* TrafficLightScene::unsafe_arena_release_lefttrcdata() {
  // @@protoc_insertion_point(field_release:HmiInterface.TrafficLightScene.lefttrcdata)
  
  ::HmiInterface::LeftLaneTRCLight* temp = lefttrcdata_;
  lefttrcdata_ = nullptr;
  return temp;
}
inline ::HmiInterface::LeftLaneTRCLight* TrafficLightScene::_internal_mutable_lefttrcdata() {
  
  if (lefttrcdata_ == nullptr) {
    auto* p = CreateMaybeMessage<::HmiInterface::LeftLaneTRCLight>(GetArenaForAllocation());
    lefttrcdata_ = p;
  }
  return lefttrcdata_;
}
inline ::HmiInterface::LeftLaneTRCLight* TrafficLightScene::mutable_lefttrcdata() {
  ::HmiInterface::LeftLaneTRCLight* _msg = _internal_mutable_lefttrcdata();
  // @@protoc_insertion_point(field_mutable:HmiInterface.TrafficLightScene.lefttrcdata)
  return _msg;
}
inline void TrafficLightScene::set_allocated_lefttrcdata(::HmiInterface::LeftLaneTRCLight* lefttrcdata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete lefttrcdata_;
  }
  if (lefttrcdata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::HmiInterface::LeftLaneTRCLight>::GetOwningArena(lefttrcdata);
    if (message_arena != submessage_arena) {
      lefttrcdata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lefttrcdata, submessage_arena);
    }
    
  } else {
    
  }
  lefttrcdata_ = lefttrcdata;
  // @@protoc_insertion_point(field_set_allocated:HmiInterface.TrafficLightScene.lefttrcdata)
}

// .HmiInterface.RightLaneTRCLight righttrcdata = 2;
inline bool TrafficLightScene::_internal_has_righttrcdata() const {
  return this != internal_default_instance() && righttrcdata_ != nullptr;
}
inline bool TrafficLightScene::has_righttrcdata() const {
  return _internal_has_righttrcdata();
}
inline void TrafficLightScene::clear_righttrcdata() {
  if (GetArenaForAllocation() == nullptr && righttrcdata_ != nullptr) {
    delete righttrcdata_;
  }
  righttrcdata_ = nullptr;
}
inline const ::HmiInterface::RightLaneTRCLight& TrafficLightScene::_internal_righttrcdata() const {
  const ::HmiInterface::RightLaneTRCLight* p = righttrcdata_;
  return p != nullptr ? *p : reinterpret_cast<const ::HmiInterface::RightLaneTRCLight&>(
      ::HmiInterface::_RightLaneTRCLight_default_instance_);
}
inline const ::HmiInterface::RightLaneTRCLight& TrafficLightScene::righttrcdata() const {
  // @@protoc_insertion_point(field_get:HmiInterface.TrafficLightScene.righttrcdata)
  return _internal_righttrcdata();
}
inline void TrafficLightScene::unsafe_arena_set_allocated_righttrcdata(
    ::HmiInterface::RightLaneTRCLight* righttrcdata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(righttrcdata_);
  }
  righttrcdata_ = righttrcdata;
  if (righttrcdata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HmiInterface.TrafficLightScene.righttrcdata)
}
inline ::HmiInterface::RightLaneTRCLight* TrafficLightScene::release_righttrcdata() {
  
  ::HmiInterface::RightLaneTRCLight* temp = righttrcdata_;
  righttrcdata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::HmiInterface::RightLaneTRCLight* TrafficLightScene::unsafe_arena_release_righttrcdata() {
  // @@protoc_insertion_point(field_release:HmiInterface.TrafficLightScene.righttrcdata)
  
  ::HmiInterface::RightLaneTRCLight* temp = righttrcdata_;
  righttrcdata_ = nullptr;
  return temp;
}
inline ::HmiInterface::RightLaneTRCLight* TrafficLightScene::_internal_mutable_righttrcdata() {
  
  if (righttrcdata_ == nullptr) {
    auto* p = CreateMaybeMessage<::HmiInterface::RightLaneTRCLight>(GetArenaForAllocation());
    righttrcdata_ = p;
  }
  return righttrcdata_;
}
inline ::HmiInterface::RightLaneTRCLight* TrafficLightScene::mutable_righttrcdata() {
  ::HmiInterface::RightLaneTRCLight* _msg = _internal_mutable_righttrcdata();
  // @@protoc_insertion_point(field_mutable:HmiInterface.TrafficLightScene.righttrcdata)
  return _msg;
}
inline void TrafficLightScene::set_allocated_righttrcdata(::HmiInterface::RightLaneTRCLight* righttrcdata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete righttrcdata_;
  }
  if (righttrcdata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::HmiInterface::RightLaneTRCLight>::GetOwningArena(righttrcdata);
    if (message_arena != submessage_arena) {
      righttrcdata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, righttrcdata, submessage_arena);
    }
    
  } else {
    
  }
  righttrcdata_ = righttrcdata;
  // @@protoc_insertion_point(field_set_allocated:HmiInterface.TrafficLightScene.righttrcdata)
}

// .HmiInterface.HostLaneTRCLight hosttrcdata = 3;
inline bool TrafficLightScene::_internal_has_hosttrcdata() const {
  return this != internal_default_instance() && hosttrcdata_ != nullptr;
}
inline bool TrafficLightScene::has_hosttrcdata() const {
  return _internal_has_hosttrcdata();
}
inline void TrafficLightScene::clear_hosttrcdata() {
  if (GetArenaForAllocation() == nullptr && hosttrcdata_ != nullptr) {
    delete hosttrcdata_;
  }
  hosttrcdata_ = nullptr;
}
inline const ::HmiInterface::HostLaneTRCLight& TrafficLightScene::_internal_hosttrcdata() const {
  const ::HmiInterface::HostLaneTRCLight* p = hosttrcdata_;
  return p != nullptr ? *p : reinterpret_cast<const ::HmiInterface::HostLaneTRCLight&>(
      ::HmiInterface::_HostLaneTRCLight_default_instance_);
}
inline const ::HmiInterface::HostLaneTRCLight& TrafficLightScene::hosttrcdata() const {
  // @@protoc_insertion_point(field_get:HmiInterface.TrafficLightScene.hosttrcdata)
  return _internal_hosttrcdata();
}
inline void TrafficLightScene::unsafe_arena_set_allocated_hosttrcdata(
    ::HmiInterface::HostLaneTRCLight* hosttrcdata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(hosttrcdata_);
  }
  hosttrcdata_ = hosttrcdata;
  if (hosttrcdata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HmiInterface.TrafficLightScene.hosttrcdata)
}
inline ::HmiInterface::HostLaneTRCLight* TrafficLightScene::release_hosttrcdata() {
  
  ::HmiInterface::HostLaneTRCLight* temp = hosttrcdata_;
  hosttrcdata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::HmiInterface::HostLaneTRCLight* TrafficLightScene::unsafe_arena_release_hosttrcdata() {
  // @@protoc_insertion_point(field_release:HmiInterface.TrafficLightScene.hosttrcdata)
  
  ::HmiInterface::HostLaneTRCLight* temp = hosttrcdata_;
  hosttrcdata_ = nullptr;
  return temp;
}
inline ::HmiInterface::HostLaneTRCLight* TrafficLightScene::_internal_mutable_hosttrcdata() {
  
  if (hosttrcdata_ == nullptr) {
    auto* p = CreateMaybeMessage<::HmiInterface::HostLaneTRCLight>(GetArenaForAllocation());
    hosttrcdata_ = p;
  }
  return hosttrcdata_;
}
inline ::HmiInterface::HostLaneTRCLight* TrafficLightScene::mutable_hosttrcdata() {
  ::HmiInterface::HostLaneTRCLight* _msg = _internal_mutable_hosttrcdata();
  // @@protoc_insertion_point(field_mutable:HmiInterface.TrafficLightScene.hosttrcdata)
  return _msg;
}
inline void TrafficLightScene::set_allocated_hosttrcdata(::HmiInterface::HostLaneTRCLight* hosttrcdata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete hosttrcdata_;
  }
  if (hosttrcdata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::HmiInterface::HostLaneTRCLight>::GetOwningArena(hosttrcdata);
    if (message_arena != submessage_arena) {
      hosttrcdata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, hosttrcdata, submessage_arena);
    }
    
  } else {
    
  }
  hosttrcdata_ = hosttrcdata;
  // @@protoc_insertion_point(field_set_allocated:HmiInterface.TrafficLightScene.hosttrcdata)
}

// .HmiInterface.RoadSign roadsigndata = 4;
inline bool TrafficLightScene::_internal_has_roadsigndata() const {
  return this != internal_default_instance() && roadsigndata_ != nullptr;
}
inline bool TrafficLightScene::has_roadsigndata() const {
  return _internal_has_roadsigndata();
}
inline void TrafficLightScene::clear_roadsigndata() {
  if (GetArenaForAllocation() == nullptr && roadsigndata_ != nullptr) {
    delete roadsigndata_;
  }
  roadsigndata_ = nullptr;
}
inline const ::HmiInterface::RoadSign& TrafficLightScene::_internal_roadsigndata() const {
  const ::HmiInterface::RoadSign* p = roadsigndata_;
  return p != nullptr ? *p : reinterpret_cast<const ::HmiInterface::RoadSign&>(
      ::HmiInterface::_RoadSign_default_instance_);
}
inline const ::HmiInterface::RoadSign& TrafficLightScene::roadsigndata() const {
  // @@protoc_insertion_point(field_get:HmiInterface.TrafficLightScene.roadsigndata)
  return _internal_roadsigndata();
}
inline void TrafficLightScene::unsafe_arena_set_allocated_roadsigndata(
    ::HmiInterface::RoadSign* roadsigndata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(roadsigndata_);
  }
  roadsigndata_ = roadsigndata;
  if (roadsigndata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HmiInterface.TrafficLightScene.roadsigndata)
}
inline ::HmiInterface::RoadSign* TrafficLightScene::release_roadsigndata() {
  
  ::HmiInterface::RoadSign* temp = roadsigndata_;
  roadsigndata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::HmiInterface::RoadSign* TrafficLightScene::unsafe_arena_release_roadsigndata() {
  // @@protoc_insertion_point(field_release:HmiInterface.TrafficLightScene.roadsigndata)
  
  ::HmiInterface::RoadSign* temp = roadsigndata_;
  roadsigndata_ = nullptr;
  return temp;
}
inline ::HmiInterface::RoadSign* TrafficLightScene::_internal_mutable_roadsigndata() {
  
  if (roadsigndata_ == nullptr) {
    auto* p = CreateMaybeMessage<::HmiInterface::RoadSign>(GetArenaForAllocation());
    roadsigndata_ = p;
  }
  return roadsigndata_;
}
inline ::HmiInterface::RoadSign* TrafficLightScene::mutable_roadsigndata() {
  ::HmiInterface::RoadSign* _msg = _internal_mutable_roadsigndata();
  // @@protoc_insertion_point(field_mutable:HmiInterface.TrafficLightScene.roadsigndata)
  return _msg;
}
inline void TrafficLightScene::set_allocated_roadsigndata(::HmiInterface::RoadSign* roadsigndata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete roadsigndata_;
  }
  if (roadsigndata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::HmiInterface::RoadSign>::GetOwningArena(roadsigndata);
    if (message_arena != submessage_arena) {
      roadsigndata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, roadsigndata, submessage_arena);
    }
    
  } else {
    
  }
  roadsigndata_ = roadsigndata;
  // @@protoc_insertion_point(field_set_allocated:HmiInterface.TrafficLightScene.roadsigndata)
}

// .HmiInterface.Crosswork crossworkdata = 5;
inline bool TrafficLightScene::_internal_has_crossworkdata() const {
  return this != internal_default_instance() && crossworkdata_ != nullptr;
}
inline bool TrafficLightScene::has_crossworkdata() const {
  return _internal_has_crossworkdata();
}
inline void TrafficLightScene::clear_crossworkdata() {
  if (GetArenaForAllocation() == nullptr && crossworkdata_ != nullptr) {
    delete crossworkdata_;
  }
  crossworkdata_ = nullptr;
}
inline const ::HmiInterface::Crosswork& TrafficLightScene::_internal_crossworkdata() const {
  const ::HmiInterface::Crosswork* p = crossworkdata_;
  return p != nullptr ? *p : reinterpret_cast<const ::HmiInterface::Crosswork&>(
      ::HmiInterface::_Crosswork_default_instance_);
}
inline const ::HmiInterface::Crosswork& TrafficLightScene::crossworkdata() const {
  // @@protoc_insertion_point(field_get:HmiInterface.TrafficLightScene.crossworkdata)
  return _internal_crossworkdata();
}
inline void TrafficLightScene::unsafe_arena_set_allocated_crossworkdata(
    ::HmiInterface::Crosswork* crossworkdata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(crossworkdata_);
  }
  crossworkdata_ = crossworkdata;
  if (crossworkdata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HmiInterface.TrafficLightScene.crossworkdata)
}
inline ::HmiInterface::Crosswork* TrafficLightScene::release_crossworkdata() {
  
  ::HmiInterface::Crosswork* temp = crossworkdata_;
  crossworkdata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::HmiInterface::Crosswork* TrafficLightScene::unsafe_arena_release_crossworkdata() {
  // @@protoc_insertion_point(field_release:HmiInterface.TrafficLightScene.crossworkdata)
  
  ::HmiInterface::Crosswork* temp = crossworkdata_;
  crossworkdata_ = nullptr;
  return temp;
}
inline ::HmiInterface::Crosswork* TrafficLightScene::_internal_mutable_crossworkdata() {
  
  if (crossworkdata_ == nullptr) {
    auto* p = CreateMaybeMessage<::HmiInterface::Crosswork>(GetArenaForAllocation());
    crossworkdata_ = p;
  }
  return crossworkdata_;
}
inline ::HmiInterface::Crosswork* TrafficLightScene::mutable_crossworkdata() {
  ::HmiInterface::Crosswork* _msg = _internal_mutable_crossworkdata();
  // @@protoc_insertion_point(field_mutable:HmiInterface.TrafficLightScene.crossworkdata)
  return _msg;
}
inline void TrafficLightScene::set_allocated_crossworkdata(::HmiInterface::Crosswork* crossworkdata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete crossworkdata_;
  }
  if (crossworkdata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::HmiInterface::Crosswork>::GetOwningArena(crossworkdata);
    if (message_arena != submessage_arena) {
      crossworkdata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, crossworkdata, submessage_arena);
    }
    
  } else {
    
  }
  crossworkdata_ = crossworkdata;
  // @@protoc_insertion_point(field_set_allocated:HmiInterface.TrafficLightScene.crossworkdata)
}

// .HmiInterface.StopLine stoplinedata = 6;
inline bool TrafficLightScene::_internal_has_stoplinedata() const {
  return this != internal_default_instance() && stoplinedata_ != nullptr;
}
inline bool TrafficLightScene::has_stoplinedata() const {
  return _internal_has_stoplinedata();
}
inline void TrafficLightScene::clear_stoplinedata() {
  if (GetArenaForAllocation() == nullptr && stoplinedata_ != nullptr) {
    delete stoplinedata_;
  }
  stoplinedata_ = nullptr;
}
inline const ::HmiInterface::StopLine& TrafficLightScene::_internal_stoplinedata() const {
  const ::HmiInterface::StopLine* p = stoplinedata_;
  return p != nullptr ? *p : reinterpret_cast<const ::HmiInterface::StopLine&>(
      ::HmiInterface::_StopLine_default_instance_);
}
inline const ::HmiInterface::StopLine& TrafficLightScene::stoplinedata() const {
  // @@protoc_insertion_point(field_get:HmiInterface.TrafficLightScene.stoplinedata)
  return _internal_stoplinedata();
}
inline void TrafficLightScene::unsafe_arena_set_allocated_stoplinedata(
    ::HmiInterface::StopLine* stoplinedata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(stoplinedata_);
  }
  stoplinedata_ = stoplinedata;
  if (stoplinedata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HmiInterface.TrafficLightScene.stoplinedata)
}
inline ::HmiInterface::StopLine* TrafficLightScene::release_stoplinedata() {
  
  ::HmiInterface::StopLine* temp = stoplinedata_;
  stoplinedata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::HmiInterface::StopLine* TrafficLightScene::unsafe_arena_release_stoplinedata() {
  // @@protoc_insertion_point(field_release:HmiInterface.TrafficLightScene.stoplinedata)
  
  ::HmiInterface::StopLine* temp = stoplinedata_;
  stoplinedata_ = nullptr;
  return temp;
}
inline ::HmiInterface::StopLine* TrafficLightScene::_internal_mutable_stoplinedata() {
  
  if (stoplinedata_ == nullptr) {
    auto* p = CreateMaybeMessage<::HmiInterface::StopLine>(GetArenaForAllocation());
    stoplinedata_ = p;
  }
  return stoplinedata_;
}
inline ::HmiInterface::StopLine* TrafficLightScene::mutable_stoplinedata() {
  ::HmiInterface::StopLine* _msg = _internal_mutable_stoplinedata();
  // @@protoc_insertion_point(field_mutable:HmiInterface.TrafficLightScene.stoplinedata)
  return _msg;
}
inline void TrafficLightScene::set_allocated_stoplinedata(::HmiInterface::StopLine* stoplinedata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete stoplinedata_;
  }
  if (stoplinedata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::HmiInterface::StopLine>::GetOwningArena(stoplinedata);
    if (message_arena != submessage_arena) {
      stoplinedata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stoplinedata, submessage_arena);
    }
    
  } else {
    
  }
  stoplinedata_ = stoplinedata;
  // @@protoc_insertion_point(field_set_allocated:HmiInterface.TrafficLightScene.stoplinedata)
}

// .HmiInterface.YellowGLine yellowglinedata = 7;
inline bool TrafficLightScene::_internal_has_yellowglinedata() const {
  return this != internal_default_instance() && yellowglinedata_ != nullptr;
}
inline bool TrafficLightScene::has_yellowglinedata() const {
  return _internal_has_yellowglinedata();
}
inline void TrafficLightScene::clear_yellowglinedata() {
  if (GetArenaForAllocation() == nullptr && yellowglinedata_ != nullptr) {
    delete yellowglinedata_;
  }
  yellowglinedata_ = nullptr;
}
inline const ::HmiInterface::YellowGLine& TrafficLightScene::_internal_yellowglinedata() const {
  const ::HmiInterface::YellowGLine* p = yellowglinedata_;
  return p != nullptr ? *p : reinterpret_cast<const ::HmiInterface::YellowGLine&>(
      ::HmiInterface::_YellowGLine_default_instance_);
}
inline const ::HmiInterface::YellowGLine& TrafficLightScene::yellowglinedata() const {
  // @@protoc_insertion_point(field_get:HmiInterface.TrafficLightScene.yellowglinedata)
  return _internal_yellowglinedata();
}
inline void TrafficLightScene::unsafe_arena_set_allocated_yellowglinedata(
    ::HmiInterface::YellowGLine* yellowglinedata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(yellowglinedata_);
  }
  yellowglinedata_ = yellowglinedata;
  if (yellowglinedata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HmiInterface.TrafficLightScene.yellowglinedata)
}
inline ::HmiInterface::YellowGLine* TrafficLightScene::release_yellowglinedata() {
  
  ::HmiInterface::YellowGLine* temp = yellowglinedata_;
  yellowglinedata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::HmiInterface::YellowGLine* TrafficLightScene::unsafe_arena_release_yellowglinedata() {
  // @@protoc_insertion_point(field_release:HmiInterface.TrafficLightScene.yellowglinedata)
  
  ::HmiInterface::YellowGLine* temp = yellowglinedata_;
  yellowglinedata_ = nullptr;
  return temp;
}
inline ::HmiInterface::YellowGLine* TrafficLightScene::_internal_mutable_yellowglinedata() {
  
  if (yellowglinedata_ == nullptr) {
    auto* p = CreateMaybeMessage<::HmiInterface::YellowGLine>(GetArenaForAllocation());
    yellowglinedata_ = p;
  }
  return yellowglinedata_;
}
inline ::HmiInterface::YellowGLine* TrafficLightScene::mutable_yellowglinedata() {
  ::HmiInterface::YellowGLine* _msg = _internal_mutable_yellowglinedata();
  // @@protoc_insertion_point(field_mutable:HmiInterface.TrafficLightScene.yellowglinedata)
  return _msg;
}
inline void TrafficLightScene::set_allocated_yellowglinedata(::HmiInterface::YellowGLine* yellowglinedata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete yellowglinedata_;
  }
  if (yellowglinedata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::HmiInterface::YellowGLine>::GetOwningArena(yellowglinedata);
    if (message_arena != submessage_arena) {
      yellowglinedata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, yellowglinedata, submessage_arena);
    }
    
  } else {
    
  }
  yellowglinedata_ = yellowglinedata;
  // @@protoc_insertion_point(field_set_allocated:HmiInterface.TrafficLightScene.yellowglinedata)
}

// -------------------------------------------------------------------

// BasicTrafficLightScene

// .HmiInterface.TrafficLightScene trafficlight = 1;
inline bool BasicTrafficLightScene::_internal_has_trafficlight() const {
  return this != internal_default_instance() && trafficlight_ != nullptr;
}
inline bool BasicTrafficLightScene::has_trafficlight() const {
  return _internal_has_trafficlight();
}
inline void BasicTrafficLightScene::clear_trafficlight() {
  if (GetArenaForAllocation() == nullptr && trafficlight_ != nullptr) {
    delete trafficlight_;
  }
  trafficlight_ = nullptr;
}
inline const ::HmiInterface::TrafficLightScene& BasicTrafficLightScene::_internal_trafficlight() const {
  const ::HmiInterface::TrafficLightScene* p = trafficlight_;
  return p != nullptr ? *p : reinterpret_cast<const ::HmiInterface::TrafficLightScene&>(
      ::HmiInterface::_TrafficLightScene_default_instance_);
}
inline const ::HmiInterface::TrafficLightScene& BasicTrafficLightScene::trafficlight() const {
  // @@protoc_insertion_point(field_get:HmiInterface.BasicTrafficLightScene.trafficlight)
  return _internal_trafficlight();
}
inline void BasicTrafficLightScene::unsafe_arena_set_allocated_trafficlight(
    ::HmiInterface::TrafficLightScene* trafficlight) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(trafficlight_);
  }
  trafficlight_ = trafficlight;
  if (trafficlight) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HmiInterface.BasicTrafficLightScene.trafficlight)
}
inline ::HmiInterface::TrafficLightScene* BasicTrafficLightScene::release_trafficlight() {
  
  ::HmiInterface::TrafficLightScene* temp = trafficlight_;
  trafficlight_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::HmiInterface::TrafficLightScene* BasicTrafficLightScene::unsafe_arena_release_trafficlight() {
  // @@protoc_insertion_point(field_release:HmiInterface.BasicTrafficLightScene.trafficlight)
  
  ::HmiInterface::TrafficLightScene* temp = trafficlight_;
  trafficlight_ = nullptr;
  return temp;
}
inline ::HmiInterface::TrafficLightScene* BasicTrafficLightScene::_internal_mutable_trafficlight() {
  
  if (trafficlight_ == nullptr) {
    auto* p = CreateMaybeMessage<::HmiInterface::TrafficLightScene>(GetArenaForAllocation());
    trafficlight_ = p;
  }
  return trafficlight_;
}
inline ::HmiInterface::TrafficLightScene* BasicTrafficLightScene::mutable_trafficlight() {
  ::HmiInterface::TrafficLightScene* _msg = _internal_mutable_trafficlight();
  // @@protoc_insertion_point(field_mutable:HmiInterface.BasicTrafficLightScene.trafficlight)
  return _msg;
}
inline void BasicTrafficLightScene::set_allocated_trafficlight(::HmiInterface::TrafficLightScene* trafficlight) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete trafficlight_;
  }
  if (trafficlight) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::HmiInterface::TrafficLightScene>::GetOwningArena(trafficlight);
    if (message_arena != submessage_arena) {
      trafficlight = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, trafficlight, submessage_arena);
    }
    
  } else {
    
  }
  trafficlight_ = trafficlight;
  // @@protoc_insertion_point(field_set_allocated:HmiInterface.BasicTrafficLightScene.trafficlight)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace HmiInterface

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_hmi_5fbasic_5ftrafficlightscene_2eproto

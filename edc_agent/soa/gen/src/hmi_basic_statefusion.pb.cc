// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: hmi_basic_statefusion.proto

#include "hmi_basic_statefusion.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG
namespace HmiInterface {
constexpr ACCIACCNIDStatus::ACCIACCNIDStatus(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : ad_ndastatus_(0u)
  , ad_iacchwamode_(0u)
  , ad_tjpstatus_(0u)
  , ad_accmode_(0u){}
struct ACCIACCNIDStatusDefaultTypeInternal {
  constexpr ACCIACCNIDStatusDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ACCIACCNIDStatusDefaultTypeInternal() {}
  union {
    ACCIACCNIDStatus _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ACCIACCNIDStatusDefaultTypeInternal _ACCIACCNIDStatus_default_instance_;
constexpr TakeOverEyeWarning::TakeOverEyeWarning(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : ad_handsonreq_(0u)
  , ad_safetynotice_(0u)
  , ad_lngtakeoverreq_(0u)
  , ad_dynamicwarninglevel_(0u)
  , ad_lattakeoverreq_(0u)
  , ads_eomwarnning_(0u){}
struct TakeOverEyeWarningDefaultTypeInternal {
  constexpr TakeOverEyeWarningDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~TakeOverEyeWarningDefaultTypeInternal() {}
  union {
    TakeOverEyeWarning _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT TakeOverEyeWarningDefaultTypeInternal _TakeOverEyeWarning_default_instance_;
constexpr FollowCarDis::FollowCarDis(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : acc_distancelevel_(0u){}
struct FollowCarDisDefaultTypeInternal {
  constexpr FollowCarDisDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~FollowCarDisDefaultTypeInternal() {}
  union {
    FollowCarDis _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT FollowCarDisDefaultTypeInternal _FollowCarDis_default_instance_;
constexpr LeftBSDStatus::LeftBSDStatus(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : lcdar_left_bsd_lcaalert_(0u)
  , lcdar_bsd_lcaalert_(0u){}
struct LeftBSDStatusDefaultTypeInternal {
  constexpr LeftBSDStatusDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~LeftBSDStatusDefaultTypeInternal() {}
  union {
    LeftBSDStatus _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT LeftBSDStatusDefaultTypeInternal _LeftBSDStatus_default_instance_;
constexpr SensorStatus::SensorStatus(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : acc_fradarfailurestatus_(0u)
  , acc_fradarcalibrationstatus_(0u)
  , las_frontcamerafailurestatus_(0u)
  , las_frontcameracalibrationstatus_(0u)
  , ads_flc_systemstatus_(0u)
  , ads_frc_systemstatus_(0u)
  , lcdal_systemstatus_(0u)
  , lcdar_systemstatus_(0u){}
struct SensorStatusDefaultTypeInternal {
  constexpr SensorStatusDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~SensorStatusDefaultTypeInternal() {}
  union {
    SensorStatus _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT SensorStatusDefaultTypeInternal _SensorStatus_default_instance_;
constexpr Gatewaystatus::Gatewaystatus(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : w_adssecocverifyfailureflag_(0u){}
struct GatewaystatusDefaultTypeInternal {
  constexpr GatewaystatusDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~GatewaystatusDefaultTypeInternal() {}
  union {
    Gatewaystatus _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT GatewaystatusDefaultTypeInternal _Gatewaystatus_default_instance_;
constexpr AutoLightStatus::AutoLightStatus(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : las_hmastatus_(0u){}
struct AutoLightStatusDefaultTypeInternal {
  constexpr AutoLightStatusDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~AutoLightStatusDefaultTypeInternal() {}
  union {
    AutoLightStatus _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT AutoLightStatusDefaultTypeInternal _AutoLightStatus_default_instance_;
constexpr Statefusion::Statefusion(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : autolightstatus_(nullptr)
  , gatewaystatus_(nullptr)
  , sensorstatus_(nullptr)
  , lrbsdstatus_(nullptr)
  , accdislevel_(nullptr)
  , takeovereyewarning_(nullptr)
  , acciaccnidstatus_(nullptr){}
struct StatefusionDefaultTypeInternal {
  constexpr StatefusionDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~StatefusionDefaultTypeInternal() {}
  union {
    Statefusion _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT StatefusionDefaultTypeInternal _Statefusion_default_instance_;
constexpr BasicStateFusion::BasicStateFusion(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : status_fusion_(nullptr){}
struct BasicStateFusionDefaultTypeInternal {
  constexpr BasicStateFusionDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~BasicStateFusionDefaultTypeInternal() {}
  union {
    BasicStateFusion _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT BasicStateFusionDefaultTypeInternal _BasicStateFusion_default_instance_;
}  // namespace HmiInterface
static ::PROTOBUF_NAMESPACE_ID::Metadata file_level_metadata_hmi_5fbasic_5fstatefusion_2eproto[9];
static constexpr ::PROTOBUF_NAMESPACE_ID::EnumDescriptor const** file_level_enum_descriptors_hmi_5fbasic_5fstatefusion_2eproto = nullptr;
static constexpr ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor const** file_level_service_descriptors_hmi_5fbasic_5fstatefusion_2eproto = nullptr;

const uint32_t TableStruct_hmi_5fbasic_5fstatefusion_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::HmiInterface::ACCIACCNIDStatus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::HmiInterface::ACCIACCNIDStatus, ad_ndastatus_),
  PROTOBUF_FIELD_OFFSET(::HmiInterface::ACCIACCNIDStatus, ad_iacchwamode_),
  PROTOBUF_FIELD_OFFSET(::HmiInterface::ACCIACCNIDStatus, ad_tjpstatus_),
  PROTOBUF_FIELD_OFFSET(::HmiInterface::ACCIACCNIDStatus, ad_accmode_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::HmiInterface::TakeOverEyeWarning, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::HmiInterface::TakeOverEyeWarning, ad_handsonreq_),
  PROTOBUF_FIELD_OFFSET(::HmiInterface::TakeOverEyeWarning, ad_safetynotice_),
  PROTOBUF_FIELD_OFFSET(::HmiInterface::TakeOverEyeWarning, ad_lngtakeoverreq_),
  PROTOBUF_FIELD_OFFSET(::HmiInterface::TakeOverEyeWarning, ad_dynamicwarninglevel_),
  PROTOBUF_FIELD_OFFSET(::HmiInterface::TakeOverEyeWarning, ad_lattakeoverreq_),
  PROTOBUF_FIELD_OFFSET(::HmiInterface::TakeOverEyeWarning, ads_eomwarnning_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::HmiInterface::FollowCarDis, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::HmiInterface::FollowCarDis, acc_distancelevel_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::HmiInterface::LeftBSDStatus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::HmiInterface::LeftBSDStatus, lcdar_left_bsd_lcaalert_),
  PROTOBUF_FIELD_OFFSET(::HmiInterface::LeftBSDStatus, lcdar_bsd_lcaalert_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::HmiInterface::SensorStatus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::HmiInterface::SensorStatus, acc_fradarfailurestatus_),
  PROTOBUF_FIELD_OFFSET(::HmiInterface::SensorStatus, acc_fradarcalibrationstatus_),
  PROTOBUF_FIELD_OFFSET(::HmiInterface::SensorStatus, las_frontcamerafailurestatus_),
  PROTOBUF_FIELD_OFFSET(::HmiInterface::SensorStatus, las_frontcameracalibrationstatus_),
  PROTOBUF_FIELD_OFFSET(::HmiInterface::SensorStatus, ads_flc_systemstatus_),
  PROTOBUF_FIELD_OFFSET(::HmiInterface::SensorStatus, ads_frc_systemstatus_),
  PROTOBUF_FIELD_OFFSET(::HmiInterface::SensorStatus, lcdal_systemstatus_),
  PROTOBUF_FIELD_OFFSET(::HmiInterface::SensorStatus, lcdar_systemstatus_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::HmiInterface::Gatewaystatus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::HmiInterface::Gatewaystatus, w_adssecocverifyfailureflag_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::HmiInterface::AutoLightStatus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::HmiInterface::AutoLightStatus, las_hmastatus_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::HmiInterface::Statefusion, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::HmiInterface::Statefusion, autolightstatus_),
  PROTOBUF_FIELD_OFFSET(::HmiInterface::Statefusion, gatewaystatus_),
  PROTOBUF_FIELD_OFFSET(::HmiInterface::Statefusion, sensorstatus_),
  PROTOBUF_FIELD_OFFSET(::HmiInterface::Statefusion, lrbsdstatus_),
  PROTOBUF_FIELD_OFFSET(::HmiInterface::Statefusion, accdislevel_),
  PROTOBUF_FIELD_OFFSET(::HmiInterface::Statefusion, takeovereyewarning_),
  PROTOBUF_FIELD_OFFSET(::HmiInterface::Statefusion, acciaccnidstatus_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::HmiInterface::BasicStateFusion, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::HmiInterface::BasicStateFusion, status_fusion_),
};
static const ::PROTOBUF_NAMESPACE_ID::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, -1, sizeof(::HmiInterface::ACCIACCNIDStatus)},
  { 10, -1, -1, sizeof(::HmiInterface::TakeOverEyeWarning)},
  { 22, -1, -1, sizeof(::HmiInterface::FollowCarDis)},
  { 29, -1, -1, sizeof(::HmiInterface::LeftBSDStatus)},
  { 37, -1, -1, sizeof(::HmiInterface::SensorStatus)},
  { 51, -1, -1, sizeof(::HmiInterface::Gatewaystatus)},
  { 58, -1, -1, sizeof(::HmiInterface::AutoLightStatus)},
  { 65, -1, -1, sizeof(::HmiInterface::Statefusion)},
  { 78, -1, -1, sizeof(::HmiInterface::BasicStateFusion)},
};

static ::PROTOBUF_NAMESPACE_ID::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::HmiInterface::_ACCIACCNIDStatus_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::HmiInterface::_TakeOverEyeWarning_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::HmiInterface::_FollowCarDis_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::HmiInterface::_LeftBSDStatus_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::HmiInterface::_SensorStatus_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::HmiInterface::_Gatewaystatus_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::HmiInterface::_AutoLightStatus_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::HmiInterface::_Statefusion_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::HmiInterface::_BasicStateFusion_default_instance_),
};

const char descriptor_table_protodef_hmi_5fbasic_5fstatefusion_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\033hmi_basic_statefusion.proto\022\014HmiInterf"
  "ace\"j\n\020ACCIACCNIDStatus\022\024\n\014ad_ndastatus\030"
  "\001 \001(\r\022\026\n\016ad_iacchwamode\030\002 \001(\r\022\024\n\014ad_tjps"
  "tatus\030\003 \001(\r\022\022\n\nad_accmode\030\004 \001(\r\"\263\001\n\022Take"
  "OverEyeWarning\022\025\n\rad_handsonreq\030\001 \001(\r\022\027\n"
  "\017ad_safetynotice\030\002 \001(\r\022\031\n\021ad_lngtakeover"
  "req\030\003 \001(\r\022\036\n\026ad_dynamicwarninglevel\030\004 \001("
  "\r\022\031\n\021ad_lattakeoverreq\030\005 \001(\r\022\027\n\017ads_eomw"
  "arnning\030\006 \001(\r\")\n\014FollowCarDis\022\031\n\021acc_dis"
  "tancelevel\030\001 \001(\r\"L\n\rLeftBSDStatus\022\037\n\027lcd"
  "ar_left_bsd_lcaalert\030\001 \001(\r\022\032\n\022lcdar_bsd_"
  "lcaalert\030\002 \001(\r\"\230\002\n\014SensorStatus\022\037\n\027acc_f"
  "radarfailurestatus\030\001 \001(\r\022#\n\033acc_fradarca"
  "librationstatus\030\002 \001(\r\022$\n\034las_frontcamera"
  "failurestatus\030\003 \001(\r\022(\n las_frontcameraca"
  "librationstatus\030\004 \001(\r\022\034\n\024ads_flc_systems"
  "tatus\030\005 \001(\r\022\034\n\024ads_frc_systemstatus\030\006 \001("
  "\r\022\032\n\022lcdal_systemstatus\030\007 \001(\r\022\032\n\022lcdar_s"
  "ystemstatus\030\010 \001(\r\"4\n\rGatewaystatus\022#\n\033w_"
  "adssecocverifyfailureflag\030\001 \001(\r\"(\n\017AutoL"
  "ightStatus\022\025\n\rlas_hmastatus\030\001 \001(\r\"\206\003\n\013St"
  "atefusion\0226\n\017autolightstatus\030\001 \001(\0132\035.Hmi"
  "Interface.AutoLightStatus\0222\n\rgatewaystat"
  "us\030\002 \001(\0132\033.HmiInterface.Gatewaystatus\0220\n"
  "\014sensorstatus\030\003 \001(\0132\032.HmiInterface.Senso"
  "rStatus\0220\n\013lrbsdstatus\030\004 \001(\0132\033.HmiInterf"
  "ace.LeftBSDStatus\022/\n\013accdislevel\030\005 \001(\0132\032"
  ".HmiInterface.FollowCarDis\022<\n\022takeoverey"
  "ewarning\030\006 \001(\0132 .HmiInterface.TakeOverEy"
  "eWarning\0228\n\020acciaccnidstatus\030\007 \001(\0132\036.Hmi"
  "Interface.ACCIACCNIDStatus\"D\n\020BasicState"
  "Fusion\0220\n\rstatus_fusion\030\001 \001(\0132\031.HmiInter"
  "face.Statefusionb\006proto3"
  ;
static ::PROTOBUF_NAMESPACE_ID::internal::once_flag descriptor_table_hmi_5fbasic_5fstatefusion_2eproto_once;
const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_hmi_5fbasic_5fstatefusion_2eproto = {
  false, false, 1304, descriptor_table_protodef_hmi_5fbasic_5fstatefusion_2eproto, "hmi_basic_statefusion.proto", 
  &descriptor_table_hmi_5fbasic_5fstatefusion_2eproto_once, nullptr, 0, 9,
  schemas, file_default_instances, TableStruct_hmi_5fbasic_5fstatefusion_2eproto::offsets,
  file_level_metadata_hmi_5fbasic_5fstatefusion_2eproto, file_level_enum_descriptors_hmi_5fbasic_5fstatefusion_2eproto, file_level_service_descriptors_hmi_5fbasic_5fstatefusion_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable* descriptor_table_hmi_5fbasic_5fstatefusion_2eproto_getter() {
  return &descriptor_table_hmi_5fbasic_5fstatefusion_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY static ::PROTOBUF_NAMESPACE_ID::internal::AddDescriptorsRunner dynamic_init_dummy_hmi_5fbasic_5fstatefusion_2eproto(&descriptor_table_hmi_5fbasic_5fstatefusion_2eproto);
namespace HmiInterface {

// ===================================================================

class ACCIACCNIDStatus::_Internal {
 public:
};

ACCIACCNIDStatus::ACCIACCNIDStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:HmiInterface.ACCIACCNIDStatus)
}
ACCIACCNIDStatus::ACCIACCNIDStatus(const ACCIACCNIDStatus& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&ad_ndastatus_, &from.ad_ndastatus_,
    static_cast<size_t>(reinterpret_cast<char*>(&ad_accmode_) -
    reinterpret_cast<char*>(&ad_ndastatus_)) + sizeof(ad_accmode_));
  // @@protoc_insertion_point(copy_constructor:HmiInterface.ACCIACCNIDStatus)
}

inline void ACCIACCNIDStatus::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&ad_ndastatus_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&ad_accmode_) -
    reinterpret_cast<char*>(&ad_ndastatus_)) + sizeof(ad_accmode_));
}

ACCIACCNIDStatus::~ACCIACCNIDStatus() {
  // @@protoc_insertion_point(destructor:HmiInterface.ACCIACCNIDStatus)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void ACCIACCNIDStatus::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ACCIACCNIDStatus::ArenaDtor(void* object) {
  ACCIACCNIDStatus* _this = reinterpret_cast< ACCIACCNIDStatus* >(object);
  (void)_this;
}
void ACCIACCNIDStatus::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ACCIACCNIDStatus::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ACCIACCNIDStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:HmiInterface.ACCIACCNIDStatus)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&ad_ndastatus_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&ad_accmode_) -
      reinterpret_cast<char*>(&ad_ndastatus_)) + sizeof(ad_accmode_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ACCIACCNIDStatus::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 ad_ndastatus = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          ad_ndastatus_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 ad_iacchwamode = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          ad_iacchwamode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 ad_tjpstatus = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          ad_tjpstatus_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 ad_accmode = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          ad_accmode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ACCIACCNIDStatus::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:HmiInterface.ACCIACCNIDStatus)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 ad_ndastatus = 1;
  if (this->_internal_ad_ndastatus() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_ad_ndastatus(), target);
  }

  // uint32 ad_iacchwamode = 2;
  if (this->_internal_ad_iacchwamode() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_ad_iacchwamode(), target);
  }

  // uint32 ad_tjpstatus = 3;
  if (this->_internal_ad_tjpstatus() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_ad_tjpstatus(), target);
  }

  // uint32 ad_accmode = 4;
  if (this->_internal_ad_accmode() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(4, this->_internal_ad_accmode(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:HmiInterface.ACCIACCNIDStatus)
  return target;
}

size_t ACCIACCNIDStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:HmiInterface.ACCIACCNIDStatus)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint32 ad_ndastatus = 1;
  if (this->_internal_ad_ndastatus() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_ad_ndastatus());
  }

  // uint32 ad_iacchwamode = 2;
  if (this->_internal_ad_iacchwamode() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_ad_iacchwamode());
  }

  // uint32 ad_tjpstatus = 3;
  if (this->_internal_ad_tjpstatus() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_ad_tjpstatus());
  }

  // uint32 ad_accmode = 4;
  if (this->_internal_ad_accmode() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_ad_accmode());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ACCIACCNIDStatus::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ACCIACCNIDStatus::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ACCIACCNIDStatus::GetClassData() const { return &_class_data_; }

void ACCIACCNIDStatus::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ACCIACCNIDStatus *>(to)->MergeFrom(
      static_cast<const ACCIACCNIDStatus &>(from));
}


void ACCIACCNIDStatus::MergeFrom(const ACCIACCNIDStatus& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:HmiInterface.ACCIACCNIDStatus)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_ad_ndastatus() != 0) {
    _internal_set_ad_ndastatus(from._internal_ad_ndastatus());
  }
  if (from._internal_ad_iacchwamode() != 0) {
    _internal_set_ad_iacchwamode(from._internal_ad_iacchwamode());
  }
  if (from._internal_ad_tjpstatus() != 0) {
    _internal_set_ad_tjpstatus(from._internal_ad_tjpstatus());
  }
  if (from._internal_ad_accmode() != 0) {
    _internal_set_ad_accmode(from._internal_ad_accmode());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ACCIACCNIDStatus::CopyFrom(const ACCIACCNIDStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:HmiInterface.ACCIACCNIDStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ACCIACCNIDStatus::IsInitialized() const {
  return true;
}

void ACCIACCNIDStatus::InternalSwap(ACCIACCNIDStatus* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ACCIACCNIDStatus, ad_accmode_)
      + sizeof(ACCIACCNIDStatus::ad_accmode_)
      - PROTOBUF_FIELD_OFFSET(ACCIACCNIDStatus, ad_ndastatus_)>(
          reinterpret_cast<char*>(&ad_ndastatus_),
          reinterpret_cast<char*>(&other->ad_ndastatus_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ACCIACCNIDStatus::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_hmi_5fbasic_5fstatefusion_2eproto_getter, &descriptor_table_hmi_5fbasic_5fstatefusion_2eproto_once,
      file_level_metadata_hmi_5fbasic_5fstatefusion_2eproto[0]);
}

// ===================================================================

class TakeOverEyeWarning::_Internal {
 public:
};

TakeOverEyeWarning::TakeOverEyeWarning(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:HmiInterface.TakeOverEyeWarning)
}
TakeOverEyeWarning::TakeOverEyeWarning(const TakeOverEyeWarning& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&ad_handsonreq_, &from.ad_handsonreq_,
    static_cast<size_t>(reinterpret_cast<char*>(&ads_eomwarnning_) -
    reinterpret_cast<char*>(&ad_handsonreq_)) + sizeof(ads_eomwarnning_));
  // @@protoc_insertion_point(copy_constructor:HmiInterface.TakeOverEyeWarning)
}

inline void TakeOverEyeWarning::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&ad_handsonreq_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&ads_eomwarnning_) -
    reinterpret_cast<char*>(&ad_handsonreq_)) + sizeof(ads_eomwarnning_));
}

TakeOverEyeWarning::~TakeOverEyeWarning() {
  // @@protoc_insertion_point(destructor:HmiInterface.TakeOverEyeWarning)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void TakeOverEyeWarning::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void TakeOverEyeWarning::ArenaDtor(void* object) {
  TakeOverEyeWarning* _this = reinterpret_cast< TakeOverEyeWarning* >(object);
  (void)_this;
}
void TakeOverEyeWarning::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TakeOverEyeWarning::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void TakeOverEyeWarning::Clear() {
// @@protoc_insertion_point(message_clear_start:HmiInterface.TakeOverEyeWarning)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&ad_handsonreq_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&ads_eomwarnning_) -
      reinterpret_cast<char*>(&ad_handsonreq_)) + sizeof(ads_eomwarnning_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TakeOverEyeWarning::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 ad_handsonreq = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          ad_handsonreq_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 ad_safetynotice = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          ad_safetynotice_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 ad_lngtakeoverreq = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          ad_lngtakeoverreq_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 ad_dynamicwarninglevel = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          ad_dynamicwarninglevel_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 ad_lattakeoverreq = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          ad_lattakeoverreq_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 ads_eomwarnning = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          ads_eomwarnning_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TakeOverEyeWarning::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:HmiInterface.TakeOverEyeWarning)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 ad_handsonreq = 1;
  if (this->_internal_ad_handsonreq() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_ad_handsonreq(), target);
  }

  // uint32 ad_safetynotice = 2;
  if (this->_internal_ad_safetynotice() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_ad_safetynotice(), target);
  }

  // uint32 ad_lngtakeoverreq = 3;
  if (this->_internal_ad_lngtakeoverreq() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_ad_lngtakeoverreq(), target);
  }

  // uint32 ad_dynamicwarninglevel = 4;
  if (this->_internal_ad_dynamicwarninglevel() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(4, this->_internal_ad_dynamicwarninglevel(), target);
  }

  // uint32 ad_lattakeoverreq = 5;
  if (this->_internal_ad_lattakeoverreq() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(5, this->_internal_ad_lattakeoverreq(), target);
  }

  // uint32 ads_eomwarnning = 6;
  if (this->_internal_ads_eomwarnning() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(6, this->_internal_ads_eomwarnning(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:HmiInterface.TakeOverEyeWarning)
  return target;
}

size_t TakeOverEyeWarning::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:HmiInterface.TakeOverEyeWarning)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint32 ad_handsonreq = 1;
  if (this->_internal_ad_handsonreq() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_ad_handsonreq());
  }

  // uint32 ad_safetynotice = 2;
  if (this->_internal_ad_safetynotice() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_ad_safetynotice());
  }

  // uint32 ad_lngtakeoverreq = 3;
  if (this->_internal_ad_lngtakeoverreq() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_ad_lngtakeoverreq());
  }

  // uint32 ad_dynamicwarninglevel = 4;
  if (this->_internal_ad_dynamicwarninglevel() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_ad_dynamicwarninglevel());
  }

  // uint32 ad_lattakeoverreq = 5;
  if (this->_internal_ad_lattakeoverreq() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_ad_lattakeoverreq());
  }

  // uint32 ads_eomwarnning = 6;
  if (this->_internal_ads_eomwarnning() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_ads_eomwarnning());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TakeOverEyeWarning::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    TakeOverEyeWarning::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TakeOverEyeWarning::GetClassData() const { return &_class_data_; }

void TakeOverEyeWarning::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<TakeOverEyeWarning *>(to)->MergeFrom(
      static_cast<const TakeOverEyeWarning &>(from));
}


void TakeOverEyeWarning::MergeFrom(const TakeOverEyeWarning& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:HmiInterface.TakeOverEyeWarning)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_ad_handsonreq() != 0) {
    _internal_set_ad_handsonreq(from._internal_ad_handsonreq());
  }
  if (from._internal_ad_safetynotice() != 0) {
    _internal_set_ad_safetynotice(from._internal_ad_safetynotice());
  }
  if (from._internal_ad_lngtakeoverreq() != 0) {
    _internal_set_ad_lngtakeoverreq(from._internal_ad_lngtakeoverreq());
  }
  if (from._internal_ad_dynamicwarninglevel() != 0) {
    _internal_set_ad_dynamicwarninglevel(from._internal_ad_dynamicwarninglevel());
  }
  if (from._internal_ad_lattakeoverreq() != 0) {
    _internal_set_ad_lattakeoverreq(from._internal_ad_lattakeoverreq());
  }
  if (from._internal_ads_eomwarnning() != 0) {
    _internal_set_ads_eomwarnning(from._internal_ads_eomwarnning());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TakeOverEyeWarning::CopyFrom(const TakeOverEyeWarning& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:HmiInterface.TakeOverEyeWarning)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TakeOverEyeWarning::IsInitialized() const {
  return true;
}

void TakeOverEyeWarning::InternalSwap(TakeOverEyeWarning* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TakeOverEyeWarning, ads_eomwarnning_)
      + sizeof(TakeOverEyeWarning::ads_eomwarnning_)
      - PROTOBUF_FIELD_OFFSET(TakeOverEyeWarning, ad_handsonreq_)>(
          reinterpret_cast<char*>(&ad_handsonreq_),
          reinterpret_cast<char*>(&other->ad_handsonreq_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TakeOverEyeWarning::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_hmi_5fbasic_5fstatefusion_2eproto_getter, &descriptor_table_hmi_5fbasic_5fstatefusion_2eproto_once,
      file_level_metadata_hmi_5fbasic_5fstatefusion_2eproto[1]);
}

// ===================================================================

class FollowCarDis::_Internal {
 public:
};

FollowCarDis::FollowCarDis(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:HmiInterface.FollowCarDis)
}
FollowCarDis::FollowCarDis(const FollowCarDis& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  acc_distancelevel_ = from.acc_distancelevel_;
  // @@protoc_insertion_point(copy_constructor:HmiInterface.FollowCarDis)
}

inline void FollowCarDis::SharedCtor() {
acc_distancelevel_ = 0u;
}

FollowCarDis::~FollowCarDis() {
  // @@protoc_insertion_point(destructor:HmiInterface.FollowCarDis)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void FollowCarDis::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void FollowCarDis::ArenaDtor(void* object) {
  FollowCarDis* _this = reinterpret_cast< FollowCarDis* >(object);
  (void)_this;
}
void FollowCarDis::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void FollowCarDis::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void FollowCarDis::Clear() {
// @@protoc_insertion_point(message_clear_start:HmiInterface.FollowCarDis)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  acc_distancelevel_ = 0u;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FollowCarDis::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 acc_distancelevel = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          acc_distancelevel_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FollowCarDis::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:HmiInterface.FollowCarDis)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 acc_distancelevel = 1;
  if (this->_internal_acc_distancelevel() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_acc_distancelevel(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:HmiInterface.FollowCarDis)
  return target;
}

size_t FollowCarDis::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:HmiInterface.FollowCarDis)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint32 acc_distancelevel = 1;
  if (this->_internal_acc_distancelevel() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_acc_distancelevel());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FollowCarDis::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    FollowCarDis::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FollowCarDis::GetClassData() const { return &_class_data_; }

void FollowCarDis::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<FollowCarDis *>(to)->MergeFrom(
      static_cast<const FollowCarDis &>(from));
}


void FollowCarDis::MergeFrom(const FollowCarDis& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:HmiInterface.FollowCarDis)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_acc_distancelevel() != 0) {
    _internal_set_acc_distancelevel(from._internal_acc_distancelevel());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FollowCarDis::CopyFrom(const FollowCarDis& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:HmiInterface.FollowCarDis)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FollowCarDis::IsInitialized() const {
  return true;
}

void FollowCarDis::InternalSwap(FollowCarDis* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(acc_distancelevel_, other->acc_distancelevel_);
}

::PROTOBUF_NAMESPACE_ID::Metadata FollowCarDis::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_hmi_5fbasic_5fstatefusion_2eproto_getter, &descriptor_table_hmi_5fbasic_5fstatefusion_2eproto_once,
      file_level_metadata_hmi_5fbasic_5fstatefusion_2eproto[2]);
}

// ===================================================================

class LeftBSDStatus::_Internal {
 public:
};

LeftBSDStatus::LeftBSDStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:HmiInterface.LeftBSDStatus)
}
LeftBSDStatus::LeftBSDStatus(const LeftBSDStatus& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&lcdar_left_bsd_lcaalert_, &from.lcdar_left_bsd_lcaalert_,
    static_cast<size_t>(reinterpret_cast<char*>(&lcdar_bsd_lcaalert_) -
    reinterpret_cast<char*>(&lcdar_left_bsd_lcaalert_)) + sizeof(lcdar_bsd_lcaalert_));
  // @@protoc_insertion_point(copy_constructor:HmiInterface.LeftBSDStatus)
}

inline void LeftBSDStatus::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&lcdar_left_bsd_lcaalert_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&lcdar_bsd_lcaalert_) -
    reinterpret_cast<char*>(&lcdar_left_bsd_lcaalert_)) + sizeof(lcdar_bsd_lcaalert_));
}

LeftBSDStatus::~LeftBSDStatus() {
  // @@protoc_insertion_point(destructor:HmiInterface.LeftBSDStatus)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void LeftBSDStatus::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void LeftBSDStatus::ArenaDtor(void* object) {
  LeftBSDStatus* _this = reinterpret_cast< LeftBSDStatus* >(object);
  (void)_this;
}
void LeftBSDStatus::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void LeftBSDStatus::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void LeftBSDStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:HmiInterface.LeftBSDStatus)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&lcdar_left_bsd_lcaalert_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&lcdar_bsd_lcaalert_) -
      reinterpret_cast<char*>(&lcdar_left_bsd_lcaalert_)) + sizeof(lcdar_bsd_lcaalert_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LeftBSDStatus::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 lcdar_left_bsd_lcaalert = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          lcdar_left_bsd_lcaalert_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 lcdar_bsd_lcaalert = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          lcdar_bsd_lcaalert_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LeftBSDStatus::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:HmiInterface.LeftBSDStatus)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 lcdar_left_bsd_lcaalert = 1;
  if (this->_internal_lcdar_left_bsd_lcaalert() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_lcdar_left_bsd_lcaalert(), target);
  }

  // uint32 lcdar_bsd_lcaalert = 2;
  if (this->_internal_lcdar_bsd_lcaalert() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_lcdar_bsd_lcaalert(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:HmiInterface.LeftBSDStatus)
  return target;
}

size_t LeftBSDStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:HmiInterface.LeftBSDStatus)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint32 lcdar_left_bsd_lcaalert = 1;
  if (this->_internal_lcdar_left_bsd_lcaalert() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_lcdar_left_bsd_lcaalert());
  }

  // uint32 lcdar_bsd_lcaalert = 2;
  if (this->_internal_lcdar_bsd_lcaalert() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_lcdar_bsd_lcaalert());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LeftBSDStatus::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    LeftBSDStatus::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LeftBSDStatus::GetClassData() const { return &_class_data_; }

void LeftBSDStatus::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<LeftBSDStatus *>(to)->MergeFrom(
      static_cast<const LeftBSDStatus &>(from));
}


void LeftBSDStatus::MergeFrom(const LeftBSDStatus& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:HmiInterface.LeftBSDStatus)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_lcdar_left_bsd_lcaalert() != 0) {
    _internal_set_lcdar_left_bsd_lcaalert(from._internal_lcdar_left_bsd_lcaalert());
  }
  if (from._internal_lcdar_bsd_lcaalert() != 0) {
    _internal_set_lcdar_bsd_lcaalert(from._internal_lcdar_bsd_lcaalert());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LeftBSDStatus::CopyFrom(const LeftBSDStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:HmiInterface.LeftBSDStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LeftBSDStatus::IsInitialized() const {
  return true;
}

void LeftBSDStatus::InternalSwap(LeftBSDStatus* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LeftBSDStatus, lcdar_bsd_lcaalert_)
      + sizeof(LeftBSDStatus::lcdar_bsd_lcaalert_)
      - PROTOBUF_FIELD_OFFSET(LeftBSDStatus, lcdar_left_bsd_lcaalert_)>(
          reinterpret_cast<char*>(&lcdar_left_bsd_lcaalert_),
          reinterpret_cast<char*>(&other->lcdar_left_bsd_lcaalert_));
}

::PROTOBUF_NAMESPACE_ID::Metadata LeftBSDStatus::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_hmi_5fbasic_5fstatefusion_2eproto_getter, &descriptor_table_hmi_5fbasic_5fstatefusion_2eproto_once,
      file_level_metadata_hmi_5fbasic_5fstatefusion_2eproto[3]);
}

// ===================================================================

class SensorStatus::_Internal {
 public:
};

SensorStatus::SensorStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:HmiInterface.SensorStatus)
}
SensorStatus::SensorStatus(const SensorStatus& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&acc_fradarfailurestatus_, &from.acc_fradarfailurestatus_,
    static_cast<size_t>(reinterpret_cast<char*>(&lcdar_systemstatus_) -
    reinterpret_cast<char*>(&acc_fradarfailurestatus_)) + sizeof(lcdar_systemstatus_));
  // @@protoc_insertion_point(copy_constructor:HmiInterface.SensorStatus)
}

inline void SensorStatus::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&acc_fradarfailurestatus_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&lcdar_systemstatus_) -
    reinterpret_cast<char*>(&acc_fradarfailurestatus_)) + sizeof(lcdar_systemstatus_));
}

SensorStatus::~SensorStatus() {
  // @@protoc_insertion_point(destructor:HmiInterface.SensorStatus)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void SensorStatus::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SensorStatus::ArenaDtor(void* object) {
  SensorStatus* _this = reinterpret_cast< SensorStatus* >(object);
  (void)_this;
}
void SensorStatus::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void SensorStatus::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SensorStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:HmiInterface.SensorStatus)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&acc_fradarfailurestatus_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&lcdar_systemstatus_) -
      reinterpret_cast<char*>(&acc_fradarfailurestatus_)) + sizeof(lcdar_systemstatus_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SensorStatus::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 acc_fradarfailurestatus = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          acc_fradarfailurestatus_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 acc_fradarcalibrationstatus = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          acc_fradarcalibrationstatus_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 las_frontcamerafailurestatus = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          las_frontcamerafailurestatus_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 las_frontcameracalibrationstatus = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          las_frontcameracalibrationstatus_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 ads_flc_systemstatus = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          ads_flc_systemstatus_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 ads_frc_systemstatus = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          ads_frc_systemstatus_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 lcdal_systemstatus = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          lcdal_systemstatus_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 lcdar_systemstatus = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          lcdar_systemstatus_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SensorStatus::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:HmiInterface.SensorStatus)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 acc_fradarfailurestatus = 1;
  if (this->_internal_acc_fradarfailurestatus() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_acc_fradarfailurestatus(), target);
  }

  // uint32 acc_fradarcalibrationstatus = 2;
  if (this->_internal_acc_fradarcalibrationstatus() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_acc_fradarcalibrationstatus(), target);
  }

  // uint32 las_frontcamerafailurestatus = 3;
  if (this->_internal_las_frontcamerafailurestatus() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_las_frontcamerafailurestatus(), target);
  }

  // uint32 las_frontcameracalibrationstatus = 4;
  if (this->_internal_las_frontcameracalibrationstatus() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(4, this->_internal_las_frontcameracalibrationstatus(), target);
  }

  // uint32 ads_flc_systemstatus = 5;
  if (this->_internal_ads_flc_systemstatus() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(5, this->_internal_ads_flc_systemstatus(), target);
  }

  // uint32 ads_frc_systemstatus = 6;
  if (this->_internal_ads_frc_systemstatus() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(6, this->_internal_ads_frc_systemstatus(), target);
  }

  // uint32 lcdal_systemstatus = 7;
  if (this->_internal_lcdal_systemstatus() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(7, this->_internal_lcdal_systemstatus(), target);
  }

  // uint32 lcdar_systemstatus = 8;
  if (this->_internal_lcdar_systemstatus() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(8, this->_internal_lcdar_systemstatus(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:HmiInterface.SensorStatus)
  return target;
}

size_t SensorStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:HmiInterface.SensorStatus)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint32 acc_fradarfailurestatus = 1;
  if (this->_internal_acc_fradarfailurestatus() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_acc_fradarfailurestatus());
  }

  // uint32 acc_fradarcalibrationstatus = 2;
  if (this->_internal_acc_fradarcalibrationstatus() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_acc_fradarcalibrationstatus());
  }

  // uint32 las_frontcamerafailurestatus = 3;
  if (this->_internal_las_frontcamerafailurestatus() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_las_frontcamerafailurestatus());
  }

  // uint32 las_frontcameracalibrationstatus = 4;
  if (this->_internal_las_frontcameracalibrationstatus() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_las_frontcameracalibrationstatus());
  }

  // uint32 ads_flc_systemstatus = 5;
  if (this->_internal_ads_flc_systemstatus() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_ads_flc_systemstatus());
  }

  // uint32 ads_frc_systemstatus = 6;
  if (this->_internal_ads_frc_systemstatus() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_ads_frc_systemstatus());
  }

  // uint32 lcdal_systemstatus = 7;
  if (this->_internal_lcdal_systemstatus() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_lcdal_systemstatus());
  }

  // uint32 lcdar_systemstatus = 8;
  if (this->_internal_lcdar_systemstatus() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_lcdar_systemstatus());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SensorStatus::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    SensorStatus::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SensorStatus::GetClassData() const { return &_class_data_; }

void SensorStatus::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<SensorStatus *>(to)->MergeFrom(
      static_cast<const SensorStatus &>(from));
}


void SensorStatus::MergeFrom(const SensorStatus& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:HmiInterface.SensorStatus)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_acc_fradarfailurestatus() != 0) {
    _internal_set_acc_fradarfailurestatus(from._internal_acc_fradarfailurestatus());
  }
  if (from._internal_acc_fradarcalibrationstatus() != 0) {
    _internal_set_acc_fradarcalibrationstatus(from._internal_acc_fradarcalibrationstatus());
  }
  if (from._internal_las_frontcamerafailurestatus() != 0) {
    _internal_set_las_frontcamerafailurestatus(from._internal_las_frontcamerafailurestatus());
  }
  if (from._internal_las_frontcameracalibrationstatus() != 0) {
    _internal_set_las_frontcameracalibrationstatus(from._internal_las_frontcameracalibrationstatus());
  }
  if (from._internal_ads_flc_systemstatus() != 0) {
    _internal_set_ads_flc_systemstatus(from._internal_ads_flc_systemstatus());
  }
  if (from._internal_ads_frc_systemstatus() != 0) {
    _internal_set_ads_frc_systemstatus(from._internal_ads_frc_systemstatus());
  }
  if (from._internal_lcdal_systemstatus() != 0) {
    _internal_set_lcdal_systemstatus(from._internal_lcdal_systemstatus());
  }
  if (from._internal_lcdar_systemstatus() != 0) {
    _internal_set_lcdar_systemstatus(from._internal_lcdar_systemstatus());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SensorStatus::CopyFrom(const SensorStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:HmiInterface.SensorStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SensorStatus::IsInitialized() const {
  return true;
}

void SensorStatus::InternalSwap(SensorStatus* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SensorStatus, lcdar_systemstatus_)
      + sizeof(SensorStatus::lcdar_systemstatus_)
      - PROTOBUF_FIELD_OFFSET(SensorStatus, acc_fradarfailurestatus_)>(
          reinterpret_cast<char*>(&acc_fradarfailurestatus_),
          reinterpret_cast<char*>(&other->acc_fradarfailurestatus_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SensorStatus::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_hmi_5fbasic_5fstatefusion_2eproto_getter, &descriptor_table_hmi_5fbasic_5fstatefusion_2eproto_once,
      file_level_metadata_hmi_5fbasic_5fstatefusion_2eproto[4]);
}

// ===================================================================

class Gatewaystatus::_Internal {
 public:
};

Gatewaystatus::Gatewaystatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:HmiInterface.Gatewaystatus)
}
Gatewaystatus::Gatewaystatus(const Gatewaystatus& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  w_adssecocverifyfailureflag_ = from.w_adssecocverifyfailureflag_;
  // @@protoc_insertion_point(copy_constructor:HmiInterface.Gatewaystatus)
}

inline void Gatewaystatus::SharedCtor() {
w_adssecocverifyfailureflag_ = 0u;
}

Gatewaystatus::~Gatewaystatus() {
  // @@protoc_insertion_point(destructor:HmiInterface.Gatewaystatus)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void Gatewaystatus::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Gatewaystatus::ArenaDtor(void* object) {
  Gatewaystatus* _this = reinterpret_cast< Gatewaystatus* >(object);
  (void)_this;
}
void Gatewaystatus::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Gatewaystatus::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Gatewaystatus::Clear() {
// @@protoc_insertion_point(message_clear_start:HmiInterface.Gatewaystatus)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  w_adssecocverifyfailureflag_ = 0u;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Gatewaystatus::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 w_adssecocverifyfailureflag = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          w_adssecocverifyfailureflag_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Gatewaystatus::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:HmiInterface.Gatewaystatus)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 w_adssecocverifyfailureflag = 1;
  if (this->_internal_w_adssecocverifyfailureflag() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_w_adssecocverifyfailureflag(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:HmiInterface.Gatewaystatus)
  return target;
}

size_t Gatewaystatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:HmiInterface.Gatewaystatus)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint32 w_adssecocverifyfailureflag = 1;
  if (this->_internal_w_adssecocverifyfailureflag() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_w_adssecocverifyfailureflag());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Gatewaystatus::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    Gatewaystatus::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Gatewaystatus::GetClassData() const { return &_class_data_; }

void Gatewaystatus::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<Gatewaystatus *>(to)->MergeFrom(
      static_cast<const Gatewaystatus &>(from));
}


void Gatewaystatus::MergeFrom(const Gatewaystatus& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:HmiInterface.Gatewaystatus)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_w_adssecocverifyfailureflag() != 0) {
    _internal_set_w_adssecocverifyfailureflag(from._internal_w_adssecocverifyfailureflag());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Gatewaystatus::CopyFrom(const Gatewaystatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:HmiInterface.Gatewaystatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Gatewaystatus::IsInitialized() const {
  return true;
}

void Gatewaystatus::InternalSwap(Gatewaystatus* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(w_adssecocverifyfailureflag_, other->w_adssecocverifyfailureflag_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Gatewaystatus::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_hmi_5fbasic_5fstatefusion_2eproto_getter, &descriptor_table_hmi_5fbasic_5fstatefusion_2eproto_once,
      file_level_metadata_hmi_5fbasic_5fstatefusion_2eproto[5]);
}

// ===================================================================

class AutoLightStatus::_Internal {
 public:
};

AutoLightStatus::AutoLightStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:HmiInterface.AutoLightStatus)
}
AutoLightStatus::AutoLightStatus(const AutoLightStatus& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  las_hmastatus_ = from.las_hmastatus_;
  // @@protoc_insertion_point(copy_constructor:HmiInterface.AutoLightStatus)
}

inline void AutoLightStatus::SharedCtor() {
las_hmastatus_ = 0u;
}

AutoLightStatus::~AutoLightStatus() {
  // @@protoc_insertion_point(destructor:HmiInterface.AutoLightStatus)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void AutoLightStatus::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void AutoLightStatus::ArenaDtor(void* object) {
  AutoLightStatus* _this = reinterpret_cast< AutoLightStatus* >(object);
  (void)_this;
}
void AutoLightStatus::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void AutoLightStatus::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void AutoLightStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:HmiInterface.AutoLightStatus)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  las_hmastatus_ = 0u;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AutoLightStatus::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 las_hmastatus = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          las_hmastatus_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AutoLightStatus::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:HmiInterface.AutoLightStatus)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 las_hmastatus = 1;
  if (this->_internal_las_hmastatus() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_las_hmastatus(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:HmiInterface.AutoLightStatus)
  return target;
}

size_t AutoLightStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:HmiInterface.AutoLightStatus)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint32 las_hmastatus = 1;
  if (this->_internal_las_hmastatus() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_las_hmastatus());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AutoLightStatus::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    AutoLightStatus::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AutoLightStatus::GetClassData() const { return &_class_data_; }

void AutoLightStatus::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<AutoLightStatus *>(to)->MergeFrom(
      static_cast<const AutoLightStatus &>(from));
}


void AutoLightStatus::MergeFrom(const AutoLightStatus& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:HmiInterface.AutoLightStatus)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_las_hmastatus() != 0) {
    _internal_set_las_hmastatus(from._internal_las_hmastatus());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AutoLightStatus::CopyFrom(const AutoLightStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:HmiInterface.AutoLightStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AutoLightStatus::IsInitialized() const {
  return true;
}

void AutoLightStatus::InternalSwap(AutoLightStatus* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(las_hmastatus_, other->las_hmastatus_);
}

::PROTOBUF_NAMESPACE_ID::Metadata AutoLightStatus::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_hmi_5fbasic_5fstatefusion_2eproto_getter, &descriptor_table_hmi_5fbasic_5fstatefusion_2eproto_once,
      file_level_metadata_hmi_5fbasic_5fstatefusion_2eproto[6]);
}

// ===================================================================

class Statefusion::_Internal {
 public:
  static const ::HmiInterface::AutoLightStatus& autolightstatus(const Statefusion* msg);
  static const ::HmiInterface::Gatewaystatus& gatewaystatus(const Statefusion* msg);
  static const ::HmiInterface::SensorStatus& sensorstatus(const Statefusion* msg);
  static const ::HmiInterface::LeftBSDStatus& lrbsdstatus(const Statefusion* msg);
  static const ::HmiInterface::FollowCarDis& accdislevel(const Statefusion* msg);
  static const ::HmiInterface::TakeOverEyeWarning& takeovereyewarning(const Statefusion* msg);
  static const ::HmiInterface::ACCIACCNIDStatus& acciaccnidstatus(const Statefusion* msg);
};

const ::HmiInterface::AutoLightStatus&
Statefusion::_Internal::autolightstatus(const Statefusion* msg) {
  return *msg->autolightstatus_;
}
const ::HmiInterface::Gatewaystatus&
Statefusion::_Internal::gatewaystatus(const Statefusion* msg) {
  return *msg->gatewaystatus_;
}
const ::HmiInterface::SensorStatus&
Statefusion::_Internal::sensorstatus(const Statefusion* msg) {
  return *msg->sensorstatus_;
}
const ::HmiInterface::LeftBSDStatus&
Statefusion::_Internal::lrbsdstatus(const Statefusion* msg) {
  return *msg->lrbsdstatus_;
}
const ::HmiInterface::FollowCarDis&
Statefusion::_Internal::accdislevel(const Statefusion* msg) {
  return *msg->accdislevel_;
}
const ::HmiInterface::TakeOverEyeWarning&
Statefusion::_Internal::takeovereyewarning(const Statefusion* msg) {
  return *msg->takeovereyewarning_;
}
const ::HmiInterface::ACCIACCNIDStatus&
Statefusion::_Internal::acciaccnidstatus(const Statefusion* msg) {
  return *msg->acciaccnidstatus_;
}
Statefusion::Statefusion(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:HmiInterface.Statefusion)
}
Statefusion::Statefusion(const Statefusion& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_autolightstatus()) {
    autolightstatus_ = new ::HmiInterface::AutoLightStatus(*from.autolightstatus_);
  } else {
    autolightstatus_ = nullptr;
  }
  if (from._internal_has_gatewaystatus()) {
    gatewaystatus_ = new ::HmiInterface::Gatewaystatus(*from.gatewaystatus_);
  } else {
    gatewaystatus_ = nullptr;
  }
  if (from._internal_has_sensorstatus()) {
    sensorstatus_ = new ::HmiInterface::SensorStatus(*from.sensorstatus_);
  } else {
    sensorstatus_ = nullptr;
  }
  if (from._internal_has_lrbsdstatus()) {
    lrbsdstatus_ = new ::HmiInterface::LeftBSDStatus(*from.lrbsdstatus_);
  } else {
    lrbsdstatus_ = nullptr;
  }
  if (from._internal_has_accdislevel()) {
    accdislevel_ = new ::HmiInterface::FollowCarDis(*from.accdislevel_);
  } else {
    accdislevel_ = nullptr;
  }
  if (from._internal_has_takeovereyewarning()) {
    takeovereyewarning_ = new ::HmiInterface::TakeOverEyeWarning(*from.takeovereyewarning_);
  } else {
    takeovereyewarning_ = nullptr;
  }
  if (from._internal_has_acciaccnidstatus()) {
    acciaccnidstatus_ = new ::HmiInterface::ACCIACCNIDStatus(*from.acciaccnidstatus_);
  } else {
    acciaccnidstatus_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:HmiInterface.Statefusion)
}

inline void Statefusion::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&autolightstatus_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&acciaccnidstatus_) -
    reinterpret_cast<char*>(&autolightstatus_)) + sizeof(acciaccnidstatus_));
}

Statefusion::~Statefusion() {
  // @@protoc_insertion_point(destructor:HmiInterface.Statefusion)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void Statefusion::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete autolightstatus_;
  if (this != internal_default_instance()) delete gatewaystatus_;
  if (this != internal_default_instance()) delete sensorstatus_;
  if (this != internal_default_instance()) delete lrbsdstatus_;
  if (this != internal_default_instance()) delete accdislevel_;
  if (this != internal_default_instance()) delete takeovereyewarning_;
  if (this != internal_default_instance()) delete acciaccnidstatus_;
}

void Statefusion::ArenaDtor(void* object) {
  Statefusion* _this = reinterpret_cast< Statefusion* >(object);
  (void)_this;
}
void Statefusion::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Statefusion::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Statefusion::Clear() {
// @@protoc_insertion_point(message_clear_start:HmiInterface.Statefusion)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && autolightstatus_ != nullptr) {
    delete autolightstatus_;
  }
  autolightstatus_ = nullptr;
  if (GetArenaForAllocation() == nullptr && gatewaystatus_ != nullptr) {
    delete gatewaystatus_;
  }
  gatewaystatus_ = nullptr;
  if (GetArenaForAllocation() == nullptr && sensorstatus_ != nullptr) {
    delete sensorstatus_;
  }
  sensorstatus_ = nullptr;
  if (GetArenaForAllocation() == nullptr && lrbsdstatus_ != nullptr) {
    delete lrbsdstatus_;
  }
  lrbsdstatus_ = nullptr;
  if (GetArenaForAllocation() == nullptr && accdislevel_ != nullptr) {
    delete accdislevel_;
  }
  accdislevel_ = nullptr;
  if (GetArenaForAllocation() == nullptr && takeovereyewarning_ != nullptr) {
    delete takeovereyewarning_;
  }
  takeovereyewarning_ = nullptr;
  if (GetArenaForAllocation() == nullptr && acciaccnidstatus_ != nullptr) {
    delete acciaccnidstatus_;
  }
  acciaccnidstatus_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Statefusion::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .HmiInterface.AutoLightStatus autolightstatus = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_autolightstatus(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .HmiInterface.Gatewaystatus gatewaystatus = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_gatewaystatus(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .HmiInterface.SensorStatus sensorstatus = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_sensorstatus(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .HmiInterface.LeftBSDStatus lrbsdstatus = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_lrbsdstatus(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .HmiInterface.FollowCarDis accdislevel = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_accdislevel(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .HmiInterface.TakeOverEyeWarning takeovereyewarning = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_takeovereyewarning(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .HmiInterface.ACCIACCNIDStatus acciaccnidstatus = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_acciaccnidstatus(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Statefusion::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:HmiInterface.Statefusion)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .HmiInterface.AutoLightStatus autolightstatus = 1;
  if (this->_internal_has_autolightstatus()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::autolightstatus(this), target, stream);
  }

  // .HmiInterface.Gatewaystatus gatewaystatus = 2;
  if (this->_internal_has_gatewaystatus()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::gatewaystatus(this), target, stream);
  }

  // .HmiInterface.SensorStatus sensorstatus = 3;
  if (this->_internal_has_sensorstatus()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::sensorstatus(this), target, stream);
  }

  // .HmiInterface.LeftBSDStatus lrbsdstatus = 4;
  if (this->_internal_has_lrbsdstatus()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::lrbsdstatus(this), target, stream);
  }

  // .HmiInterface.FollowCarDis accdislevel = 5;
  if (this->_internal_has_accdislevel()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        5, _Internal::accdislevel(this), target, stream);
  }

  // .HmiInterface.TakeOverEyeWarning takeovereyewarning = 6;
  if (this->_internal_has_takeovereyewarning()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        6, _Internal::takeovereyewarning(this), target, stream);
  }

  // .HmiInterface.ACCIACCNIDStatus acciaccnidstatus = 7;
  if (this->_internal_has_acciaccnidstatus()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        7, _Internal::acciaccnidstatus(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:HmiInterface.Statefusion)
  return target;
}

size_t Statefusion::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:HmiInterface.Statefusion)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .HmiInterface.AutoLightStatus autolightstatus = 1;
  if (this->_internal_has_autolightstatus()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *autolightstatus_);
  }

  // .HmiInterface.Gatewaystatus gatewaystatus = 2;
  if (this->_internal_has_gatewaystatus()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *gatewaystatus_);
  }

  // .HmiInterface.SensorStatus sensorstatus = 3;
  if (this->_internal_has_sensorstatus()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *sensorstatus_);
  }

  // .HmiInterface.LeftBSDStatus lrbsdstatus = 4;
  if (this->_internal_has_lrbsdstatus()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *lrbsdstatus_);
  }

  // .HmiInterface.FollowCarDis accdislevel = 5;
  if (this->_internal_has_accdislevel()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *accdislevel_);
  }

  // .HmiInterface.TakeOverEyeWarning takeovereyewarning = 6;
  if (this->_internal_has_takeovereyewarning()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *takeovereyewarning_);
  }

  // .HmiInterface.ACCIACCNIDStatus acciaccnidstatus = 7;
  if (this->_internal_has_acciaccnidstatus()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *acciaccnidstatus_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Statefusion::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    Statefusion::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Statefusion::GetClassData() const { return &_class_data_; }

void Statefusion::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<Statefusion *>(to)->MergeFrom(
      static_cast<const Statefusion &>(from));
}


void Statefusion::MergeFrom(const Statefusion& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:HmiInterface.Statefusion)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_autolightstatus()) {
    _internal_mutable_autolightstatus()->::HmiInterface::AutoLightStatus::MergeFrom(from._internal_autolightstatus());
  }
  if (from._internal_has_gatewaystatus()) {
    _internal_mutable_gatewaystatus()->::HmiInterface::Gatewaystatus::MergeFrom(from._internal_gatewaystatus());
  }
  if (from._internal_has_sensorstatus()) {
    _internal_mutable_sensorstatus()->::HmiInterface::SensorStatus::MergeFrom(from._internal_sensorstatus());
  }
  if (from._internal_has_lrbsdstatus()) {
    _internal_mutable_lrbsdstatus()->::HmiInterface::LeftBSDStatus::MergeFrom(from._internal_lrbsdstatus());
  }
  if (from._internal_has_accdislevel()) {
    _internal_mutable_accdislevel()->::HmiInterface::FollowCarDis::MergeFrom(from._internal_accdislevel());
  }
  if (from._internal_has_takeovereyewarning()) {
    _internal_mutable_takeovereyewarning()->::HmiInterface::TakeOverEyeWarning::MergeFrom(from._internal_takeovereyewarning());
  }
  if (from._internal_has_acciaccnidstatus()) {
    _internal_mutable_acciaccnidstatus()->::HmiInterface::ACCIACCNIDStatus::MergeFrom(from._internal_acciaccnidstatus());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Statefusion::CopyFrom(const Statefusion& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:HmiInterface.Statefusion)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Statefusion::IsInitialized() const {
  return true;
}

void Statefusion::InternalSwap(Statefusion* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Statefusion, acciaccnidstatus_)
      + sizeof(Statefusion::acciaccnidstatus_)
      - PROTOBUF_FIELD_OFFSET(Statefusion, autolightstatus_)>(
          reinterpret_cast<char*>(&autolightstatus_),
          reinterpret_cast<char*>(&other->autolightstatus_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Statefusion::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_hmi_5fbasic_5fstatefusion_2eproto_getter, &descriptor_table_hmi_5fbasic_5fstatefusion_2eproto_once,
      file_level_metadata_hmi_5fbasic_5fstatefusion_2eproto[7]);
}

// ===================================================================

class BasicStateFusion::_Internal {
 public:
  static const ::HmiInterface::Statefusion& status_fusion(const BasicStateFusion* msg);
};

const ::HmiInterface::Statefusion&
BasicStateFusion::_Internal::status_fusion(const BasicStateFusion* msg) {
  return *msg->status_fusion_;
}
BasicStateFusion::BasicStateFusion(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:HmiInterface.BasicStateFusion)
}
BasicStateFusion::BasicStateFusion(const BasicStateFusion& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_status_fusion()) {
    status_fusion_ = new ::HmiInterface::Statefusion(*from.status_fusion_);
  } else {
    status_fusion_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:HmiInterface.BasicStateFusion)
}

inline void BasicStateFusion::SharedCtor() {
status_fusion_ = nullptr;
}

BasicStateFusion::~BasicStateFusion() {
  // @@protoc_insertion_point(destructor:HmiInterface.BasicStateFusion)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void BasicStateFusion::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete status_fusion_;
}

void BasicStateFusion::ArenaDtor(void* object) {
  BasicStateFusion* _this = reinterpret_cast< BasicStateFusion* >(object);
  (void)_this;
}
void BasicStateFusion::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void BasicStateFusion::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void BasicStateFusion::Clear() {
// @@protoc_insertion_point(message_clear_start:HmiInterface.BasicStateFusion)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && status_fusion_ != nullptr) {
    delete status_fusion_;
  }
  status_fusion_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BasicStateFusion::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .HmiInterface.Statefusion status_fusion = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_status_fusion(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BasicStateFusion::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:HmiInterface.BasicStateFusion)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .HmiInterface.Statefusion status_fusion = 1;
  if (this->_internal_has_status_fusion()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::status_fusion(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:HmiInterface.BasicStateFusion)
  return target;
}

size_t BasicStateFusion::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:HmiInterface.BasicStateFusion)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .HmiInterface.Statefusion status_fusion = 1;
  if (this->_internal_has_status_fusion()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *status_fusion_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BasicStateFusion::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    BasicStateFusion::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BasicStateFusion::GetClassData() const { return &_class_data_; }

void BasicStateFusion::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<BasicStateFusion *>(to)->MergeFrom(
      static_cast<const BasicStateFusion &>(from));
}


void BasicStateFusion::MergeFrom(const BasicStateFusion& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:HmiInterface.BasicStateFusion)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_status_fusion()) {
    _internal_mutable_status_fusion()->::HmiInterface::Statefusion::MergeFrom(from._internal_status_fusion());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void BasicStateFusion::CopyFrom(const BasicStateFusion& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:HmiInterface.BasicStateFusion)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BasicStateFusion::IsInitialized() const {
  return true;
}

void BasicStateFusion::InternalSwap(BasicStateFusion* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(status_fusion_, other->status_fusion_);
}

::PROTOBUF_NAMESPACE_ID::Metadata BasicStateFusion::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_hmi_5fbasic_5fstatefusion_2eproto_getter, &descriptor_table_hmi_5fbasic_5fstatefusion_2eproto_once,
      file_level_metadata_hmi_5fbasic_5fstatefusion_2eproto[8]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace HmiInterface
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::HmiInterface::ACCIACCNIDStatus* Arena::CreateMaybeMessage< ::HmiInterface::ACCIACCNIDStatus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::HmiInterface::ACCIACCNIDStatus >(arena);
}
template<> PROTOBUF_NOINLINE ::HmiInterface::TakeOverEyeWarning* Arena::CreateMaybeMessage< ::HmiInterface::TakeOverEyeWarning >(Arena* arena) {
  return Arena::CreateMessageInternal< ::HmiInterface::TakeOverEyeWarning >(arena);
}
template<> PROTOBUF_NOINLINE ::HmiInterface::FollowCarDis* Arena::CreateMaybeMessage< ::HmiInterface::FollowCarDis >(Arena* arena) {
  return Arena::CreateMessageInternal< ::HmiInterface::FollowCarDis >(arena);
}
template<> PROTOBUF_NOINLINE ::HmiInterface::LeftBSDStatus* Arena::CreateMaybeMessage< ::HmiInterface::LeftBSDStatus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::HmiInterface::LeftBSDStatus >(arena);
}
template<> PROTOBUF_NOINLINE ::HmiInterface::SensorStatus* Arena::CreateMaybeMessage< ::HmiInterface::SensorStatus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::HmiInterface::SensorStatus >(arena);
}
template<> PROTOBUF_NOINLINE ::HmiInterface::Gatewaystatus* Arena::CreateMaybeMessage< ::HmiInterface::Gatewaystatus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::HmiInterface::Gatewaystatus >(arena);
}
template<> PROTOBUF_NOINLINE ::HmiInterface::AutoLightStatus* Arena::CreateMaybeMessage< ::HmiInterface::AutoLightStatus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::HmiInterface::AutoLightStatus >(arena);
}
template<> PROTOBUF_NOINLINE ::HmiInterface::Statefusion* Arena::CreateMaybeMessage< ::HmiInterface::Statefusion >(Arena* arena) {
  return Arena::CreateMessageInternal< ::HmiInterface::Statefusion >(arena);
}
template<> PROTOBUF_NOINLINE ::HmiInterface::BasicStateFusion* Arena::CreateMaybeMessage< ::HmiInterface::BasicStateFusion >(Arena* arena) {
  return Arena::CreateMessageInternal< ::HmiInterface::BasicStateFusion >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>

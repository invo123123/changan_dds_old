/****************************************************************
  Generated by ChangAn Code Generator,Do Not Modify
  AppVersion： mADC_Application_Service-V1.5
  CmVersion： v2.0.3
  ServiceVersion: V1.2.0
  ServiceLatestModifyTime: 2023-11-21T11:51:51
  Generate Time: 2023-12-11 18:07:59
*****************************************************************/
#include "changan/Basc_ADASCruiseSet_Proxy.hpp"
#include <string.h>
#include "dds/ddsrt/sync.h"
#include <iostream>
#include "changan/string_util.hpp"
#include "changan/dds_client.hpp"
namespace com {
namespace changan {
namespace carDrive {
namespace C2Controller {
namespace proxy {
    using namespace com::changan::rpc_service;
    using namespace com::changan::soa_log::skeleton;
    void Basc_ADASCruiseSet_Ntf_ADASCruiseSet_trigger(carDrive_Basc_ADASCruiseSet_Ntf* notify_data){
	    Basc_ADASCruiseSet_Proxy::get_instance().Ntf_ADASCruiseSet.trigger(notify_data->data._u.Basc_ADASCruiseSet_Ntf_ADASCruiseSet);
		carDrive_Basc_ADASCruiseSet_Ntf_free(notify_data, DDS_FREE_ALL);
    }
    void Basc_ADASCruiseSet_Ntf_C2_IACCFamlrRdModSwtFb_trigger(carDrive_Basc_ADASCruiseSet_Ntf* notify_data){
	    Basc_ADASCruiseSet_Proxy::get_instance().Ntf_C2_IACCFamlrRdModSwtFb.trigger(notify_data->data._u.Basc_ADASCruiseSet_Ntf_C2_IACCFamlrRdModSwtFb);
		carDrive_Basc_ADASCruiseSet_Ntf_free(notify_data, DDS_FREE_ALL);
    }
    void Basc_ADASCruiseSet_Ntf_AD_NIDSelfLrngFb_trigger(carDrive_Basc_ADASCruiseSet_Ntf* notify_data){
	    Basc_ADASCruiseSet_Proxy::get_instance().Ntf_AD_NIDSelfLrngFb.trigger(notify_data->data._u.Basc_ADASCruiseSet_Ntf_AD_NIDSelfLrngFb);
		carDrive_Basc_ADASCruiseSet_Ntf_free(notify_data, DDS_FREE_ALL);
    }
    void Basc_ADASCruiseSet_Ntf_AD_BSDLCAOnOffSet_trigger(carDrive_Basc_ADASCruiseSet_Ntf* notify_data){
	    Basc_ADASCruiseSet_Proxy::get_instance().Ntf_AD_BSDLCAOnOffSet.trigger(notify_data->data._u.Basc_ADASCruiseSet_Ntf_AD_BSDLCAOnOffSet);
		carDrive_Basc_ADASCruiseSet_Ntf_free(notify_data, DDS_FREE_ALL);
    }
    void Basc_ADASCruiseSet_Ntf_AD_SEAOnOffSts_trigger(carDrive_Basc_ADASCruiseSet_Ntf* notify_data){
	    Basc_ADASCruiseSet_Proxy::get_instance().Ntf_AD_SEAOnOffSts.trigger(notify_data->data._u.Basc_ADASCruiseSet_Ntf_AD_SEAOnOffSts);
		carDrive_Basc_ADASCruiseSet_Ntf_free(notify_data, DDS_FREE_ALL);
    }
    void on_Basc_ADASCruiseSet_Ntf_ADASCruiseSet_data_available(int32_t reader, void* arg){
        ASF_LOG_DEBUG_ARGS("on_Basc_ADASCruiseSet_Ntf_ADASCruiseSet_data_available");
    	dds_return_t rc;
		carDrive_Basc_ADASCruiseSet_Ntf* data;
		void* samples[1];
		samples[0] = carDrive_Basc_ADASCruiseSet_Ntf__alloc();
		dds_sample_info_t infos[1];
		rc = dds_take_next(reader, samples, infos);
		if (rc < 0){
			ASF_LOG_ERROR_ARGS("on_Basc_ADASCruiseSet_Ntf_ADASCruiseSet_data_available dds_take_next faild rc=[%d]", rc);
			//printf("dds_take_next failed!\n");
        }
		if (infos[0].valid_data){
            data = (carDrive_Basc_ADASCruiseSet_Ntf*)samples[0];
            ASF_LOG_DEBUG_ARGS("on_Basc_ADASCruiseSet_Ntf_ADASCruiseSet_data_available, hashId=[%d]", data->data._d);
			DDSClient::execute(Basc_ADASCruiseSet_Ntf_ADASCruiseSet_trigger,data);
			return;
		}
		carDrive_Basc_ADASCruiseSet_Ntf_free(samples[0],DDS_FREE_ALL);
	}
    void on_Basc_ADASCruiseSet_Ntf_C2_IACCFamlrRdModSwtFb_data_available(int32_t reader, void* arg){
        ASF_LOG_DEBUG_ARGS("on_Basc_ADASCruiseSet_Ntf_C2_IACCFamlrRdModSwtFb_data_available");
    	dds_return_t rc;
		carDrive_Basc_ADASCruiseSet_Ntf* data;
		void* samples[1];
		samples[0] = carDrive_Basc_ADASCruiseSet_Ntf__alloc();
		dds_sample_info_t infos[1];
		rc = dds_take_next(reader, samples, infos);
		if (rc < 0){
			ASF_LOG_ERROR_ARGS("on_Basc_ADASCruiseSet_Ntf_C2_IACCFamlrRdModSwtFb_data_available dds_take_next faild rc=[%d]", rc);
			//printf("dds_take_next failed!\n");
        }
		if (infos[0].valid_data){
            data = (carDrive_Basc_ADASCruiseSet_Ntf*)samples[0];
            ASF_LOG_DEBUG_ARGS("on_Basc_ADASCruiseSet_Ntf_C2_IACCFamlrRdModSwtFb_data_available, hashId=[%d]", data->data._d);
			DDSClient::execute(Basc_ADASCruiseSet_Ntf_C2_IACCFamlrRdModSwtFb_trigger,data);
			return;
		}
		carDrive_Basc_ADASCruiseSet_Ntf_free(samples[0],DDS_FREE_ALL);
	}
    void on_Basc_ADASCruiseSet_Ntf_AD_NIDSelfLrngFb_data_available(int32_t reader, void* arg){
        ASF_LOG_DEBUG_ARGS("on_Basc_ADASCruiseSet_Ntf_AD_NIDSelfLrngFb_data_available");
    	dds_return_t rc;
		carDrive_Basc_ADASCruiseSet_Ntf* data;
		void* samples[1];
		samples[0] = carDrive_Basc_ADASCruiseSet_Ntf__alloc();
		dds_sample_info_t infos[1];
		rc = dds_take_next(reader, samples, infos);
		if (rc < 0){
			ASF_LOG_ERROR_ARGS("on_Basc_ADASCruiseSet_Ntf_AD_NIDSelfLrngFb_data_available dds_take_next faild rc=[%d]", rc);
			//printf("dds_take_next failed!\n");
        }
		if (infos[0].valid_data){
            data = (carDrive_Basc_ADASCruiseSet_Ntf*)samples[0];
            ASF_LOG_DEBUG_ARGS("on_Basc_ADASCruiseSet_Ntf_AD_NIDSelfLrngFb_data_available, hashId=[%d]", data->data._d);
			DDSClient::execute(Basc_ADASCruiseSet_Ntf_AD_NIDSelfLrngFb_trigger,data);
			return;
		}
		carDrive_Basc_ADASCruiseSet_Ntf_free(samples[0],DDS_FREE_ALL);
	}
    void on_Basc_ADASCruiseSet_Ntf_AD_BSDLCAOnOffSet_data_available(int32_t reader, void* arg){
        ASF_LOG_DEBUG_ARGS("on_Basc_ADASCruiseSet_Ntf_AD_BSDLCAOnOffSet_data_available");
    	dds_return_t rc;
		carDrive_Basc_ADASCruiseSet_Ntf* data;
		void* samples[1];
		samples[0] = carDrive_Basc_ADASCruiseSet_Ntf__alloc();
		dds_sample_info_t infos[1];
		rc = dds_take_next(reader, samples, infos);
		if (rc < 0){
			ASF_LOG_ERROR_ARGS("on_Basc_ADASCruiseSet_Ntf_AD_BSDLCAOnOffSet_data_available dds_take_next faild rc=[%d]", rc);
			//printf("dds_take_next failed!\n");
        }
		if (infos[0].valid_data){
            data = (carDrive_Basc_ADASCruiseSet_Ntf*)samples[0];
            ASF_LOG_DEBUG_ARGS("on_Basc_ADASCruiseSet_Ntf_AD_BSDLCAOnOffSet_data_available, hashId=[%d]", data->data._d);
			DDSClient::execute(Basc_ADASCruiseSet_Ntf_AD_BSDLCAOnOffSet_trigger,data);
			return;
		}
		carDrive_Basc_ADASCruiseSet_Ntf_free(samples[0],DDS_FREE_ALL);
	}
    void on_Basc_ADASCruiseSet_Ntf_AD_SEAOnOffSts_data_available(int32_t reader, void* arg){
        ASF_LOG_DEBUG_ARGS("on_Basc_ADASCruiseSet_Ntf_AD_SEAOnOffSts_data_available");
    	dds_return_t rc;
		carDrive_Basc_ADASCruiseSet_Ntf* data;
		void* samples[1];
		samples[0] = carDrive_Basc_ADASCruiseSet_Ntf__alloc();
		dds_sample_info_t infos[1];
		rc = dds_take_next(reader, samples, infos);
		if (rc < 0){
			ASF_LOG_ERROR_ARGS("on_Basc_ADASCruiseSet_Ntf_AD_SEAOnOffSts_data_available dds_take_next faild rc=[%d]", rc);
			//printf("dds_take_next failed!\n");
        }
		if (infos[0].valid_data){
            data = (carDrive_Basc_ADASCruiseSet_Ntf*)samples[0];
            ASF_LOG_DEBUG_ARGS("on_Basc_ADASCruiseSet_Ntf_AD_SEAOnOffSts_data_available, hashId=[%d]", data->data._d);
			DDSClient::execute(Basc_ADASCruiseSet_Ntf_AD_SEAOnOffSts_trigger,data);
			return;
		}
		carDrive_Basc_ADASCruiseSet_Ntf_free(samples[0],DDS_FREE_ALL);
	}
	void on_carDrive_Basc_ADASCruiseSet_reply_data_available(int32_t reader, void* arg) {
		ASF_LOG_DEBUG_ARGS("on_carDrive_Basc_ADASCruiseSet_reply_data_available");
		dds_return_t rc;
		carDrive_Basc_ADASCruiseSet_Reply* reply;
		void* samples[MAX_SAMPLES];
		dds_sample_info_t infos[MAX_SAMPLES];
		samples[0] = carDrive_Basc_ADASCruiseSet_Reply__alloc();
		rc = dds_take_next(reader, samples, infos);
		if (rc < 0) {
			ASF_LOG_ERROR_ARGS("on_carDrive_Basc_ADASCruiseSet_reply_data_available dds_take_next faild rc=[%d]", rc);
			//printf("dds_take_next failed!\n");
		}
		if (infos[0].valid_data) {
			reply = (carDrive_Basc_ADASCruiseSet_Reply*)samples[0];
			auto sp = std::shared_ptr<void>{
				samples[0],
				[](void* ptr) {
					carDrive_Basc_ADASCruiseSet_Reply_free(ptr,DDS_FREE_ALL);
				}
			};
			int32_t funID = reply->data._d;
			ASF_LOG_DEBUG_ARGS("on_carDrive_Basc_ADASCruiseSet_reply_data_available, hashId=[%d], reqId=[%d]", funID, reply->header.relatedRequestId.sequence_number.low);
			switch (funID) {
				case carDrive_Basc_ADASCruiseSet_Get_ADASCruiseSet_Hash:
				case carDrive_Basc_ADASCruiseSet_RR_HU_CuriseMode_Hash:
				case carDrive_Basc_ADASCruiseSet_RR_HU_IDAEnable_Hash:
				case carDrive_Basc_ADASCruiseSet_RR_HU_LaneChangeFrequency_Hash:
				case carDrive_Basc_ADASCruiseSet_RR_HU_UDLCEnable_Hash:
				case carDrive_Basc_ADASCruiseSet_RR_HU_NIDAudioWarStyle_Hash:
				case carDrive_Basc_ADASCruiseSet_RR_HU_CSLAEnable_Hash:
				case carDrive_Basc_ADASCruiseSet_RR_HU_CSLmode_Hash:
				case carDrive_Basc_ADASCruiseSet_RR_HU_OverspeedSoundWarEnable_Hash:
				case carDrive_Basc_ADASCruiseSet_RR_HU_CSLWarnOffsetTp_Hash:
				case carDrive_Basc_ADASCruiseSet_RR_HU_AbsOverSpdWarnOffset_Hash:
				case carDrive_Basc_ADASCruiseSet_RR_HU_RelOverSpdWarnOffset_Hash:
				case carDrive_Basc_ADASCruiseSet_RR_HU_AutoDriveStyle_Hash:
				case carDrive_Basc_ADASCruiseSet_RR_HU_ADACCStyle_Hash:
				case carDrive_Basc_ADASCruiseSet_RR_HU_ADStartStyle_Hash:
				case carDrive_Basc_ADASCruiseSet_RR_HU_ADCurveStyle_Hash:
				case carDrive_Basc_ADASCruiseSet_RR_HU_ADLanechangeStyle_Hash:
				case carDrive_Basc_ADASCruiseSet_RR_HU_VehicleStartRemindEnable_Hash:
				case carDrive_Basc_ADASCruiseSet_RR_HU_RCWEnable_Hash:
				case carDrive_Basc_ADASCruiseSet_RR_HU_SEAMode_Hash:
				case carDrive_Basc_ADASCruiseSet_RR_HU_BSDLCASetting_Hash:
				case carDrive_Basc_ADASCruiseSet_RR_HU_BSDLCARemindmode_Hash:
				case carDrive_Basc_ADASCruiseSet_RR_HU_IACCFamlrRdModSwt_Hash:
				case carDrive_Basc_ADASCruiseSet_Get_C2_IACCFamlrRdModSwtFb_Hash:
				case carDrive_Basc_ADASCruiseSet_Get_AD_NIDSelfLrngFb_Hash:
				case carDrive_Basc_ADASCruiseSet_RR_EDC_NIDSelfLrngReq_Hash:
				case carDrive_Basc_ADASCruiseSet_Get_AD_BSDLCAOnOffSet_Hash:
				case carDrive_Basc_ADASCruiseSet_RR_HU_BSDLCAOnOff_Hash:
				case carDrive_Basc_ADASCruiseSet_Get_AD_SEAOnOffSts_Hash:
				case carDrive_Basc_ADASCruiseSet_RR_HU_SEAOnOff_Hash:
				{
					uint64_t key = reply->header.relatedRequestId.sequence_number.low;
					com::changan::rpc_service::DDSClient::release(key, sp);
					break;
				}
				default:
				{
					uint64_t key = reply->header.relatedRequestId.sequence_number.low;
					com::changan::rpc_service::DDSClient::release(key, sp);
					break;
				}
			}
		}
	}

	Basc_ADASCruiseSet_Proxy::Basc_ADASCruiseSet_Proxy(){

    }

    void on_Basc_ADASCruiseSet_request_publication_matched_cb(dds_entity_t writer, const dds_publication_matched_status_t  status, void* arg) {
		ASF_LOG_DEBUG_ARGS("on_Basc_ADASCruiseSet_request_publication_matched_cb, writer=[%d], current_count=[%d]", writer, status.current_count);
		Basc_ADASCruiseSet_Proxy *pTmp = &Basc_ADASCruiseSet_Proxy::get_instance();
		auto handler=Basc_ADASCruiseSet_Proxy::get_instance().get_provider_matched_handler();
		if(NULL!=handler){
			ProviderMatchedStatus data=DDSUtil::get_provider_matched_status(writer,status);
			if(data.is_online == true)
            {
                pTmp->add_link_count();
            }
			else
            {
                pTmp->subtract_link_count();
            }
            if(pTmp->get_link_count() < 2)
            {
               data.is_online = false;
            }
            handler(data);
		}
	}
	
	void on_Basc_ADASCruiseSet_reply_sublication_matched_cb(dds_entity_t reader, const dds_subscription_matched_status_t  status, void* arg) {
		ASF_LOG_DEBUG_ARGS("on_Basc_ADASCruiseSet_reply_sublication_matched_cb, reader=[%d], current_count=[%d]", reader, status.current_count);
		Basc_ADASCruiseSet_Proxy *pTmp = &Basc_ADASCruiseSet_Proxy::get_instance();
        auto handler = pTmp->get_provider_matched_handler();
        if(NULL!=handler){
            ConsumerMatchedStatus ConsumerData=DDSUtil::get_consumer_matched_status(reader,status);
            ProviderMatchedStatus ProviderData;
			ProviderData.is_online = false;
            if(ConsumerData.is_online == true)
            {
                pTmp->add_link_count();
            }
            else
            {
                pTmp->subtract_link_count();
            }
            
            if(pTmp->get_link_count() == 2)
            {
                ProviderData.is_online = true;
            }
            handler(ProviderData);
        }
    }


	void Basc_ADASCruiseSet_Proxy::wait_server_online()
	{
		this->wait_for_sub_online(dds_rpc_reply_handle.reader);
	}

	bool Basc_ADASCruiseSet_Proxy::init(std::string config) {
	    std::lock_guard<std::mutex> guard(init_mutex);
	    if(this->init_flag){
	        return true;
	    }
		logconfig_Skeleton::get_instance().init(config);
		DDSUtil::event_sub_init(DDS_DOMAIN_ID,
			this->get_service_name()+"_"+this->Ntf_ADASCruiseSet.get_name(),
		    &carDrive_Basc_ADASCruiseSet_Ntf_desc,
			&on_Basc_ADASCruiseSet_Ntf_ADASCruiseSet_data_available,
			NULL,
			&dds_Ntf_ADASCruiseSet_handle,
			NULL,{PROXY_TOKEN, PROXY_TOKEN, ""},{},config);
		DDSUtil::event_sub_init(DDS_DOMAIN_ID,
			this->get_service_name()+"_"+this->Ntf_C2_IACCFamlrRdModSwtFb.get_name(),
		    &carDrive_Basc_ADASCruiseSet_Ntf_desc,
			&on_Basc_ADASCruiseSet_Ntf_C2_IACCFamlrRdModSwtFb_data_available,
			NULL,
			&dds_Ntf_C2_IACCFamlrRdModSwtFb_handle,
			NULL,{PROXY_TOKEN, PROXY_TOKEN, ""},{},config);
		DDSUtil::event_sub_init(DDS_DOMAIN_ID,
			this->get_service_name()+"_"+this->Ntf_AD_NIDSelfLrngFb.get_name(),
		    &carDrive_Basc_ADASCruiseSet_Ntf_desc,
			&on_Basc_ADASCruiseSet_Ntf_AD_NIDSelfLrngFb_data_available,
			NULL,
			&dds_Ntf_AD_NIDSelfLrngFb_handle,
			NULL,{PROXY_TOKEN, PROXY_TOKEN, ""},{},config);
		DDSUtil::event_sub_init(DDS_DOMAIN_ID,
			this->get_service_name()+"_"+this->Ntf_AD_BSDLCAOnOffSet.get_name(),
		    &carDrive_Basc_ADASCruiseSet_Ntf_desc,
			&on_Basc_ADASCruiseSet_Ntf_AD_BSDLCAOnOffSet_data_available,
			NULL,
			&dds_Ntf_AD_BSDLCAOnOffSet_handle,
			NULL,{PROXY_TOKEN, PROXY_TOKEN, ""},{},config);
		DDSUtil::event_sub_init(DDS_DOMAIN_ID,
			this->get_service_name()+"_"+this->Ntf_AD_SEAOnOffSts.get_name(),
		    &carDrive_Basc_ADASCruiseSet_Ntf_desc,
			&on_Basc_ADASCruiseSet_Ntf_AD_SEAOnOffSts_data_available,
			NULL,
			&dds_Ntf_AD_SEAOnOffSts_handle,
			NULL,{PROXY_TOKEN, PROXY_TOKEN, ""},{},config);
		DDSUtil::event_sub_init(DDS_DOMAIN_ID,
			this->service_name + "_reply",
			&carDrive_Basc_ADASCruiseSet_Reply_desc,
			&on_carDrive_Basc_ADASCruiseSet_reply_data_available,
			NULL,
			&dds_rpc_reply_handle,
			&on_Basc_ADASCruiseSet_reply_sublication_matched_cb,{PROXY_TOKEN, PROXY_TOKEN, ""},{},config
		);
		DDSUtil::event_pub_init(DDS_DOMAIN_ID,
			this->service_name + "_request",
			&carDrive_Basc_ADASCruiseSet_Request_desc,
			&dds_rpc_request_handle,
            &on_Basc_ADASCruiseSet_request_publication_matched_cb,{PROXY_TOKEN, PROXY_TOKEN, ""},config
		);

		this->init_flag = true;
		return true;
	}

	bool Basc_ADASCruiseSet_Proxy::destroy() {
		ASF_LOG_DEBUG_ARGS("Basc_ADASCruiseSet_Proxy::destroy");
		std::lock_guard<std::mutex> guard(init_mutex);
	    if (!this->init_flag) {
			return true;
		}
		if (!DDSUtil::dds_client_destroy(&dds_Ntf_ADASCruiseSet_handle)) {
			return false;
		}
		if (!DDSUtil::dds_client_destroy(&dds_Ntf_C2_IACCFamlrRdModSwtFb_handle)) {
			return false;
		}
		if (!DDSUtil::dds_client_destroy(&dds_Ntf_AD_NIDSelfLrngFb_handle)) {
			return false;
		}
		if (!DDSUtil::dds_client_destroy(&dds_Ntf_AD_BSDLCAOnOffSet_handle)) {
			return false;
		}
		if (!DDSUtil::dds_client_destroy(&dds_Ntf_AD_SEAOnOffSts_handle)) {
			return false;
		}
		if (!DDSUtil::dds_client_destroy(&dds_rpc_reply_handle)) {
			return false;
		}
		if (!DDSUtil::dds_client_destroy(&dds_rpc_request_handle)) {
			return false;
		}
		this->init_flag = false;
		return true;
	}

	Msg<ADASCruiseSet> Basc_ADASCruiseSet_Proxy::Get_ADASCruiseSet( size_t dds_rpc_time_out) {
		Msg<ADASCruiseSet> _rpc_result;
		carDrive_Basc_ADASCruiseSet_Request* _rpc_request = carDrive_Basc_ADASCruiseSet_Request__alloc();

		dds_guid_t _temp_guid = { 0 };
		dds_return_t rc = dds_get_guid(dds_rpc_request_handle.writer, &_temp_guid);
		if (DDS_RETCODE_OK != rc)
		{
			ASF_LOG_ERROR_ARGS("Basc_ADASCruiseSet_Proxy::Get_ADASCruiseSet dds_get_guid faild rc=[%d], writer=[%d]", rc, dds_rpc_request_handle.writer);
			_rpc_result.code = DDS_RPC_REMOTE_EX_UNSUPPORTED;
			return _rpc_result;
		}

		memcpy(&_rpc_request->header.requestId, &_temp_guid, sizeof(dds_guid_t));
		DDS_SequenceNumber_t _rpc_client_sn = com::changan::rpc_service::DDSClient::get_rpc_request_id();
		_rpc_request->header.requestId.sequence_number = _rpc_client_sn;

		_rpc_request->data._d = carDrive_Basc_ADASCruiseSet_Get_ADASCruiseSet_Hash;
		ASF_LOG_DEBUG_ARGS("Basc_ADASCruiseSet_Proxy::Get_ADASCruiseSet pre async_call, hashId=[%d], reqId=[%d]", carDrive_Basc_ADASCruiseSet_Get_ADASCruiseSet_Hash, _rpc_client_sn.low);
		auto _rpc_future = com::changan::rpc_service::DDSClient::async_call(_rpc_client_sn.low, dds_rpc_request_handle.writer, _rpc_request);
		carDrive_Basc_ADASCruiseSet_Request_free(_rpc_request, DDS_FREE_ALL);

		auto _rpc_status = _rpc_future.wait_for(std::chrono::milliseconds(dds_rpc_time_out));
		if (_rpc_status == std::future_status::timeout ||
			_rpc_status == std::future_status::deferred) {
			_rpc_result.code = DDS_RPC_REMOTE_TIMEOUT_EXCEPTION;
			return _rpc_result;
		}
		auto sp =_rpc_future.get();
		auto _rpc_ret = (carDrive_Basc_ADASCruiseSet_Reply*)sp.get();

		_rpc_result.code = _rpc_ret->header.remoteEx;
		if (_rpc_result.code == DDS_RPC_REMOTE_EX_OK) {
			_rpc_result.data = _rpc_ret->data._u.Get_ADASCruiseSet.return_;
			_rpc_result.autoFreePtr = sp;
		}
		return _rpc_result;
	}
	Msg<ResponseInfo> Basc_ADASCruiseSet_Proxy::RR_HU_CuriseMode(const HUset_CuriseMode &HUset_CuriseMode_,const RequestInfo &Requestinfo, size_t dds_rpc_time_out) {
		Msg<ResponseInfo> _rpc_result;
		carDrive_Basc_ADASCruiseSet_Request* _rpc_request = carDrive_Basc_ADASCruiseSet_Request__alloc();

		dds_guid_t _temp_guid = { 0 };
		dds_return_t rc = dds_get_guid(dds_rpc_request_handle.writer, &_temp_guid);
		if (DDS_RETCODE_OK != rc)
		{
			ASF_LOG_ERROR_ARGS("Basc_ADASCruiseSet_Proxy::RR_HU_CuriseMode dds_get_guid faild rc=[%d], writer=[%d]", rc, dds_rpc_request_handle.writer);
			_rpc_result.code = DDS_RPC_REMOTE_EX_UNSUPPORTED;
			return _rpc_result;
		}

		memcpy(&_rpc_request->header.requestId, &_temp_guid, sizeof(dds_guid_t));
		DDS_SequenceNumber_t _rpc_client_sn = com::changan::rpc_service::DDSClient::get_rpc_request_id();
		_rpc_request->header.requestId.sequence_number = _rpc_client_sn;
		_rpc_request->data._u.RR_HU_CuriseMode.HUset_CuriseMode = HUset_CuriseMode_;
		_rpc_request->data._u.RR_HU_CuriseMode.Requestinfo = Requestinfo;

		_rpc_request->data._d = carDrive_Basc_ADASCruiseSet_RR_HU_CuriseMode_Hash;
		ASF_LOG_DEBUG_ARGS("Basc_ADASCruiseSet_Proxy::RR_HU_CuriseMode pre async_call, hashId=[%d], reqId=[%d]", carDrive_Basc_ADASCruiseSet_RR_HU_CuriseMode_Hash, _rpc_client_sn.low);
		auto _rpc_future = com::changan::rpc_service::DDSClient::async_call(_rpc_client_sn.low, dds_rpc_request_handle.writer, _rpc_request);
		carDrive_Basc_ADASCruiseSet_Request_free(_rpc_request, DDS_FREE_ALL);

		auto _rpc_status = _rpc_future.wait_for(std::chrono::milliseconds(dds_rpc_time_out));
		if (_rpc_status == std::future_status::timeout ||
			_rpc_status == std::future_status::deferred) {
			_rpc_result.code = DDS_RPC_REMOTE_TIMEOUT_EXCEPTION;
			return _rpc_result;
		}
		auto sp =_rpc_future.get();
		auto _rpc_ret = (carDrive_Basc_ADASCruiseSet_Reply*)sp.get();

		_rpc_result.code = _rpc_ret->header.remoteEx;
		if (_rpc_result.code == DDS_RPC_REMOTE_EX_OK) {
			_rpc_result.data = _rpc_ret->data._u.RR_HU_CuriseMode.return_;
			_rpc_result.autoFreePtr = sp;
		}
		return _rpc_result;
	}
	Msg<ResponseInfo> Basc_ADASCruiseSet_Proxy::RR_HU_IDAEnable(const HUset_IDAEnable &HUset_IDAEnable_,const RequestInfo &Requestinfo, size_t dds_rpc_time_out) {
		Msg<ResponseInfo> _rpc_result;
		carDrive_Basc_ADASCruiseSet_Request* _rpc_request = carDrive_Basc_ADASCruiseSet_Request__alloc();

		dds_guid_t _temp_guid = { 0 };
		dds_return_t rc = dds_get_guid(dds_rpc_request_handle.writer, &_temp_guid);
		if (DDS_RETCODE_OK != rc)
		{
			ASF_LOG_ERROR_ARGS("Basc_ADASCruiseSet_Proxy::RR_HU_IDAEnable dds_get_guid faild rc=[%d], writer=[%d]", rc, dds_rpc_request_handle.writer);
			_rpc_result.code = DDS_RPC_REMOTE_EX_UNSUPPORTED;
			return _rpc_result;
		}

		memcpy(&_rpc_request->header.requestId, &_temp_guid, sizeof(dds_guid_t));
		DDS_SequenceNumber_t _rpc_client_sn = com::changan::rpc_service::DDSClient::get_rpc_request_id();
		_rpc_request->header.requestId.sequence_number = _rpc_client_sn;
		_rpc_request->data._u.RR_HU_IDAEnable.HUset_IDAEnable = HUset_IDAEnable_;
		_rpc_request->data._u.RR_HU_IDAEnable.Requestinfo = Requestinfo;

		_rpc_request->data._d = carDrive_Basc_ADASCruiseSet_RR_HU_IDAEnable_Hash;
		ASF_LOG_DEBUG_ARGS("Basc_ADASCruiseSet_Proxy::RR_HU_IDAEnable pre async_call, hashId=[%d], reqId=[%d]", carDrive_Basc_ADASCruiseSet_RR_HU_IDAEnable_Hash, _rpc_client_sn.low);
		auto _rpc_future = com::changan::rpc_service::DDSClient::async_call(_rpc_client_sn.low, dds_rpc_request_handle.writer, _rpc_request);
		carDrive_Basc_ADASCruiseSet_Request_free(_rpc_request, DDS_FREE_ALL);

		auto _rpc_status = _rpc_future.wait_for(std::chrono::milliseconds(dds_rpc_time_out));
		if (_rpc_status == std::future_status::timeout ||
			_rpc_status == std::future_status::deferred) {
			_rpc_result.code = DDS_RPC_REMOTE_TIMEOUT_EXCEPTION;
			return _rpc_result;
		}
		auto sp =_rpc_future.get();
		auto _rpc_ret = (carDrive_Basc_ADASCruiseSet_Reply*)sp.get();

		_rpc_result.code = _rpc_ret->header.remoteEx;
		if (_rpc_result.code == DDS_RPC_REMOTE_EX_OK) {
			_rpc_result.data = _rpc_ret->data._u.RR_HU_IDAEnable.return_;
			_rpc_result.autoFreePtr = sp;
		}
		return _rpc_result;
	}
	Msg<ResponseInfo> Basc_ADASCruiseSet_Proxy::RR_HU_LaneChangeFrequency(const HUset_LaneChangeFrequency &HUset_LaneChangeFrequency_,const RequestInfo &Requestinfo, size_t dds_rpc_time_out) {
		Msg<ResponseInfo> _rpc_result;
		carDrive_Basc_ADASCruiseSet_Request* _rpc_request = carDrive_Basc_ADASCruiseSet_Request__alloc();

		dds_guid_t _temp_guid = { 0 };
		dds_return_t rc = dds_get_guid(dds_rpc_request_handle.writer, &_temp_guid);
		if (DDS_RETCODE_OK != rc)
		{
			ASF_LOG_ERROR_ARGS("Basc_ADASCruiseSet_Proxy::RR_HU_LaneChangeFrequency dds_get_guid faild rc=[%d], writer=[%d]", rc, dds_rpc_request_handle.writer);
			_rpc_result.code = DDS_RPC_REMOTE_EX_UNSUPPORTED;
			return _rpc_result;
		}

		memcpy(&_rpc_request->header.requestId, &_temp_guid, sizeof(dds_guid_t));
		DDS_SequenceNumber_t _rpc_client_sn = com::changan::rpc_service::DDSClient::get_rpc_request_id();
		_rpc_request->header.requestId.sequence_number = _rpc_client_sn;
		_rpc_request->data._u.RR_HU_LaneChangeFrequency.HUset_LaneChangeFrequency = HUset_LaneChangeFrequency_;
		_rpc_request->data._u.RR_HU_LaneChangeFrequency.Requestinfo = Requestinfo;

		_rpc_request->data._d = carDrive_Basc_ADASCruiseSet_RR_HU_LaneChangeFrequency_Hash;
		ASF_LOG_DEBUG_ARGS("Basc_ADASCruiseSet_Proxy::RR_HU_LaneChangeFrequency pre async_call, hashId=[%d], reqId=[%d]", carDrive_Basc_ADASCruiseSet_RR_HU_LaneChangeFrequency_Hash, _rpc_client_sn.low);
		auto _rpc_future = com::changan::rpc_service::DDSClient::async_call(_rpc_client_sn.low, dds_rpc_request_handle.writer, _rpc_request);
		carDrive_Basc_ADASCruiseSet_Request_free(_rpc_request, DDS_FREE_ALL);

		auto _rpc_status = _rpc_future.wait_for(std::chrono::milliseconds(dds_rpc_time_out));
		if (_rpc_status == std::future_status::timeout ||
			_rpc_status == std::future_status::deferred) {
			_rpc_result.code = DDS_RPC_REMOTE_TIMEOUT_EXCEPTION;
			return _rpc_result;
		}
		auto sp =_rpc_future.get();
		auto _rpc_ret = (carDrive_Basc_ADASCruiseSet_Reply*)sp.get();

		_rpc_result.code = _rpc_ret->header.remoteEx;
		if (_rpc_result.code == DDS_RPC_REMOTE_EX_OK) {
			_rpc_result.data = _rpc_ret->data._u.RR_HU_LaneChangeFrequency.return_;
			_rpc_result.autoFreePtr = sp;
		}
		return _rpc_result;
	}
	Msg<ResponseInfo> Basc_ADASCruiseSet_Proxy::RR_HU_UDLCEnable(const HUset_UDLCEnable &HUset_UDLCEnable_,const RequestInfo &Requestinfo, size_t dds_rpc_time_out) {
		Msg<ResponseInfo> _rpc_result;
		carDrive_Basc_ADASCruiseSet_Request* _rpc_request = carDrive_Basc_ADASCruiseSet_Request__alloc();

		dds_guid_t _temp_guid = { 0 };
		dds_return_t rc = dds_get_guid(dds_rpc_request_handle.writer, &_temp_guid);
		if (DDS_RETCODE_OK != rc)
		{
			ASF_LOG_ERROR_ARGS("Basc_ADASCruiseSet_Proxy::RR_HU_UDLCEnable dds_get_guid faild rc=[%d], writer=[%d]", rc, dds_rpc_request_handle.writer);
			_rpc_result.code = DDS_RPC_REMOTE_EX_UNSUPPORTED;
			return _rpc_result;
		}

		memcpy(&_rpc_request->header.requestId, &_temp_guid, sizeof(dds_guid_t));
		DDS_SequenceNumber_t _rpc_client_sn = com::changan::rpc_service::DDSClient::get_rpc_request_id();
		_rpc_request->header.requestId.sequence_number = _rpc_client_sn;
		_rpc_request->data._u.RR_HU_UDLCEnable.HUset_UDLCEnable = HUset_UDLCEnable_;
		_rpc_request->data._u.RR_HU_UDLCEnable.Requestinfo = Requestinfo;

		_rpc_request->data._d = carDrive_Basc_ADASCruiseSet_RR_HU_UDLCEnable_Hash;
		ASF_LOG_DEBUG_ARGS("Basc_ADASCruiseSet_Proxy::RR_HU_UDLCEnable pre async_call, hashId=[%d], reqId=[%d]", carDrive_Basc_ADASCruiseSet_RR_HU_UDLCEnable_Hash, _rpc_client_sn.low);
		auto _rpc_future = com::changan::rpc_service::DDSClient::async_call(_rpc_client_sn.low, dds_rpc_request_handle.writer, _rpc_request);
		carDrive_Basc_ADASCruiseSet_Request_free(_rpc_request, DDS_FREE_ALL);

		auto _rpc_status = _rpc_future.wait_for(std::chrono::milliseconds(dds_rpc_time_out));
		if (_rpc_status == std::future_status::timeout ||
			_rpc_status == std::future_status::deferred) {
			_rpc_result.code = DDS_RPC_REMOTE_TIMEOUT_EXCEPTION;
			return _rpc_result;
		}
		auto sp =_rpc_future.get();
		auto _rpc_ret = (carDrive_Basc_ADASCruiseSet_Reply*)sp.get();

		_rpc_result.code = _rpc_ret->header.remoteEx;
		if (_rpc_result.code == DDS_RPC_REMOTE_EX_OK) {
			_rpc_result.data = _rpc_ret->data._u.RR_HU_UDLCEnable.return_;
			_rpc_result.autoFreePtr = sp;
		}
		return _rpc_result;
	}
	Msg<ResponseInfo> Basc_ADASCruiseSet_Proxy::RR_HU_NIDAudioWarStyle(const HUset_NIDAudioWarStyle &HUset_NIDAudioWarStyle_,const RequestInfo &Requestinfo, size_t dds_rpc_time_out) {
		Msg<ResponseInfo> _rpc_result;
		carDrive_Basc_ADASCruiseSet_Request* _rpc_request = carDrive_Basc_ADASCruiseSet_Request__alloc();

		dds_guid_t _temp_guid = { 0 };
		dds_return_t rc = dds_get_guid(dds_rpc_request_handle.writer, &_temp_guid);
		if (DDS_RETCODE_OK != rc)
		{
			ASF_LOG_ERROR_ARGS("Basc_ADASCruiseSet_Proxy::RR_HU_NIDAudioWarStyle dds_get_guid faild rc=[%d], writer=[%d]", rc, dds_rpc_request_handle.writer);
			_rpc_result.code = DDS_RPC_REMOTE_EX_UNSUPPORTED;
			return _rpc_result;
		}

		memcpy(&_rpc_request->header.requestId, &_temp_guid, sizeof(dds_guid_t));
		DDS_SequenceNumber_t _rpc_client_sn = com::changan::rpc_service::DDSClient::get_rpc_request_id();
		_rpc_request->header.requestId.sequence_number = _rpc_client_sn;
		_rpc_request->data._u.RR_HU_NIDAudioWarStyle.HUset_NIDAudioWarStyle = HUset_NIDAudioWarStyle_;
		_rpc_request->data._u.RR_HU_NIDAudioWarStyle.Requestinfo = Requestinfo;

		_rpc_request->data._d = carDrive_Basc_ADASCruiseSet_RR_HU_NIDAudioWarStyle_Hash;
		ASF_LOG_DEBUG_ARGS("Basc_ADASCruiseSet_Proxy::RR_HU_NIDAudioWarStyle pre async_call, hashId=[%d], reqId=[%d]", carDrive_Basc_ADASCruiseSet_RR_HU_NIDAudioWarStyle_Hash, _rpc_client_sn.low);
		auto _rpc_future = com::changan::rpc_service::DDSClient::async_call(_rpc_client_sn.low, dds_rpc_request_handle.writer, _rpc_request);
		carDrive_Basc_ADASCruiseSet_Request_free(_rpc_request, DDS_FREE_ALL);

		auto _rpc_status = _rpc_future.wait_for(std::chrono::milliseconds(dds_rpc_time_out));
		if (_rpc_status == std::future_status::timeout ||
			_rpc_status == std::future_status::deferred) {
			_rpc_result.code = DDS_RPC_REMOTE_TIMEOUT_EXCEPTION;
			return _rpc_result;
		}
		auto sp =_rpc_future.get();
		auto _rpc_ret = (carDrive_Basc_ADASCruiseSet_Reply*)sp.get();

		_rpc_result.code = _rpc_ret->header.remoteEx;
		if (_rpc_result.code == DDS_RPC_REMOTE_EX_OK) {
			_rpc_result.data = _rpc_ret->data._u.RR_HU_NIDAudioWarStyle.return_;
			_rpc_result.autoFreePtr = sp;
		}
		return _rpc_result;
	}
	Msg<ResponseInfo> Basc_ADASCruiseSet_Proxy::RR_HU_CSLAEnable(const HUset_CSLAEnable &HUset_CSLAEnable_,const RequestInfo &Requestinfo, size_t dds_rpc_time_out) {
		Msg<ResponseInfo> _rpc_result;
		carDrive_Basc_ADASCruiseSet_Request* _rpc_request = carDrive_Basc_ADASCruiseSet_Request__alloc();

		dds_guid_t _temp_guid = { 0 };
		dds_return_t rc = dds_get_guid(dds_rpc_request_handle.writer, &_temp_guid);
		if (DDS_RETCODE_OK != rc)
		{
			ASF_LOG_ERROR_ARGS("Basc_ADASCruiseSet_Proxy::RR_HU_CSLAEnable dds_get_guid faild rc=[%d], writer=[%d]", rc, dds_rpc_request_handle.writer);
			_rpc_result.code = DDS_RPC_REMOTE_EX_UNSUPPORTED;
			return _rpc_result;
		}

		memcpy(&_rpc_request->header.requestId, &_temp_guid, sizeof(dds_guid_t));
		DDS_SequenceNumber_t _rpc_client_sn = com::changan::rpc_service::DDSClient::get_rpc_request_id();
		_rpc_request->header.requestId.sequence_number = _rpc_client_sn;
		_rpc_request->data._u.RR_HU_CSLAEnable.HUset_CSLAEnable = HUset_CSLAEnable_;
		_rpc_request->data._u.RR_HU_CSLAEnable.Requestinfo = Requestinfo;

		_rpc_request->data._d = carDrive_Basc_ADASCruiseSet_RR_HU_CSLAEnable_Hash;
		ASF_LOG_DEBUG_ARGS("Basc_ADASCruiseSet_Proxy::RR_HU_CSLAEnable pre async_call, hashId=[%d], reqId=[%d]", carDrive_Basc_ADASCruiseSet_RR_HU_CSLAEnable_Hash, _rpc_client_sn.low);
		auto _rpc_future = com::changan::rpc_service::DDSClient::async_call(_rpc_client_sn.low, dds_rpc_request_handle.writer, _rpc_request);
		carDrive_Basc_ADASCruiseSet_Request_free(_rpc_request, DDS_FREE_ALL);

		auto _rpc_status = _rpc_future.wait_for(std::chrono::milliseconds(dds_rpc_time_out));
		if (_rpc_status == std::future_status::timeout ||
			_rpc_status == std::future_status::deferred) {
			_rpc_result.code = DDS_RPC_REMOTE_TIMEOUT_EXCEPTION;
			return _rpc_result;
		}
		auto sp =_rpc_future.get();
		auto _rpc_ret = (carDrive_Basc_ADASCruiseSet_Reply*)sp.get();

		_rpc_result.code = _rpc_ret->header.remoteEx;
		if (_rpc_result.code == DDS_RPC_REMOTE_EX_OK) {
			_rpc_result.data = _rpc_ret->data._u.RR_HU_CSLAEnable.return_;
			_rpc_result.autoFreePtr = sp;
		}
		return _rpc_result;
	}
	Msg<ResponseInfo> Basc_ADASCruiseSet_Proxy::RR_HU_CSLmode(const HUset_CSLmode &HUset_CSLmode_,const RequestInfo &Requestinfo, size_t dds_rpc_time_out) {
		Msg<ResponseInfo> _rpc_result;
		carDrive_Basc_ADASCruiseSet_Request* _rpc_request = carDrive_Basc_ADASCruiseSet_Request__alloc();

		dds_guid_t _temp_guid = { 0 };
		dds_return_t rc = dds_get_guid(dds_rpc_request_handle.writer, &_temp_guid);
		if (DDS_RETCODE_OK != rc)
		{
			ASF_LOG_ERROR_ARGS("Basc_ADASCruiseSet_Proxy::RR_HU_CSLmode dds_get_guid faild rc=[%d], writer=[%d]", rc, dds_rpc_request_handle.writer);
			_rpc_result.code = DDS_RPC_REMOTE_EX_UNSUPPORTED;
			return _rpc_result;
		}

		memcpy(&_rpc_request->header.requestId, &_temp_guid, sizeof(dds_guid_t));
		DDS_SequenceNumber_t _rpc_client_sn = com::changan::rpc_service::DDSClient::get_rpc_request_id();
		_rpc_request->header.requestId.sequence_number = _rpc_client_sn;
		_rpc_request->data._u.RR_HU_CSLmode.HUset_CSLmode = HUset_CSLmode_;
		_rpc_request->data._u.RR_HU_CSLmode.Requestinfo = Requestinfo;

		_rpc_request->data._d = carDrive_Basc_ADASCruiseSet_RR_HU_CSLmode_Hash;
		ASF_LOG_DEBUG_ARGS("Basc_ADASCruiseSet_Proxy::RR_HU_CSLmode pre async_call, hashId=[%d], reqId=[%d]", carDrive_Basc_ADASCruiseSet_RR_HU_CSLmode_Hash, _rpc_client_sn.low);
		auto _rpc_future = com::changan::rpc_service::DDSClient::async_call(_rpc_client_sn.low, dds_rpc_request_handle.writer, _rpc_request);
		carDrive_Basc_ADASCruiseSet_Request_free(_rpc_request, DDS_FREE_ALL);

		auto _rpc_status = _rpc_future.wait_for(std::chrono::milliseconds(dds_rpc_time_out));
		if (_rpc_status == std::future_status::timeout ||
			_rpc_status == std::future_status::deferred) {
			_rpc_result.code = DDS_RPC_REMOTE_TIMEOUT_EXCEPTION;
			return _rpc_result;
		}
		auto sp =_rpc_future.get();
		auto _rpc_ret = (carDrive_Basc_ADASCruiseSet_Reply*)sp.get();

		_rpc_result.code = _rpc_ret->header.remoteEx;
		if (_rpc_result.code == DDS_RPC_REMOTE_EX_OK) {
			_rpc_result.data = _rpc_ret->data._u.RR_HU_CSLmode.return_;
			_rpc_result.autoFreePtr = sp;
		}
		return _rpc_result;
	}
	Msg<ResponseInfo> Basc_ADASCruiseSet_Proxy::RR_HU_OverspeedSoundWarEnable(const HUset_OverspeedSoundWarEnable &HUset_OverspeedSoundWarEnable_,const RequestInfo &Requestinfo, size_t dds_rpc_time_out) {
		Msg<ResponseInfo> _rpc_result;
		carDrive_Basc_ADASCruiseSet_Request* _rpc_request = carDrive_Basc_ADASCruiseSet_Request__alloc();

		dds_guid_t _temp_guid = { 0 };
		dds_return_t rc = dds_get_guid(dds_rpc_request_handle.writer, &_temp_guid);
		if (DDS_RETCODE_OK != rc)
		{
			ASF_LOG_ERROR_ARGS("Basc_ADASCruiseSet_Proxy::RR_HU_OverspeedSoundWarEnable dds_get_guid faild rc=[%d], writer=[%d]", rc, dds_rpc_request_handle.writer);
			_rpc_result.code = DDS_RPC_REMOTE_EX_UNSUPPORTED;
			return _rpc_result;
		}

		memcpy(&_rpc_request->header.requestId, &_temp_guid, sizeof(dds_guid_t));
		DDS_SequenceNumber_t _rpc_client_sn = com::changan::rpc_service::DDSClient::get_rpc_request_id();
		_rpc_request->header.requestId.sequence_number = _rpc_client_sn;
		_rpc_request->data._u.RR_HU_OverspeedSoundWarEnable.HUset_OverspeedSoundWarEnable = HUset_OverspeedSoundWarEnable_;
		_rpc_request->data._u.RR_HU_OverspeedSoundWarEnable.Requestinfo = Requestinfo;

		_rpc_request->data._d = carDrive_Basc_ADASCruiseSet_RR_HU_OverspeedSoundWarEnable_Hash;
		ASF_LOG_DEBUG_ARGS("Basc_ADASCruiseSet_Proxy::RR_HU_OverspeedSoundWarEnable pre async_call, hashId=[%d], reqId=[%d]", carDrive_Basc_ADASCruiseSet_RR_HU_OverspeedSoundWarEnable_Hash, _rpc_client_sn.low);
		auto _rpc_future = com::changan::rpc_service::DDSClient::async_call(_rpc_client_sn.low, dds_rpc_request_handle.writer, _rpc_request);
		carDrive_Basc_ADASCruiseSet_Request_free(_rpc_request, DDS_FREE_ALL);

		auto _rpc_status = _rpc_future.wait_for(std::chrono::milliseconds(dds_rpc_time_out));
		if (_rpc_status == std::future_status::timeout ||
			_rpc_status == std::future_status::deferred) {
			_rpc_result.code = DDS_RPC_REMOTE_TIMEOUT_EXCEPTION;
			return _rpc_result;
		}
		auto sp =_rpc_future.get();
		auto _rpc_ret = (carDrive_Basc_ADASCruiseSet_Reply*)sp.get();

		_rpc_result.code = _rpc_ret->header.remoteEx;
		if (_rpc_result.code == DDS_RPC_REMOTE_EX_OK) {
			_rpc_result.data = _rpc_ret->data._u.RR_HU_OverspeedSoundWarEnable.return_;
			_rpc_result.autoFreePtr = sp;
		}
		return _rpc_result;
	}
	Msg<ResponseInfo> Basc_ADASCruiseSet_Proxy::RR_HU_CSLWarnOffsetTp(const HUset_CSLWarnOffsetTp &HUset_CSLWarnOffsetTp_,const RequestInfo &Requestinfo, size_t dds_rpc_time_out) {
		Msg<ResponseInfo> _rpc_result;
		carDrive_Basc_ADASCruiseSet_Request* _rpc_request = carDrive_Basc_ADASCruiseSet_Request__alloc();

		dds_guid_t _temp_guid = { 0 };
		dds_return_t rc = dds_get_guid(dds_rpc_request_handle.writer, &_temp_guid);
		if (DDS_RETCODE_OK != rc)
		{
			ASF_LOG_ERROR_ARGS("Basc_ADASCruiseSet_Proxy::RR_HU_CSLWarnOffsetTp dds_get_guid faild rc=[%d], writer=[%d]", rc, dds_rpc_request_handle.writer);
			_rpc_result.code = DDS_RPC_REMOTE_EX_UNSUPPORTED;
			return _rpc_result;
		}

		memcpy(&_rpc_request->header.requestId, &_temp_guid, sizeof(dds_guid_t));
		DDS_SequenceNumber_t _rpc_client_sn = com::changan::rpc_service::DDSClient::get_rpc_request_id();
		_rpc_request->header.requestId.sequence_number = _rpc_client_sn;
		_rpc_request->data._u.RR_HU_CSLWarnOffsetTp.HUset_CSLWarnOffsetTp = HUset_CSLWarnOffsetTp_;
		_rpc_request->data._u.RR_HU_CSLWarnOffsetTp.Requestinfo = Requestinfo;

		_rpc_request->data._d = carDrive_Basc_ADASCruiseSet_RR_HU_CSLWarnOffsetTp_Hash;
		ASF_LOG_DEBUG_ARGS("Basc_ADASCruiseSet_Proxy::RR_HU_CSLWarnOffsetTp pre async_call, hashId=[%d], reqId=[%d]", carDrive_Basc_ADASCruiseSet_RR_HU_CSLWarnOffsetTp_Hash, _rpc_client_sn.low);
		auto _rpc_future = com::changan::rpc_service::DDSClient::async_call(_rpc_client_sn.low, dds_rpc_request_handle.writer, _rpc_request);
		carDrive_Basc_ADASCruiseSet_Request_free(_rpc_request, DDS_FREE_ALL);

		auto _rpc_status = _rpc_future.wait_for(std::chrono::milliseconds(dds_rpc_time_out));
		if (_rpc_status == std::future_status::timeout ||
			_rpc_status == std::future_status::deferred) {
			_rpc_result.code = DDS_RPC_REMOTE_TIMEOUT_EXCEPTION;
			return _rpc_result;
		}
		auto sp =_rpc_future.get();
		auto _rpc_ret = (carDrive_Basc_ADASCruiseSet_Reply*)sp.get();

		_rpc_result.code = _rpc_ret->header.remoteEx;
		if (_rpc_result.code == DDS_RPC_REMOTE_EX_OK) {
			_rpc_result.data = _rpc_ret->data._u.RR_HU_CSLWarnOffsetTp.return_;
			_rpc_result.autoFreePtr = sp;
		}
		return _rpc_result;
	}
	Msg<ResponseInfo> Basc_ADASCruiseSet_Proxy::RR_HU_AbsOverSpdWarnOffset(const HUset_AbsOverSpdWarnOffset &HUset_AbsOverSpdWarnOffset_,const RequestInfo &Requestinfo, size_t dds_rpc_time_out) {
		Msg<ResponseInfo> _rpc_result;
		carDrive_Basc_ADASCruiseSet_Request* _rpc_request = carDrive_Basc_ADASCruiseSet_Request__alloc();

		dds_guid_t _temp_guid = { 0 };
		dds_return_t rc = dds_get_guid(dds_rpc_request_handle.writer, &_temp_guid);
		if (DDS_RETCODE_OK != rc)
		{
			ASF_LOG_ERROR_ARGS("Basc_ADASCruiseSet_Proxy::RR_HU_AbsOverSpdWarnOffset dds_get_guid faild rc=[%d], writer=[%d]", rc, dds_rpc_request_handle.writer);
			_rpc_result.code = DDS_RPC_REMOTE_EX_UNSUPPORTED;
			return _rpc_result;
		}

		memcpy(&_rpc_request->header.requestId, &_temp_guid, sizeof(dds_guid_t));
		DDS_SequenceNumber_t _rpc_client_sn = com::changan::rpc_service::DDSClient::get_rpc_request_id();
		_rpc_request->header.requestId.sequence_number = _rpc_client_sn;
		_rpc_request->data._u.RR_HU_AbsOverSpdWarnOffset.HUset_AbsOverSpdWarnOffset = HUset_AbsOverSpdWarnOffset_;
		_rpc_request->data._u.RR_HU_AbsOverSpdWarnOffset.Requestinfo = Requestinfo;

		_rpc_request->data._d = carDrive_Basc_ADASCruiseSet_RR_HU_AbsOverSpdWarnOffset_Hash;
		ASF_LOG_DEBUG_ARGS("Basc_ADASCruiseSet_Proxy::RR_HU_AbsOverSpdWarnOffset pre async_call, hashId=[%d], reqId=[%d]", carDrive_Basc_ADASCruiseSet_RR_HU_AbsOverSpdWarnOffset_Hash, _rpc_client_sn.low);
		auto _rpc_future = com::changan::rpc_service::DDSClient::async_call(_rpc_client_sn.low, dds_rpc_request_handle.writer, _rpc_request);
		carDrive_Basc_ADASCruiseSet_Request_free(_rpc_request, DDS_FREE_ALL);

		auto _rpc_status = _rpc_future.wait_for(std::chrono::milliseconds(dds_rpc_time_out));
		if (_rpc_status == std::future_status::timeout ||
			_rpc_status == std::future_status::deferred) {
			_rpc_result.code = DDS_RPC_REMOTE_TIMEOUT_EXCEPTION;
			return _rpc_result;
		}
		auto sp =_rpc_future.get();
		auto _rpc_ret = (carDrive_Basc_ADASCruiseSet_Reply*)sp.get();

		_rpc_result.code = _rpc_ret->header.remoteEx;
		if (_rpc_result.code == DDS_RPC_REMOTE_EX_OK) {
			_rpc_result.data = _rpc_ret->data._u.RR_HU_AbsOverSpdWarnOffset.return_;
			_rpc_result.autoFreePtr = sp;
		}
		return _rpc_result;
	}
	Msg<ResponseInfo> Basc_ADASCruiseSet_Proxy::RR_HU_RelOverSpdWarnOffset(const HUset_RelOverSpdWarnOffset &HUset_RelOverSpdWarnOffset_,const RequestInfo &Requestinfo, size_t dds_rpc_time_out) {
		Msg<ResponseInfo> _rpc_result;
		carDrive_Basc_ADASCruiseSet_Request* _rpc_request = carDrive_Basc_ADASCruiseSet_Request__alloc();

		dds_guid_t _temp_guid = { 0 };
		dds_return_t rc = dds_get_guid(dds_rpc_request_handle.writer, &_temp_guid);
		if (DDS_RETCODE_OK != rc)
		{
			ASF_LOG_ERROR_ARGS("Basc_ADASCruiseSet_Proxy::RR_HU_RelOverSpdWarnOffset dds_get_guid faild rc=[%d], writer=[%d]", rc, dds_rpc_request_handle.writer);
			_rpc_result.code = DDS_RPC_REMOTE_EX_UNSUPPORTED;
			return _rpc_result;
		}

		memcpy(&_rpc_request->header.requestId, &_temp_guid, sizeof(dds_guid_t));
		DDS_SequenceNumber_t _rpc_client_sn = com::changan::rpc_service::DDSClient::get_rpc_request_id();
		_rpc_request->header.requestId.sequence_number = _rpc_client_sn;
		_rpc_request->data._u.RR_HU_RelOverSpdWarnOffset.HUset_RelOverSpdWarnOffset = HUset_RelOverSpdWarnOffset_;
		_rpc_request->data._u.RR_HU_RelOverSpdWarnOffset.Requestinfo = Requestinfo;

		_rpc_request->data._d = carDrive_Basc_ADASCruiseSet_RR_HU_RelOverSpdWarnOffset_Hash;
		ASF_LOG_DEBUG_ARGS("Basc_ADASCruiseSet_Proxy::RR_HU_RelOverSpdWarnOffset pre async_call, hashId=[%d], reqId=[%d]", carDrive_Basc_ADASCruiseSet_RR_HU_RelOverSpdWarnOffset_Hash, _rpc_client_sn.low);
		auto _rpc_future = com::changan::rpc_service::DDSClient::async_call(_rpc_client_sn.low, dds_rpc_request_handle.writer, _rpc_request);
		carDrive_Basc_ADASCruiseSet_Request_free(_rpc_request, DDS_FREE_ALL);

		auto _rpc_status = _rpc_future.wait_for(std::chrono::milliseconds(dds_rpc_time_out));
		if (_rpc_status == std::future_status::timeout ||
			_rpc_status == std::future_status::deferred) {
			_rpc_result.code = DDS_RPC_REMOTE_TIMEOUT_EXCEPTION;
			return _rpc_result;
		}
		auto sp =_rpc_future.get();
		auto _rpc_ret = (carDrive_Basc_ADASCruiseSet_Reply*)sp.get();

		_rpc_result.code = _rpc_ret->header.remoteEx;
		if (_rpc_result.code == DDS_RPC_REMOTE_EX_OK) {
			_rpc_result.data = _rpc_ret->data._u.RR_HU_RelOverSpdWarnOffset.return_;
			_rpc_result.autoFreePtr = sp;
		}
		return _rpc_result;
	}
	Msg<ResponseInfo> Basc_ADASCruiseSet_Proxy::RR_HU_AutoDriveStyle(const HUset_AutoDriveStyle &HUset_AutoDriveStyle_,const RequestInfo &Requestinfo, size_t dds_rpc_time_out) {
		Msg<ResponseInfo> _rpc_result;
		carDrive_Basc_ADASCruiseSet_Request* _rpc_request = carDrive_Basc_ADASCruiseSet_Request__alloc();

		dds_guid_t _temp_guid = { 0 };
		dds_return_t rc = dds_get_guid(dds_rpc_request_handle.writer, &_temp_guid);
		if (DDS_RETCODE_OK != rc)
		{
			ASF_LOG_ERROR_ARGS("Basc_ADASCruiseSet_Proxy::RR_HU_AutoDriveStyle dds_get_guid faild rc=[%d], writer=[%d]", rc, dds_rpc_request_handle.writer);
			_rpc_result.code = DDS_RPC_REMOTE_EX_UNSUPPORTED;
			return _rpc_result;
		}

		memcpy(&_rpc_request->header.requestId, &_temp_guid, sizeof(dds_guid_t));
		DDS_SequenceNumber_t _rpc_client_sn = com::changan::rpc_service::DDSClient::get_rpc_request_id();
		_rpc_request->header.requestId.sequence_number = _rpc_client_sn;
		_rpc_request->data._u.RR_HU_AutoDriveStyle.HUset_AutoDriveStyle = HUset_AutoDriveStyle_;
		_rpc_request->data._u.RR_HU_AutoDriveStyle.Requestinfo = Requestinfo;

		_rpc_request->data._d = carDrive_Basc_ADASCruiseSet_RR_HU_AutoDriveStyle_Hash;
		ASF_LOG_DEBUG_ARGS("Basc_ADASCruiseSet_Proxy::RR_HU_AutoDriveStyle pre async_call, hashId=[%d], reqId=[%d]", carDrive_Basc_ADASCruiseSet_RR_HU_AutoDriveStyle_Hash, _rpc_client_sn.low);
		auto _rpc_future = com::changan::rpc_service::DDSClient::async_call(_rpc_client_sn.low, dds_rpc_request_handle.writer, _rpc_request);
		carDrive_Basc_ADASCruiseSet_Request_free(_rpc_request, DDS_FREE_ALL);

		auto _rpc_status = _rpc_future.wait_for(std::chrono::milliseconds(dds_rpc_time_out));
		if (_rpc_status == std::future_status::timeout ||
			_rpc_status == std::future_status::deferred) {
			_rpc_result.code = DDS_RPC_REMOTE_TIMEOUT_EXCEPTION;
			return _rpc_result;
		}
		auto sp =_rpc_future.get();
		auto _rpc_ret = (carDrive_Basc_ADASCruiseSet_Reply*)sp.get();

		_rpc_result.code = _rpc_ret->header.remoteEx;
		if (_rpc_result.code == DDS_RPC_REMOTE_EX_OK) {
			_rpc_result.data = _rpc_ret->data._u.RR_HU_AutoDriveStyle.return_;
			_rpc_result.autoFreePtr = sp;
		}
		return _rpc_result;
	}
	Msg<ResponseInfo> Basc_ADASCruiseSet_Proxy::RR_HU_ADACCStyle(const HUset_ADACCStyle &HUset_ADACCStyle_,const RequestInfo &Requestinfo, size_t dds_rpc_time_out) {
		Msg<ResponseInfo> _rpc_result;
		carDrive_Basc_ADASCruiseSet_Request* _rpc_request = carDrive_Basc_ADASCruiseSet_Request__alloc();

		dds_guid_t _temp_guid = { 0 };
		dds_return_t rc = dds_get_guid(dds_rpc_request_handle.writer, &_temp_guid);
		if (DDS_RETCODE_OK != rc)
		{
			ASF_LOG_ERROR_ARGS("Basc_ADASCruiseSet_Proxy::RR_HU_ADACCStyle dds_get_guid faild rc=[%d], writer=[%d]", rc, dds_rpc_request_handle.writer);
			_rpc_result.code = DDS_RPC_REMOTE_EX_UNSUPPORTED;
			return _rpc_result;
		}

		memcpy(&_rpc_request->header.requestId, &_temp_guid, sizeof(dds_guid_t));
		DDS_SequenceNumber_t _rpc_client_sn = com::changan::rpc_service::DDSClient::get_rpc_request_id();
		_rpc_request->header.requestId.sequence_number = _rpc_client_sn;
		_rpc_request->data._u.RR_HU_ADACCStyle.HUset_ADACCStyle = HUset_ADACCStyle_;
		_rpc_request->data._u.RR_HU_ADACCStyle.Requestinfo = Requestinfo;

		_rpc_request->data._d = carDrive_Basc_ADASCruiseSet_RR_HU_ADACCStyle_Hash;
		ASF_LOG_DEBUG_ARGS("Basc_ADASCruiseSet_Proxy::RR_HU_ADACCStyle pre async_call, hashId=[%d], reqId=[%d]", carDrive_Basc_ADASCruiseSet_RR_HU_ADACCStyle_Hash, _rpc_client_sn.low);
		auto _rpc_future = com::changan::rpc_service::DDSClient::async_call(_rpc_client_sn.low, dds_rpc_request_handle.writer, _rpc_request);
		carDrive_Basc_ADASCruiseSet_Request_free(_rpc_request, DDS_FREE_ALL);

		auto _rpc_status = _rpc_future.wait_for(std::chrono::milliseconds(dds_rpc_time_out));
		if (_rpc_status == std::future_status::timeout ||
			_rpc_status == std::future_status::deferred) {
			_rpc_result.code = DDS_RPC_REMOTE_TIMEOUT_EXCEPTION;
			return _rpc_result;
		}
		auto sp =_rpc_future.get();
		auto _rpc_ret = (carDrive_Basc_ADASCruiseSet_Reply*)sp.get();

		_rpc_result.code = _rpc_ret->header.remoteEx;
		if (_rpc_result.code == DDS_RPC_REMOTE_EX_OK) {
			_rpc_result.data = _rpc_ret->data._u.RR_HU_ADACCStyle.return_;
			_rpc_result.autoFreePtr = sp;
		}
		return _rpc_result;
	}
	Msg<ResponseInfo> Basc_ADASCruiseSet_Proxy::RR_HU_ADStartStyle(const HUset_ADStartStyle &HUset_ADStartStyle_,const RequestInfo &Requestinfo, size_t dds_rpc_time_out) {
		Msg<ResponseInfo> _rpc_result;
		carDrive_Basc_ADASCruiseSet_Request* _rpc_request = carDrive_Basc_ADASCruiseSet_Request__alloc();

		dds_guid_t _temp_guid = { 0 };
		dds_return_t rc = dds_get_guid(dds_rpc_request_handle.writer, &_temp_guid);
		if (DDS_RETCODE_OK != rc)
		{
			ASF_LOG_ERROR_ARGS("Basc_ADASCruiseSet_Proxy::RR_HU_ADStartStyle dds_get_guid faild rc=[%d], writer=[%d]", rc, dds_rpc_request_handle.writer);
			_rpc_result.code = DDS_RPC_REMOTE_EX_UNSUPPORTED;
			return _rpc_result;
		}

		memcpy(&_rpc_request->header.requestId, &_temp_guid, sizeof(dds_guid_t));
		DDS_SequenceNumber_t _rpc_client_sn = com::changan::rpc_service::DDSClient::get_rpc_request_id();
		_rpc_request->header.requestId.sequence_number = _rpc_client_sn;
		_rpc_request->data._u.RR_HU_ADStartStyle.HUset_ADStartStyle = HUset_ADStartStyle_;
		_rpc_request->data._u.RR_HU_ADStartStyle.Requestinfo = Requestinfo;

		_rpc_request->data._d = carDrive_Basc_ADASCruiseSet_RR_HU_ADStartStyle_Hash;
		ASF_LOG_DEBUG_ARGS("Basc_ADASCruiseSet_Proxy::RR_HU_ADStartStyle pre async_call, hashId=[%d], reqId=[%d]", carDrive_Basc_ADASCruiseSet_RR_HU_ADStartStyle_Hash, _rpc_client_sn.low);
		auto _rpc_future = com::changan::rpc_service::DDSClient::async_call(_rpc_client_sn.low, dds_rpc_request_handle.writer, _rpc_request);
		carDrive_Basc_ADASCruiseSet_Request_free(_rpc_request, DDS_FREE_ALL);

		auto _rpc_status = _rpc_future.wait_for(std::chrono::milliseconds(dds_rpc_time_out));
		if (_rpc_status == std::future_status::timeout ||
			_rpc_status == std::future_status::deferred) {
			_rpc_result.code = DDS_RPC_REMOTE_TIMEOUT_EXCEPTION;
			return _rpc_result;
		}
		auto sp =_rpc_future.get();
		auto _rpc_ret = (carDrive_Basc_ADASCruiseSet_Reply*)sp.get();

		_rpc_result.code = _rpc_ret->header.remoteEx;
		if (_rpc_result.code == DDS_RPC_REMOTE_EX_OK) {
			_rpc_result.data = _rpc_ret->data._u.RR_HU_ADStartStyle.return_;
			_rpc_result.autoFreePtr = sp;
		}
		return _rpc_result;
	}
	Msg<ResponseInfo> Basc_ADASCruiseSet_Proxy::RR_HU_ADCurveStyle(const HUset_ADCurveStyle &HUset_ADCurveStyle_,const RequestInfo &Requestinfo, size_t dds_rpc_time_out) {
		Msg<ResponseInfo> _rpc_result;
		carDrive_Basc_ADASCruiseSet_Request* _rpc_request = carDrive_Basc_ADASCruiseSet_Request__alloc();

		dds_guid_t _temp_guid = { 0 };
		dds_return_t rc = dds_get_guid(dds_rpc_request_handle.writer, &_temp_guid);
		if (DDS_RETCODE_OK != rc)
		{
			ASF_LOG_ERROR_ARGS("Basc_ADASCruiseSet_Proxy::RR_HU_ADCurveStyle dds_get_guid faild rc=[%d], writer=[%d]", rc, dds_rpc_request_handle.writer);
			_rpc_result.code = DDS_RPC_REMOTE_EX_UNSUPPORTED;
			return _rpc_result;
		}

		memcpy(&_rpc_request->header.requestId, &_temp_guid, sizeof(dds_guid_t));
		DDS_SequenceNumber_t _rpc_client_sn = com::changan::rpc_service::DDSClient::get_rpc_request_id();
		_rpc_request->header.requestId.sequence_number = _rpc_client_sn;
		_rpc_request->data._u.RR_HU_ADCurveStyle.HUset_ADCurveStyle = HUset_ADCurveStyle_;
		_rpc_request->data._u.RR_HU_ADCurveStyle.Requestinfo = Requestinfo;

		_rpc_request->data._d = carDrive_Basc_ADASCruiseSet_RR_HU_ADCurveStyle_Hash;
		ASF_LOG_DEBUG_ARGS("Basc_ADASCruiseSet_Proxy::RR_HU_ADCurveStyle pre async_call, hashId=[%d], reqId=[%d]", carDrive_Basc_ADASCruiseSet_RR_HU_ADCurveStyle_Hash, _rpc_client_sn.low);
		auto _rpc_future = com::changan::rpc_service::DDSClient::async_call(_rpc_client_sn.low, dds_rpc_request_handle.writer, _rpc_request);
		carDrive_Basc_ADASCruiseSet_Request_free(_rpc_request, DDS_FREE_ALL);

		auto _rpc_status = _rpc_future.wait_for(std::chrono::milliseconds(dds_rpc_time_out));
		if (_rpc_status == std::future_status::timeout ||
			_rpc_status == std::future_status::deferred) {
			_rpc_result.code = DDS_RPC_REMOTE_TIMEOUT_EXCEPTION;
			return _rpc_result;
		}
		auto sp =_rpc_future.get();
		auto _rpc_ret = (carDrive_Basc_ADASCruiseSet_Reply*)sp.get();

		_rpc_result.code = _rpc_ret->header.remoteEx;
		if (_rpc_result.code == DDS_RPC_REMOTE_EX_OK) {
			_rpc_result.data = _rpc_ret->data._u.RR_HU_ADCurveStyle.return_;
			_rpc_result.autoFreePtr = sp;
		}
		return _rpc_result;
	}
	Msg<ResponseInfo> Basc_ADASCruiseSet_Proxy::RR_HU_ADLanechangeStyle(const HUset_ADLanechangeStyle &HUset_ADLanechangeStyle_,const RequestInfo &Requestinfo, size_t dds_rpc_time_out) {
		Msg<ResponseInfo> _rpc_result;
		carDrive_Basc_ADASCruiseSet_Request* _rpc_request = carDrive_Basc_ADASCruiseSet_Request__alloc();

		dds_guid_t _temp_guid = { 0 };
		dds_return_t rc = dds_get_guid(dds_rpc_request_handle.writer, &_temp_guid);
		if (DDS_RETCODE_OK != rc)
		{
			ASF_LOG_ERROR_ARGS("Basc_ADASCruiseSet_Proxy::RR_HU_ADLanechangeStyle dds_get_guid faild rc=[%d], writer=[%d]", rc, dds_rpc_request_handle.writer);
			_rpc_result.code = DDS_RPC_REMOTE_EX_UNSUPPORTED;
			return _rpc_result;
		}

		memcpy(&_rpc_request->header.requestId, &_temp_guid, sizeof(dds_guid_t));
		DDS_SequenceNumber_t _rpc_client_sn = com::changan::rpc_service::DDSClient::get_rpc_request_id();
		_rpc_request->header.requestId.sequence_number = _rpc_client_sn;
		_rpc_request->data._u.RR_HU_ADLanechangeStyle.HUset_ADLanechangeStyle = HUset_ADLanechangeStyle_;
		_rpc_request->data._u.RR_HU_ADLanechangeStyle.Requestinfo = Requestinfo;

		_rpc_request->data._d = carDrive_Basc_ADASCruiseSet_RR_HU_ADLanechangeStyle_Hash;
		ASF_LOG_DEBUG_ARGS("Basc_ADASCruiseSet_Proxy::RR_HU_ADLanechangeStyle pre async_call, hashId=[%d], reqId=[%d]", carDrive_Basc_ADASCruiseSet_RR_HU_ADLanechangeStyle_Hash, _rpc_client_sn.low);
		auto _rpc_future = com::changan::rpc_service::DDSClient::async_call(_rpc_client_sn.low, dds_rpc_request_handle.writer, _rpc_request);
		carDrive_Basc_ADASCruiseSet_Request_free(_rpc_request, DDS_FREE_ALL);

		auto _rpc_status = _rpc_future.wait_for(std::chrono::milliseconds(dds_rpc_time_out));
		if (_rpc_status == std::future_status::timeout ||
			_rpc_status == std::future_status::deferred) {
			_rpc_result.code = DDS_RPC_REMOTE_TIMEOUT_EXCEPTION;
			return _rpc_result;
		}
		auto sp =_rpc_future.get();
		auto _rpc_ret = (carDrive_Basc_ADASCruiseSet_Reply*)sp.get();

		_rpc_result.code = _rpc_ret->header.remoteEx;
		if (_rpc_result.code == DDS_RPC_REMOTE_EX_OK) {
			_rpc_result.data = _rpc_ret->data._u.RR_HU_ADLanechangeStyle.return_;
			_rpc_result.autoFreePtr = sp;
		}
		return _rpc_result;
	}
	Msg<ResponseInfo> Basc_ADASCruiseSet_Proxy::RR_HU_VehicleStartRemindEnable(const HUset_VehicleStartRemindEnable &HUset_VehicleStartRemindEnable_,const RequestInfo &Requestinfo, size_t dds_rpc_time_out) {
		Msg<ResponseInfo> _rpc_result;
		carDrive_Basc_ADASCruiseSet_Request* _rpc_request = carDrive_Basc_ADASCruiseSet_Request__alloc();

		dds_guid_t _temp_guid = { 0 };
		dds_return_t rc = dds_get_guid(dds_rpc_request_handle.writer, &_temp_guid);
		if (DDS_RETCODE_OK != rc)
		{
			ASF_LOG_ERROR_ARGS("Basc_ADASCruiseSet_Proxy::RR_HU_VehicleStartRemindEnable dds_get_guid faild rc=[%d], writer=[%d]", rc, dds_rpc_request_handle.writer);
			_rpc_result.code = DDS_RPC_REMOTE_EX_UNSUPPORTED;
			return _rpc_result;
		}

		memcpy(&_rpc_request->header.requestId, &_temp_guid, sizeof(dds_guid_t));
		DDS_SequenceNumber_t _rpc_client_sn = com::changan::rpc_service::DDSClient::get_rpc_request_id();
		_rpc_request->header.requestId.sequence_number = _rpc_client_sn;
		_rpc_request->data._u.RR_HU_VehicleStartRemindEnable.HUset_VehicleStartRemindEnable = HUset_VehicleStartRemindEnable_;
		_rpc_request->data._u.RR_HU_VehicleStartRemindEnable.Requestinfo = Requestinfo;

		_rpc_request->data._d = carDrive_Basc_ADASCruiseSet_RR_HU_VehicleStartRemindEnable_Hash;
		ASF_LOG_DEBUG_ARGS("Basc_ADASCruiseSet_Proxy::RR_HU_VehicleStartRemindEnable pre async_call, hashId=[%d], reqId=[%d]", carDrive_Basc_ADASCruiseSet_RR_HU_VehicleStartRemindEnable_Hash, _rpc_client_sn.low);
		auto _rpc_future = com::changan::rpc_service::DDSClient::async_call(_rpc_client_sn.low, dds_rpc_request_handle.writer, _rpc_request);
		carDrive_Basc_ADASCruiseSet_Request_free(_rpc_request, DDS_FREE_ALL);

		auto _rpc_status = _rpc_future.wait_for(std::chrono::milliseconds(dds_rpc_time_out));
		if (_rpc_status == std::future_status::timeout ||
			_rpc_status == std::future_status::deferred) {
			_rpc_result.code = DDS_RPC_REMOTE_TIMEOUT_EXCEPTION;
			return _rpc_result;
		}
		auto sp =_rpc_future.get();
		auto _rpc_ret = (carDrive_Basc_ADASCruiseSet_Reply*)sp.get();

		_rpc_result.code = _rpc_ret->header.remoteEx;
		if (_rpc_result.code == DDS_RPC_REMOTE_EX_OK) {
			_rpc_result.data = _rpc_ret->data._u.RR_HU_VehicleStartRemindEnable.return_;
			_rpc_result.autoFreePtr = sp;
		}
		return _rpc_result;
	}
	Msg<ResponseInfo> Basc_ADASCruiseSet_Proxy::RR_HU_RCWEnable(const HUset_RCWEnable &HUset_RCWEnable_,const RequestInfo &Requestinfo, size_t dds_rpc_time_out) {
		Msg<ResponseInfo> _rpc_result;
		carDrive_Basc_ADASCruiseSet_Request* _rpc_request = carDrive_Basc_ADASCruiseSet_Request__alloc();

		dds_guid_t _temp_guid = { 0 };
		dds_return_t rc = dds_get_guid(dds_rpc_request_handle.writer, &_temp_guid);
		if (DDS_RETCODE_OK != rc)
		{
			ASF_LOG_ERROR_ARGS("Basc_ADASCruiseSet_Proxy::RR_HU_RCWEnable dds_get_guid faild rc=[%d], writer=[%d]", rc, dds_rpc_request_handle.writer);
			_rpc_result.code = DDS_RPC_REMOTE_EX_UNSUPPORTED;
			return _rpc_result;
		}

		memcpy(&_rpc_request->header.requestId, &_temp_guid, sizeof(dds_guid_t));
		DDS_SequenceNumber_t _rpc_client_sn = com::changan::rpc_service::DDSClient::get_rpc_request_id();
		_rpc_request->header.requestId.sequence_number = _rpc_client_sn;
		_rpc_request->data._u.RR_HU_RCWEnable.HUset_RCWEnable = HUset_RCWEnable_;
		_rpc_request->data._u.RR_HU_RCWEnable.Requestinfo = Requestinfo;

		_rpc_request->data._d = carDrive_Basc_ADASCruiseSet_RR_HU_RCWEnable_Hash;
		ASF_LOG_DEBUG_ARGS("Basc_ADASCruiseSet_Proxy::RR_HU_RCWEnable pre async_call, hashId=[%d], reqId=[%d]", carDrive_Basc_ADASCruiseSet_RR_HU_RCWEnable_Hash, _rpc_client_sn.low);
		auto _rpc_future = com::changan::rpc_service::DDSClient::async_call(_rpc_client_sn.low, dds_rpc_request_handle.writer, _rpc_request);
		carDrive_Basc_ADASCruiseSet_Request_free(_rpc_request, DDS_FREE_ALL);

		auto _rpc_status = _rpc_future.wait_for(std::chrono::milliseconds(dds_rpc_time_out));
		if (_rpc_status == std::future_status::timeout ||
			_rpc_status == std::future_status::deferred) {
			_rpc_result.code = DDS_RPC_REMOTE_TIMEOUT_EXCEPTION;
			return _rpc_result;
		}
		auto sp =_rpc_future.get();
		auto _rpc_ret = (carDrive_Basc_ADASCruiseSet_Reply*)sp.get();

		_rpc_result.code = _rpc_ret->header.remoteEx;
		if (_rpc_result.code == DDS_RPC_REMOTE_EX_OK) {
			_rpc_result.data = _rpc_ret->data._u.RR_HU_RCWEnable.return_;
			_rpc_result.autoFreePtr = sp;
		}
		return _rpc_result;
	}
	Msg<ResponseInfo> Basc_ADASCruiseSet_Proxy::RR_HU_SEAMode(const HUset_SEAMode &HUset_SEAMode_,const RequestInfo &Requestinfo, size_t dds_rpc_time_out) {
		Msg<ResponseInfo> _rpc_result;
		carDrive_Basc_ADASCruiseSet_Request* _rpc_request = carDrive_Basc_ADASCruiseSet_Request__alloc();

		dds_guid_t _temp_guid = { 0 };
		dds_return_t rc = dds_get_guid(dds_rpc_request_handle.writer, &_temp_guid);
		if (DDS_RETCODE_OK != rc)
		{
			ASF_LOG_ERROR_ARGS("Basc_ADASCruiseSet_Proxy::RR_HU_SEAMode dds_get_guid faild rc=[%d], writer=[%d]", rc, dds_rpc_request_handle.writer);
			_rpc_result.code = DDS_RPC_REMOTE_EX_UNSUPPORTED;
			return _rpc_result;
		}

		memcpy(&_rpc_request->header.requestId, &_temp_guid, sizeof(dds_guid_t));
		DDS_SequenceNumber_t _rpc_client_sn = com::changan::rpc_service::DDSClient::get_rpc_request_id();
		_rpc_request->header.requestId.sequence_number = _rpc_client_sn;
		_rpc_request->data._u.RR_HU_SEAMode.HUset_SEAMode = HUset_SEAMode_;
		_rpc_request->data._u.RR_HU_SEAMode.Requestinfo = Requestinfo;

		_rpc_request->data._d = carDrive_Basc_ADASCruiseSet_RR_HU_SEAMode_Hash;
		ASF_LOG_DEBUG_ARGS("Basc_ADASCruiseSet_Proxy::RR_HU_SEAMode pre async_call, hashId=[%d], reqId=[%d]", carDrive_Basc_ADASCruiseSet_RR_HU_SEAMode_Hash, _rpc_client_sn.low);
		auto _rpc_future = com::changan::rpc_service::DDSClient::async_call(_rpc_client_sn.low, dds_rpc_request_handle.writer, _rpc_request);
		carDrive_Basc_ADASCruiseSet_Request_free(_rpc_request, DDS_FREE_ALL);

		auto _rpc_status = _rpc_future.wait_for(std::chrono::milliseconds(dds_rpc_time_out));
		if (_rpc_status == std::future_status::timeout ||
			_rpc_status == std::future_status::deferred) {
			_rpc_result.code = DDS_RPC_REMOTE_TIMEOUT_EXCEPTION;
			return _rpc_result;
		}
		auto sp =_rpc_future.get();
		auto _rpc_ret = (carDrive_Basc_ADASCruiseSet_Reply*)sp.get();

		_rpc_result.code = _rpc_ret->header.remoteEx;
		if (_rpc_result.code == DDS_RPC_REMOTE_EX_OK) {
			_rpc_result.data = _rpc_ret->data._u.RR_HU_SEAMode.return_;
			_rpc_result.autoFreePtr = sp;
		}
		return _rpc_result;
	}
	Msg<ResponseInfo> Basc_ADASCruiseSet_Proxy::RR_HU_BSDLCASetting(const HUset_BSDLCASetting &HUset_BSDLCASetting_,const RequestInfo &Requestinfo, size_t dds_rpc_time_out) {
		Msg<ResponseInfo> _rpc_result;
		carDrive_Basc_ADASCruiseSet_Request* _rpc_request = carDrive_Basc_ADASCruiseSet_Request__alloc();

		dds_guid_t _temp_guid = { 0 };
		dds_return_t rc = dds_get_guid(dds_rpc_request_handle.writer, &_temp_guid);
		if (DDS_RETCODE_OK != rc)
		{
			ASF_LOG_ERROR_ARGS("Basc_ADASCruiseSet_Proxy::RR_HU_BSDLCASetting dds_get_guid faild rc=[%d], writer=[%d]", rc, dds_rpc_request_handle.writer);
			_rpc_result.code = DDS_RPC_REMOTE_EX_UNSUPPORTED;
			return _rpc_result;
		}

		memcpy(&_rpc_request->header.requestId, &_temp_guid, sizeof(dds_guid_t));
		DDS_SequenceNumber_t _rpc_client_sn = com::changan::rpc_service::DDSClient::get_rpc_request_id();
		_rpc_request->header.requestId.sequence_number = _rpc_client_sn;
		_rpc_request->data._u.RR_HU_BSDLCASetting.HUset_BSDLCASetting = HUset_BSDLCASetting_;
		_rpc_request->data._u.RR_HU_BSDLCASetting.Requestinfo = Requestinfo;

		_rpc_request->data._d = carDrive_Basc_ADASCruiseSet_RR_HU_BSDLCASetting_Hash;
		ASF_LOG_DEBUG_ARGS("Basc_ADASCruiseSet_Proxy::RR_HU_BSDLCASetting pre async_call, hashId=[%d], reqId=[%d]", carDrive_Basc_ADASCruiseSet_RR_HU_BSDLCASetting_Hash, _rpc_client_sn.low);
		auto _rpc_future = com::changan::rpc_service::DDSClient::async_call(_rpc_client_sn.low, dds_rpc_request_handle.writer, _rpc_request);
		carDrive_Basc_ADASCruiseSet_Request_free(_rpc_request, DDS_FREE_ALL);

		auto _rpc_status = _rpc_future.wait_for(std::chrono::milliseconds(dds_rpc_time_out));
		if (_rpc_status == std::future_status::timeout ||
			_rpc_status == std::future_status::deferred) {
			_rpc_result.code = DDS_RPC_REMOTE_TIMEOUT_EXCEPTION;
			return _rpc_result;
		}
		auto sp =_rpc_future.get();
		auto _rpc_ret = (carDrive_Basc_ADASCruiseSet_Reply*)sp.get();

		_rpc_result.code = _rpc_ret->header.remoteEx;
		if (_rpc_result.code == DDS_RPC_REMOTE_EX_OK) {
			_rpc_result.data = _rpc_ret->data._u.RR_HU_BSDLCASetting.return_;
			_rpc_result.autoFreePtr = sp;
		}
		return _rpc_result;
	}
	Msg<ResponseInfo> Basc_ADASCruiseSet_Proxy::RR_HU_BSDLCARemindmode(const HUset_BSDLCARemindmode &HUset_BSDLCARemindmode_,const RequestInfo &Requestinfo, size_t dds_rpc_time_out) {
		Msg<ResponseInfo> _rpc_result;
		carDrive_Basc_ADASCruiseSet_Request* _rpc_request = carDrive_Basc_ADASCruiseSet_Request__alloc();

		dds_guid_t _temp_guid = { 0 };
		dds_return_t rc = dds_get_guid(dds_rpc_request_handle.writer, &_temp_guid);
		if (DDS_RETCODE_OK != rc)
		{
			ASF_LOG_ERROR_ARGS("Basc_ADASCruiseSet_Proxy::RR_HU_BSDLCARemindmode dds_get_guid faild rc=[%d], writer=[%d]", rc, dds_rpc_request_handle.writer);
			_rpc_result.code = DDS_RPC_REMOTE_EX_UNSUPPORTED;
			return _rpc_result;
		}

		memcpy(&_rpc_request->header.requestId, &_temp_guid, sizeof(dds_guid_t));
		DDS_SequenceNumber_t _rpc_client_sn = com::changan::rpc_service::DDSClient::get_rpc_request_id();
		_rpc_request->header.requestId.sequence_number = _rpc_client_sn;
		_rpc_request->data._u.RR_HU_BSDLCARemindmode.HUset_BSDLCARemindmode = HUset_BSDLCARemindmode_;
		_rpc_request->data._u.RR_HU_BSDLCARemindmode.Requestinfo = Requestinfo;

		_rpc_request->data._d = carDrive_Basc_ADASCruiseSet_RR_HU_BSDLCARemindmode_Hash;
		ASF_LOG_DEBUG_ARGS("Basc_ADASCruiseSet_Proxy::RR_HU_BSDLCARemindmode pre async_call, hashId=[%d], reqId=[%d]", carDrive_Basc_ADASCruiseSet_RR_HU_BSDLCARemindmode_Hash, _rpc_client_sn.low);
		auto _rpc_future = com::changan::rpc_service::DDSClient::async_call(_rpc_client_sn.low, dds_rpc_request_handle.writer, _rpc_request);
		carDrive_Basc_ADASCruiseSet_Request_free(_rpc_request, DDS_FREE_ALL);

		auto _rpc_status = _rpc_future.wait_for(std::chrono::milliseconds(dds_rpc_time_out));
		if (_rpc_status == std::future_status::timeout ||
			_rpc_status == std::future_status::deferred) {
			_rpc_result.code = DDS_RPC_REMOTE_TIMEOUT_EXCEPTION;
			return _rpc_result;
		}
		auto sp =_rpc_future.get();
		auto _rpc_ret = (carDrive_Basc_ADASCruiseSet_Reply*)sp.get();

		_rpc_result.code = _rpc_ret->header.remoteEx;
		if (_rpc_result.code == DDS_RPC_REMOTE_EX_OK) {
			_rpc_result.data = _rpc_ret->data._u.RR_HU_BSDLCARemindmode.return_;
			_rpc_result.autoFreePtr = sp;
		}
		return _rpc_result;
	}
	Msg<ResponseInfo> Basc_ADASCruiseSet_Proxy::RR_HU_IACCFamlrRdModSwt(const HUset_IACCFamlrRdModSwt &HUset_IACCFamlrRdModSwt_,const RequestInfo &RequestInfo_, size_t dds_rpc_time_out) {
		Msg<ResponseInfo> _rpc_result;
		carDrive_Basc_ADASCruiseSet_Request* _rpc_request = carDrive_Basc_ADASCruiseSet_Request__alloc();

		dds_guid_t _temp_guid = { 0 };
		dds_return_t rc = dds_get_guid(dds_rpc_request_handle.writer, &_temp_guid);
		if (DDS_RETCODE_OK != rc)
		{
			ASF_LOG_ERROR_ARGS("Basc_ADASCruiseSet_Proxy::RR_HU_IACCFamlrRdModSwt dds_get_guid faild rc=[%d], writer=[%d]", rc, dds_rpc_request_handle.writer);
			_rpc_result.code = DDS_RPC_REMOTE_EX_UNSUPPORTED;
			return _rpc_result;
		}

		memcpy(&_rpc_request->header.requestId, &_temp_guid, sizeof(dds_guid_t));
		DDS_SequenceNumber_t _rpc_client_sn = com::changan::rpc_service::DDSClient::get_rpc_request_id();
		_rpc_request->header.requestId.sequence_number = _rpc_client_sn;
		_rpc_request->data._u.RR_HU_IACCFamlrRdModSwt.HUset_IACCFamlrRdModSwt = HUset_IACCFamlrRdModSwt_;
		_rpc_request->data._u.RR_HU_IACCFamlrRdModSwt.RequestInfo = RequestInfo_;

		_rpc_request->data._d = carDrive_Basc_ADASCruiseSet_RR_HU_IACCFamlrRdModSwt_Hash;
		ASF_LOG_DEBUG_ARGS("Basc_ADASCruiseSet_Proxy::RR_HU_IACCFamlrRdModSwt pre async_call, hashId=[%d], reqId=[%d]", carDrive_Basc_ADASCruiseSet_RR_HU_IACCFamlrRdModSwt_Hash, _rpc_client_sn.low);
		auto _rpc_future = com::changan::rpc_service::DDSClient::async_call(_rpc_client_sn.low, dds_rpc_request_handle.writer, _rpc_request);
		carDrive_Basc_ADASCruiseSet_Request_free(_rpc_request, DDS_FREE_ALL);

		auto _rpc_status = _rpc_future.wait_for(std::chrono::milliseconds(dds_rpc_time_out));
		if (_rpc_status == std::future_status::timeout ||
			_rpc_status == std::future_status::deferred) {
			_rpc_result.code = DDS_RPC_REMOTE_TIMEOUT_EXCEPTION;
			return _rpc_result;
		}
		auto sp =_rpc_future.get();
		auto _rpc_ret = (carDrive_Basc_ADASCruiseSet_Reply*)sp.get();

		_rpc_result.code = _rpc_ret->header.remoteEx;
		if (_rpc_result.code == DDS_RPC_REMOTE_EX_OK) {
			_rpc_result.data = _rpc_ret->data._u.RR_HU_IACCFamlrRdModSwt.return_;
			_rpc_result.autoFreePtr = sp;
		}
		return _rpc_result;
	}
	Msg<C2_IACCFamlrRdModSwtFbSet> Basc_ADASCruiseSet_Proxy::Get_C2_IACCFamlrRdModSwtFb( size_t dds_rpc_time_out) {
		Msg<C2_IACCFamlrRdModSwtFbSet> _rpc_result;
		carDrive_Basc_ADASCruiseSet_Request* _rpc_request = carDrive_Basc_ADASCruiseSet_Request__alloc();

		dds_guid_t _temp_guid = { 0 };
		dds_return_t rc = dds_get_guid(dds_rpc_request_handle.writer, &_temp_guid);
		if (DDS_RETCODE_OK != rc)
		{
			ASF_LOG_ERROR_ARGS("Basc_ADASCruiseSet_Proxy::Get_C2_IACCFamlrRdModSwtFb dds_get_guid faild rc=[%d], writer=[%d]", rc, dds_rpc_request_handle.writer);
			_rpc_result.code = DDS_RPC_REMOTE_EX_UNSUPPORTED;
			return _rpc_result;
		}

		memcpy(&_rpc_request->header.requestId, &_temp_guid, sizeof(dds_guid_t));
		DDS_SequenceNumber_t _rpc_client_sn = com::changan::rpc_service::DDSClient::get_rpc_request_id();
		_rpc_request->header.requestId.sequence_number = _rpc_client_sn;

		_rpc_request->data._d = carDrive_Basc_ADASCruiseSet_Get_C2_IACCFamlrRdModSwtFb_Hash;
		ASF_LOG_DEBUG_ARGS("Basc_ADASCruiseSet_Proxy::Get_C2_IACCFamlrRdModSwtFb pre async_call, hashId=[%d], reqId=[%d]", carDrive_Basc_ADASCruiseSet_Get_C2_IACCFamlrRdModSwtFb_Hash, _rpc_client_sn.low);
		auto _rpc_future = com::changan::rpc_service::DDSClient::async_call(_rpc_client_sn.low, dds_rpc_request_handle.writer, _rpc_request);
		carDrive_Basc_ADASCruiseSet_Request_free(_rpc_request, DDS_FREE_ALL);

		auto _rpc_status = _rpc_future.wait_for(std::chrono::milliseconds(dds_rpc_time_out));
		if (_rpc_status == std::future_status::timeout ||
			_rpc_status == std::future_status::deferred) {
			_rpc_result.code = DDS_RPC_REMOTE_TIMEOUT_EXCEPTION;
			return _rpc_result;
		}
		auto sp =_rpc_future.get();
		auto _rpc_ret = (carDrive_Basc_ADASCruiseSet_Reply*)sp.get();

		_rpc_result.code = _rpc_ret->header.remoteEx;
		if (_rpc_result.code == DDS_RPC_REMOTE_EX_OK) {
			_rpc_result.data = _rpc_ret->data._u.Get_C2_IACCFamlrRdModSwtFb.return_;
			_rpc_result.autoFreePtr = sp;
		}
		return _rpc_result;
	}
	Msg<AD_NIDSelfLrngFbset> Basc_ADASCruiseSet_Proxy::Get_AD_NIDSelfLrngFb( size_t dds_rpc_time_out) {
		Msg<AD_NIDSelfLrngFbset> _rpc_result;
		carDrive_Basc_ADASCruiseSet_Request* _rpc_request = carDrive_Basc_ADASCruiseSet_Request__alloc();

		dds_guid_t _temp_guid = { 0 };
		dds_return_t rc = dds_get_guid(dds_rpc_request_handle.writer, &_temp_guid);
		if (DDS_RETCODE_OK != rc)
		{
			ASF_LOG_ERROR_ARGS("Basc_ADASCruiseSet_Proxy::Get_AD_NIDSelfLrngFb dds_get_guid faild rc=[%d], writer=[%d]", rc, dds_rpc_request_handle.writer);
			_rpc_result.code = DDS_RPC_REMOTE_EX_UNSUPPORTED;
			return _rpc_result;
		}

		memcpy(&_rpc_request->header.requestId, &_temp_guid, sizeof(dds_guid_t));
		DDS_SequenceNumber_t _rpc_client_sn = com::changan::rpc_service::DDSClient::get_rpc_request_id();
		_rpc_request->header.requestId.sequence_number = _rpc_client_sn;

		_rpc_request->data._d = carDrive_Basc_ADASCruiseSet_Get_AD_NIDSelfLrngFb_Hash;
		ASF_LOG_DEBUG_ARGS("Basc_ADASCruiseSet_Proxy::Get_AD_NIDSelfLrngFb pre async_call, hashId=[%d], reqId=[%d]", carDrive_Basc_ADASCruiseSet_Get_AD_NIDSelfLrngFb_Hash, _rpc_client_sn.low);
		auto _rpc_future = com::changan::rpc_service::DDSClient::async_call(_rpc_client_sn.low, dds_rpc_request_handle.writer, _rpc_request);
		carDrive_Basc_ADASCruiseSet_Request_free(_rpc_request, DDS_FREE_ALL);

		auto _rpc_status = _rpc_future.wait_for(std::chrono::milliseconds(dds_rpc_time_out));
		if (_rpc_status == std::future_status::timeout ||
			_rpc_status == std::future_status::deferred) {
			_rpc_result.code = DDS_RPC_REMOTE_TIMEOUT_EXCEPTION;
			return _rpc_result;
		}
		auto sp =_rpc_future.get();
		auto _rpc_ret = (carDrive_Basc_ADASCruiseSet_Reply*)sp.get();

		_rpc_result.code = _rpc_ret->header.remoteEx;
		if (_rpc_result.code == DDS_RPC_REMOTE_EX_OK) {
			_rpc_result.data = _rpc_ret->data._u.Get_AD_NIDSelfLrngFb.return_;
			_rpc_result.autoFreePtr = sp;
		}
		return _rpc_result;
	}
	Msg<AD_NIDSelfLrngFbset> Basc_ADASCruiseSet_Proxy::RR_EDC_NIDSelfLrngReq(const EDCset_NIDSelfLrngReq &EDCset_NIDSelfLrngReq_,const RequestInfo &RequestInfo_, size_t dds_rpc_time_out) {
		Msg<AD_NIDSelfLrngFbset> _rpc_result;
		carDrive_Basc_ADASCruiseSet_Request* _rpc_request = carDrive_Basc_ADASCruiseSet_Request__alloc();

		dds_guid_t _temp_guid = { 0 };
		dds_return_t rc = dds_get_guid(dds_rpc_request_handle.writer, &_temp_guid);
		if (DDS_RETCODE_OK != rc)
		{
			ASF_LOG_ERROR_ARGS("Basc_ADASCruiseSet_Proxy::RR_EDC_NIDSelfLrngReq dds_get_guid faild rc=[%d], writer=[%d]", rc, dds_rpc_request_handle.writer);
			_rpc_result.code = DDS_RPC_REMOTE_EX_UNSUPPORTED;
			return _rpc_result;
		}

		memcpy(&_rpc_request->header.requestId, &_temp_guid, sizeof(dds_guid_t));
		DDS_SequenceNumber_t _rpc_client_sn = com::changan::rpc_service::DDSClient::get_rpc_request_id();
		_rpc_request->header.requestId.sequence_number = _rpc_client_sn;
		_rpc_request->data._u.RR_EDC_NIDSelfLrngReq.EDCset_NIDSelfLrngReq = EDCset_NIDSelfLrngReq_;
		_rpc_request->data._u.RR_EDC_NIDSelfLrngReq.RequestInfo = RequestInfo_;

		_rpc_request->data._d = carDrive_Basc_ADASCruiseSet_RR_EDC_NIDSelfLrngReq_Hash;
		ASF_LOG_DEBUG_ARGS("Basc_ADASCruiseSet_Proxy::RR_EDC_NIDSelfLrngReq pre async_call, hashId=[%d], reqId=[%d]", carDrive_Basc_ADASCruiseSet_RR_EDC_NIDSelfLrngReq_Hash, _rpc_client_sn.low);
		auto _rpc_future = com::changan::rpc_service::DDSClient::async_call(_rpc_client_sn.low, dds_rpc_request_handle.writer, _rpc_request);
		carDrive_Basc_ADASCruiseSet_Request_free(_rpc_request, DDS_FREE_ALL);

		auto _rpc_status = _rpc_future.wait_for(std::chrono::milliseconds(dds_rpc_time_out));
		if (_rpc_status == std::future_status::timeout ||
			_rpc_status == std::future_status::deferred) {
			_rpc_result.code = DDS_RPC_REMOTE_TIMEOUT_EXCEPTION;
			return _rpc_result;
		}
		auto sp =_rpc_future.get();
		auto _rpc_ret = (carDrive_Basc_ADASCruiseSet_Reply*)sp.get();

		_rpc_result.code = _rpc_ret->header.remoteEx;
		if (_rpc_result.code == DDS_RPC_REMOTE_EX_OK) {
			_rpc_result.data = _rpc_ret->data._u.RR_EDC_NIDSelfLrngReq.return_;
			_rpc_result.autoFreePtr = sp;
		}
		return _rpc_result;
	}
	Msg<AD_BSDLCAOnOffSet> Basc_ADASCruiseSet_Proxy::Get_AD_BSDLCAOnOffSet( size_t dds_rpc_time_out) {
		Msg<AD_BSDLCAOnOffSet> _rpc_result;
		carDrive_Basc_ADASCruiseSet_Request* _rpc_request = carDrive_Basc_ADASCruiseSet_Request__alloc();

		dds_guid_t _temp_guid = { 0 };
		dds_return_t rc = dds_get_guid(dds_rpc_request_handle.writer, &_temp_guid);
		if (DDS_RETCODE_OK != rc)
		{
			ASF_LOG_ERROR_ARGS("Basc_ADASCruiseSet_Proxy::Get_AD_BSDLCAOnOffSet dds_get_guid faild rc=[%d], writer=[%d]", rc, dds_rpc_request_handle.writer);
			_rpc_result.code = DDS_RPC_REMOTE_EX_UNSUPPORTED;
			return _rpc_result;
		}

		memcpy(&_rpc_request->header.requestId, &_temp_guid, sizeof(dds_guid_t));
		DDS_SequenceNumber_t _rpc_client_sn = com::changan::rpc_service::DDSClient::get_rpc_request_id();
		_rpc_request->header.requestId.sequence_number = _rpc_client_sn;

		_rpc_request->data._d = carDrive_Basc_ADASCruiseSet_Get_AD_BSDLCAOnOffSet_Hash;
		ASF_LOG_DEBUG_ARGS("Basc_ADASCruiseSet_Proxy::Get_AD_BSDLCAOnOffSet pre async_call, hashId=[%d], reqId=[%d]", carDrive_Basc_ADASCruiseSet_Get_AD_BSDLCAOnOffSet_Hash, _rpc_client_sn.low);
		auto _rpc_future = com::changan::rpc_service::DDSClient::async_call(_rpc_client_sn.low, dds_rpc_request_handle.writer, _rpc_request);
		carDrive_Basc_ADASCruiseSet_Request_free(_rpc_request, DDS_FREE_ALL);

		auto _rpc_status = _rpc_future.wait_for(std::chrono::milliseconds(dds_rpc_time_out));
		if (_rpc_status == std::future_status::timeout ||
			_rpc_status == std::future_status::deferred) {
			_rpc_result.code = DDS_RPC_REMOTE_TIMEOUT_EXCEPTION;
			return _rpc_result;
		}
		auto sp =_rpc_future.get();
		auto _rpc_ret = (carDrive_Basc_ADASCruiseSet_Reply*)sp.get();

		_rpc_result.code = _rpc_ret->header.remoteEx;
		if (_rpc_result.code == DDS_RPC_REMOTE_EX_OK) {
			_rpc_result.data = _rpc_ret->data._u.Get_AD_BSDLCAOnOffSet.return_;
			_rpc_result.autoFreePtr = sp;
		}
		return _rpc_result;
	}
	Msg<AD_BSDLCAOnOffSet> Basc_ADASCruiseSet_Proxy::RR_HU_BSDLCAOnOff(const HUset_BSDLCAOnOff &HUset_BSDLCAOnOff_,const RequestInfo &RequestInfo_, size_t dds_rpc_time_out) {
		Msg<AD_BSDLCAOnOffSet> _rpc_result;
		carDrive_Basc_ADASCruiseSet_Request* _rpc_request = carDrive_Basc_ADASCruiseSet_Request__alloc();

		dds_guid_t _temp_guid = { 0 };
		dds_return_t rc = dds_get_guid(dds_rpc_request_handle.writer, &_temp_guid);
		if (DDS_RETCODE_OK != rc)
		{
			ASF_LOG_ERROR_ARGS("Basc_ADASCruiseSet_Proxy::RR_HU_BSDLCAOnOff dds_get_guid faild rc=[%d], writer=[%d]", rc, dds_rpc_request_handle.writer);
			_rpc_result.code = DDS_RPC_REMOTE_EX_UNSUPPORTED;
			return _rpc_result;
		}

		memcpy(&_rpc_request->header.requestId, &_temp_guid, sizeof(dds_guid_t));
		DDS_SequenceNumber_t _rpc_client_sn = com::changan::rpc_service::DDSClient::get_rpc_request_id();
		_rpc_request->header.requestId.sequence_number = _rpc_client_sn;
		_rpc_request->data._u.RR_HU_BSDLCAOnOff.HUset_BSDLCAOnOff = HUset_BSDLCAOnOff_;
		_rpc_request->data._u.RR_HU_BSDLCAOnOff.RequestInfo = RequestInfo_;

		_rpc_request->data._d = carDrive_Basc_ADASCruiseSet_RR_HU_BSDLCAOnOff_Hash;
		ASF_LOG_DEBUG_ARGS("Basc_ADASCruiseSet_Proxy::RR_HU_BSDLCAOnOff pre async_call, hashId=[%d], reqId=[%d]", carDrive_Basc_ADASCruiseSet_RR_HU_BSDLCAOnOff_Hash, _rpc_client_sn.low);
		auto _rpc_future = com::changan::rpc_service::DDSClient::async_call(_rpc_client_sn.low, dds_rpc_request_handle.writer, _rpc_request);
		carDrive_Basc_ADASCruiseSet_Request_free(_rpc_request, DDS_FREE_ALL);

		auto _rpc_status = _rpc_future.wait_for(std::chrono::milliseconds(dds_rpc_time_out));
		if (_rpc_status == std::future_status::timeout ||
			_rpc_status == std::future_status::deferred) {
			_rpc_result.code = DDS_RPC_REMOTE_TIMEOUT_EXCEPTION;
			return _rpc_result;
		}
		auto sp =_rpc_future.get();
		auto _rpc_ret = (carDrive_Basc_ADASCruiseSet_Reply*)sp.get();

		_rpc_result.code = _rpc_ret->header.remoteEx;
		if (_rpc_result.code == DDS_RPC_REMOTE_EX_OK) {
			_rpc_result.data = _rpc_ret->data._u.RR_HU_BSDLCAOnOff.return_;
			_rpc_result.autoFreePtr = sp;
		}
		return _rpc_result;
	}
	Msg<AD_SEAOnOffStsSet> Basc_ADASCruiseSet_Proxy::Get_AD_SEAOnOffSts( size_t dds_rpc_time_out) {
		Msg<AD_SEAOnOffStsSet> _rpc_result;
		carDrive_Basc_ADASCruiseSet_Request* _rpc_request = carDrive_Basc_ADASCruiseSet_Request__alloc();

		dds_guid_t _temp_guid = { 0 };
		dds_return_t rc = dds_get_guid(dds_rpc_request_handle.writer, &_temp_guid);
		if (DDS_RETCODE_OK != rc)
		{
			ASF_LOG_ERROR_ARGS("Basc_ADASCruiseSet_Proxy::Get_AD_SEAOnOffSts dds_get_guid faild rc=[%d], writer=[%d]", rc, dds_rpc_request_handle.writer);
			_rpc_result.code = DDS_RPC_REMOTE_EX_UNSUPPORTED;
			return _rpc_result;
		}

		memcpy(&_rpc_request->header.requestId, &_temp_guid, sizeof(dds_guid_t));
		DDS_SequenceNumber_t _rpc_client_sn = com::changan::rpc_service::DDSClient::get_rpc_request_id();
		_rpc_request->header.requestId.sequence_number = _rpc_client_sn;

		_rpc_request->data._d = carDrive_Basc_ADASCruiseSet_Get_AD_SEAOnOffSts_Hash;
		ASF_LOG_DEBUG_ARGS("Basc_ADASCruiseSet_Proxy::Get_AD_SEAOnOffSts pre async_call, hashId=[%d], reqId=[%d]", carDrive_Basc_ADASCruiseSet_Get_AD_SEAOnOffSts_Hash, _rpc_client_sn.low);
		auto _rpc_future = com::changan::rpc_service::DDSClient::async_call(_rpc_client_sn.low, dds_rpc_request_handle.writer, _rpc_request);
		carDrive_Basc_ADASCruiseSet_Request_free(_rpc_request, DDS_FREE_ALL);

		auto _rpc_status = _rpc_future.wait_for(std::chrono::milliseconds(dds_rpc_time_out));
		if (_rpc_status == std::future_status::timeout ||
			_rpc_status == std::future_status::deferred) {
			_rpc_result.code = DDS_RPC_REMOTE_TIMEOUT_EXCEPTION;
			return _rpc_result;
		}
		auto sp =_rpc_future.get();
		auto _rpc_ret = (carDrive_Basc_ADASCruiseSet_Reply*)sp.get();

		_rpc_result.code = _rpc_ret->header.remoteEx;
		if (_rpc_result.code == DDS_RPC_REMOTE_EX_OK) {
			_rpc_result.data = _rpc_ret->data._u.Get_AD_SEAOnOffSts.return_;
			_rpc_result.autoFreePtr = sp;
		}
		return _rpc_result;
	}
	Msg<AD_SEAOnOffStsSet> Basc_ADASCruiseSet_Proxy::RR_HU_SEAOnOff(const HUset_SEAOnOff &HUset_SEAOnOff_,const RequestInfo &RequestInfo_, size_t dds_rpc_time_out) {
		Msg<AD_SEAOnOffStsSet> _rpc_result;
		carDrive_Basc_ADASCruiseSet_Request* _rpc_request = carDrive_Basc_ADASCruiseSet_Request__alloc();

		dds_guid_t _temp_guid = { 0 };
		dds_return_t rc = dds_get_guid(dds_rpc_request_handle.writer, &_temp_guid);
		if (DDS_RETCODE_OK != rc)
		{
			ASF_LOG_ERROR_ARGS("Basc_ADASCruiseSet_Proxy::RR_HU_SEAOnOff dds_get_guid faild rc=[%d], writer=[%d]", rc, dds_rpc_request_handle.writer);
			_rpc_result.code = DDS_RPC_REMOTE_EX_UNSUPPORTED;
			return _rpc_result;
		}

		memcpy(&_rpc_request->header.requestId, &_temp_guid, sizeof(dds_guid_t));
		DDS_SequenceNumber_t _rpc_client_sn = com::changan::rpc_service::DDSClient::get_rpc_request_id();
		_rpc_request->header.requestId.sequence_number = _rpc_client_sn;
		_rpc_request->data._u.RR_HU_SEAOnOff.HUset_SEAOnOff = HUset_SEAOnOff_;
		_rpc_request->data._u.RR_HU_SEAOnOff.RequestInfo = RequestInfo_;

		_rpc_request->data._d = carDrive_Basc_ADASCruiseSet_RR_HU_SEAOnOff_Hash;
		ASF_LOG_DEBUG_ARGS("Basc_ADASCruiseSet_Proxy::RR_HU_SEAOnOff pre async_call, hashId=[%d], reqId=[%d]", carDrive_Basc_ADASCruiseSet_RR_HU_SEAOnOff_Hash, _rpc_client_sn.low);
		auto _rpc_future = com::changan::rpc_service::DDSClient::async_call(_rpc_client_sn.low, dds_rpc_request_handle.writer, _rpc_request);
		carDrive_Basc_ADASCruiseSet_Request_free(_rpc_request, DDS_FREE_ALL);

		auto _rpc_status = _rpc_future.wait_for(std::chrono::milliseconds(dds_rpc_time_out));
		if (_rpc_status == std::future_status::timeout ||
			_rpc_status == std::future_status::deferred) {
			_rpc_result.code = DDS_RPC_REMOTE_TIMEOUT_EXCEPTION;
			return _rpc_result;
		}
		auto sp =_rpc_future.get();
		auto _rpc_ret = (carDrive_Basc_ADASCruiseSet_Reply*)sp.get();

		_rpc_result.code = _rpc_ret->header.remoteEx;
		if (_rpc_result.code == DDS_RPC_REMOTE_EX_OK) {
			_rpc_result.data = _rpc_ret->data._u.RR_HU_SEAOnOff.return_;
			_rpc_result.autoFreePtr = sp;
		}
		return _rpc_result;
	}
    Basc_ADASCruiseSet_Proxy::~Basc_ADASCruiseSet_Proxy(){

    }

	Basc_ADASCruiseSet_Proxy& Basc_ADASCruiseSet_Proxy::get_instance()
	{
		static Basc_ADASCruiseSet_Proxy instance;
		return instance;
	}
}
}
}
}
}


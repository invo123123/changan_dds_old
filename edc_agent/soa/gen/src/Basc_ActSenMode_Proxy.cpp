/****************************************************************
  Generated by ChangAn Code Generator,Do Not Modify
  AppVersion： mADC_Application_Service-V1.5
  CmVersion： v2.0.3
  ServiceVersion: V1.1.6
  ServiceLatestModifyTime: 2023-10-07T15:03:14
  Generate Time: 2023-12-11 18:07:59
*****************************************************************/
#include "changan/Basc_ActSenMode_Proxy.hpp"
#include <string.h>
#include "dds/ddsrt/sync.h"
#include <iostream>
#include "changan/string_util.hpp"
#include "changan/dds_client.hpp"
namespace com {
namespace changan {
namespace carCabin {
namespace BasicService {
namespace proxy {
    using namespace com::changan::rpc_service;
    using namespace com::changan::soa_log::skeleton;
    void Basc_ActSenMode_Ntf_ActSenMoSwitSt_trigger(carCabin_Basc_ActSenMode_Ntf* notify_data){
	    Basc_ActSenMode_Proxy::get_instance().Ntf_ActSenMoSwitSt.trigger(notify_data->data._u.Basc_ActSenMode_Ntf_ActSenMoSwitSt);
		carCabin_Basc_ActSenMode_Ntf_free(notify_data, DDS_FREE_ALL);
    }
    void Basc_ActSenMode_Ntf_ActSenFunEnSt_trigger(carCabin_Basc_ActSenMode_Ntf* notify_data){
	    Basc_ActSenMode_Proxy::get_instance().Ntf_ActSenFunEnSt.trigger(notify_data->data._u.Basc_ActSenMode_Ntf_ActSenFunEnSt);
		carCabin_Basc_ActSenMode_Ntf_free(notify_data, DDS_FREE_ALL);
    }
    void Basc_ActSenMode_Ntf__ActSenMoInfoSet_trigger(carCabin_Basc_ActSenMode_Ntf* notify_data){
	    Basc_ActSenMode_Proxy::get_instance().Ntf__ActSenMoInfoSet.trigger(notify_data->data._u.Basc_ActSenMode_Ntf__ActSenMoInfoSet);
		carCabin_Basc_ActSenMode_Ntf_free(notify_data, DDS_FREE_ALL);
    }
    void Basc_ActSenMode_Ntf_UserNotiConfir_trigger(carCabin_Basc_ActSenMode_Ntf* notify_data){
	    Basc_ActSenMode_Proxy::get_instance().Ntf_UserNotiConfir.trigger(notify_data->data._u.Basc_ActSenMode_Ntf_UserNotiConfir);
		carCabin_Basc_ActSenMode_Ntf_free(notify_data, DDS_FREE_ALL);
    }
    void Basc_ActSenMode_Ntf_ActSenTrig_trigger(carCabin_Basc_ActSenMode_Ntf* notify_data){
	    Basc_ActSenMode_Proxy::get_instance().Ntf_ActSenTrig.trigger(notify_data->data._u.Basc_ActSenMode_Ntf_ActSenTrig);
		carCabin_Basc_ActSenMode_Ntf_free(notify_data, DDS_FREE_ALL);
    }
    void Basc_ActSenMode_Ntf_ActSenFunEn_trigger(carCabin_Basc_ActSenMode_Ntf* notify_data){
	    Basc_ActSenMode_Proxy::get_instance().Ntf_ActSenFunEn.trigger(notify_data->data._u.Basc_ActSenMode_Ntf_ActSenFunEn);
		carCabin_Basc_ActSenMode_Ntf_free(notify_data, DDS_FREE_ALL);
    }
    void Basc_ActSenMode_Ntf_SdcardSenErrTrig_trigger(carCabin_Basc_ActSenMode_Ntf* notify_data){
	    Basc_ActSenMode_Proxy::get_instance().Ntf_SdcardSenErrTrig.trigger(notify_data->data._u.Basc_ActSenMode_Ntf_SdcardSenErrTrig);
		carCabin_Basc_ActSenMode_Ntf_free(notify_data, DDS_FREE_ALL);
    }
    void Basc_ActSenMode_Ntf_ActCampSwitSet_trigger(carCabin_Basc_ActSenMode_Ntf* notify_data){
	    Basc_ActSenMode_Proxy::get_instance().Ntf_ActCampSwitSet.trigger(notify_data->data._u.Basc_ActSenMode_Ntf_ActCampSwitSet);
		carCabin_Basc_ActSenMode_Ntf_free(notify_data, DDS_FREE_ALL);
    }
    void Basc_ActSenMode_Ntf_CampRangeSet_trigger(carCabin_Basc_ActSenMode_Ntf* notify_data){
	    Basc_ActSenMode_Proxy::get_instance().Ntf_CampRangeSet.trigger(notify_data->data._u.Basc_ActSenMode_Ntf_CampRangeSet);
		carCabin_Basc_ActSenMode_Ntf_free(notify_data, DDS_FREE_ALL);
    }
    void Basc_ActSenMode_Ntf_SenWarningSetSwitchEarly_trigger(carCabin_Basc_ActSenMode_Ntf* notify_data){
	    Basc_ActSenMode_Proxy::get_instance().Ntf_SenWarningSetSwitchEarly.trigger(notify_data->data._u.Basc_ActSenMode_Ntf_SenWarningSetSwitchEarly);
		carCabin_Basc_ActSenMode_Ntf_free(notify_data, DDS_FREE_ALL);
    }
    void Basc_ActSenMode_Ntf_SenWarningSetSwitchCollision_trigger(carCabin_Basc_ActSenMode_Ntf* notify_data){
	    Basc_ActSenMode_Proxy::get_instance().Ntf_SenWarningSetSwitchCollision.trigger(notify_data->data._u.Basc_ActSenMode_Ntf_SenWarningSetSwitchCollision);
		carCabin_Basc_ActSenMode_Ntf_free(notify_data, DDS_FREE_ALL);
    }
    void Basc_ActSenMode_Ntf_SenWarningSetSwitchTheft_trigger(carCabin_Basc_ActSenMode_Ntf* notify_data){
	    Basc_ActSenMode_Proxy::get_instance().Ntf_SenWarningSetSwitchTheft.trigger(notify_data->data._u.Basc_ActSenMode_Ntf_SenWarningSetSwitchTheft);
		carCabin_Basc_ActSenMode_Ntf_free(notify_data, DDS_FREE_ALL);
    }
    void Basc_ActSenMode_Ntf_CampWarningSetSwitchS_trigger(carCabin_Basc_ActSenMode_Ntf* notify_data){
	    Basc_ActSenMode_Proxy::get_instance().Ntf_CampWarningSetSwitchS.trigger(notify_data->data._u.Basc_ActSenMode_Ntf_CampWarningSetSwitchS);
		carCabin_Basc_ActSenMode_Ntf_free(notify_data, DDS_FREE_ALL);
    }
    void Basc_ActSenMode_Ntf_CampWarningSetSwitchM_trigger(carCabin_Basc_ActSenMode_Ntf* notify_data){
	    Basc_ActSenMode_Proxy::get_instance().Ntf_CampWarningSetSwitchM.trigger(notify_data->data._u.Basc_ActSenMode_Ntf_CampWarningSetSwitchM);
		carCabin_Basc_ActSenMode_Ntf_free(notify_data, DDS_FREE_ALL);
    }
    void Basc_ActSenMode_Ntf_CampWarningSetSwitchL_trigger(carCabin_Basc_ActSenMode_Ntf* notify_data){
	    Basc_ActSenMode_Proxy::get_instance().Ntf_CampWarningSetSwitchL.trigger(notify_data->data._u.Basc_ActSenMode_Ntf_CampWarningSetSwitchL);
		carCabin_Basc_ActSenMode_Ntf_free(notify_data, DDS_FREE_ALL);
    }
    void Basc_ActSenMode_Ntf_SenRecordCameraSet_trigger(carCabin_Basc_ActSenMode_Ntf* notify_data){
	    Basc_ActSenMode_Proxy::get_instance().Ntf_SenRecordCameraSet.trigger(notify_data->data._u.Basc_ActSenMode_Ntf_SenRecordCameraSet);
		carCabin_Basc_ActSenMode_Ntf_free(notify_data, DDS_FREE_ALL);
    }
    void Basc_ActSenMode_Ntf_CampRecordCameraSet_trigger(carCabin_Basc_ActSenMode_Ntf* notify_data){
	    Basc_ActSenMode_Proxy::get_instance().Ntf_CampRecordCameraSet.trigger(notify_data->data._u.Basc_ActSenMode_Ntf_CampRecordCameraSet);
		carCabin_Basc_ActSenMode_Ntf_free(notify_data, DDS_FREE_ALL);
    }
    void Basc_ActSenMode_Ntf_ActCampTrig_trigger(carCabin_Basc_ActSenMode_Ntf* notify_data){
	    Basc_ActSenMode_Proxy::get_instance().Ntf_ActCampTrig.trigger(notify_data->data._u.Basc_ActSenMode_Ntf_ActCampTrig);
		carCabin_Basc_ActSenMode_Ntf_free(notify_data, DDS_FREE_ALL);
    }
    void on_Basc_ActSenMode_Ntf_ActSenMoSwitSt_data_available(int32_t reader, void* arg){
        ASF_LOG_DEBUG_ARGS("on_Basc_ActSenMode_Ntf_ActSenMoSwitSt_data_available");
    	dds_return_t rc;
		carCabin_Basc_ActSenMode_Ntf* data;
		void* samples[1];
		samples[0] = carCabin_Basc_ActSenMode_Ntf__alloc();
		dds_sample_info_t infos[1];
		rc = dds_take_next(reader, samples, infos);
		if (rc < 0){
			ASF_LOG_ERROR_ARGS("on_Basc_ActSenMode_Ntf_ActSenMoSwitSt_data_available dds_take_next faild rc=[%d]", rc);
			//printf("dds_take_next failed!\n");
        }
		if (infos[0].valid_data){
            data = (carCabin_Basc_ActSenMode_Ntf*)samples[0];
            ASF_LOG_DEBUG_ARGS("on_Basc_ActSenMode_Ntf_ActSenMoSwitSt_data_available, hashId=[%d]", data->data._d);
			DDSClient::execute(Basc_ActSenMode_Ntf_ActSenMoSwitSt_trigger,data);
			return;
		}
		carCabin_Basc_ActSenMode_Ntf_free(samples[0],DDS_FREE_ALL);
	}
    void on_Basc_ActSenMode_Ntf_ActSenFunEnSt_data_available(int32_t reader, void* arg){
        ASF_LOG_DEBUG_ARGS("on_Basc_ActSenMode_Ntf_ActSenFunEnSt_data_available");
    	dds_return_t rc;
		carCabin_Basc_ActSenMode_Ntf* data;
		void* samples[1];
		samples[0] = carCabin_Basc_ActSenMode_Ntf__alloc();
		dds_sample_info_t infos[1];
		rc = dds_take_next(reader, samples, infos);
		if (rc < 0){
			ASF_LOG_ERROR_ARGS("on_Basc_ActSenMode_Ntf_ActSenFunEnSt_data_available dds_take_next faild rc=[%d]", rc);
			//printf("dds_take_next failed!\n");
        }
		if (infos[0].valid_data){
            data = (carCabin_Basc_ActSenMode_Ntf*)samples[0];
            ASF_LOG_DEBUG_ARGS("on_Basc_ActSenMode_Ntf_ActSenFunEnSt_data_available, hashId=[%d]", data->data._d);
			DDSClient::execute(Basc_ActSenMode_Ntf_ActSenFunEnSt_trigger,data);
			return;
		}
		carCabin_Basc_ActSenMode_Ntf_free(samples[0],DDS_FREE_ALL);
	}
    void on_Basc_ActSenMode_Ntf__ActSenMoInfoSet_data_available(int32_t reader, void* arg){
        ASF_LOG_DEBUG_ARGS("on_Basc_ActSenMode_Ntf__ActSenMoInfoSet_data_available");
    	dds_return_t rc;
		carCabin_Basc_ActSenMode_Ntf* data;
		void* samples[1];
		samples[0] = carCabin_Basc_ActSenMode_Ntf__alloc();
		dds_sample_info_t infos[1];
		rc = dds_take_next(reader, samples, infos);
		if (rc < 0){
			ASF_LOG_ERROR_ARGS("on_Basc_ActSenMode_Ntf__ActSenMoInfoSet_data_available dds_take_next faild rc=[%d]", rc);
			//printf("dds_take_next failed!\n");
        }
		if (infos[0].valid_data){
            data = (carCabin_Basc_ActSenMode_Ntf*)samples[0];
            ASF_LOG_DEBUG_ARGS("on_Basc_ActSenMode_Ntf__ActSenMoInfoSet_data_available, hashId=[%d]", data->data._d);
			DDSClient::execute(Basc_ActSenMode_Ntf__ActSenMoInfoSet_trigger,data);
			return;
		}
		carCabin_Basc_ActSenMode_Ntf_free(samples[0],DDS_FREE_ALL);
	}
    void on_Basc_ActSenMode_Ntf_UserNotiConfir_data_available(int32_t reader, void* arg){
        ASF_LOG_DEBUG_ARGS("on_Basc_ActSenMode_Ntf_UserNotiConfir_data_available");
    	dds_return_t rc;
		carCabin_Basc_ActSenMode_Ntf* data;
		void* samples[1];
		samples[0] = carCabin_Basc_ActSenMode_Ntf__alloc();
		dds_sample_info_t infos[1];
		rc = dds_take_next(reader, samples, infos);
		if (rc < 0){
			ASF_LOG_ERROR_ARGS("on_Basc_ActSenMode_Ntf_UserNotiConfir_data_available dds_take_next faild rc=[%d]", rc);
			//printf("dds_take_next failed!\n");
        }
		if (infos[0].valid_data){
            data = (carCabin_Basc_ActSenMode_Ntf*)samples[0];
            ASF_LOG_DEBUG_ARGS("on_Basc_ActSenMode_Ntf_UserNotiConfir_data_available, hashId=[%d]", data->data._d);
			DDSClient::execute(Basc_ActSenMode_Ntf_UserNotiConfir_trigger,data);
			return;
		}
		carCabin_Basc_ActSenMode_Ntf_free(samples[0],DDS_FREE_ALL);
	}
    void on_Basc_ActSenMode_Ntf_ActSenTrig_data_available(int32_t reader, void* arg){
        ASF_LOG_DEBUG_ARGS("on_Basc_ActSenMode_Ntf_ActSenTrig_data_available");
    	dds_return_t rc;
		carCabin_Basc_ActSenMode_Ntf* data;
		void* samples[1];
		samples[0] = carCabin_Basc_ActSenMode_Ntf__alloc();
		dds_sample_info_t infos[1];
		rc = dds_take_next(reader, samples, infos);
		if (rc < 0){
			ASF_LOG_ERROR_ARGS("on_Basc_ActSenMode_Ntf_ActSenTrig_data_available dds_take_next faild rc=[%d]", rc);
			//printf("dds_take_next failed!\n");
        }
		if (infos[0].valid_data){
            data = (carCabin_Basc_ActSenMode_Ntf*)samples[0];
            ASF_LOG_DEBUG_ARGS("on_Basc_ActSenMode_Ntf_ActSenTrig_data_available, hashId=[%d]", data->data._d);
			DDSClient::execute(Basc_ActSenMode_Ntf_ActSenTrig_trigger,data);
			return;
		}
		carCabin_Basc_ActSenMode_Ntf_free(samples[0],DDS_FREE_ALL);
	}
    void on_Basc_ActSenMode_Ntf_ActSenFunEn_data_available(int32_t reader, void* arg){
        ASF_LOG_DEBUG_ARGS("on_Basc_ActSenMode_Ntf_ActSenFunEn_data_available");
    	dds_return_t rc;
		carCabin_Basc_ActSenMode_Ntf* data;
		void* samples[1];
		samples[0] = carCabin_Basc_ActSenMode_Ntf__alloc();
		dds_sample_info_t infos[1];
		rc = dds_take_next(reader, samples, infos);
		if (rc < 0){
			ASF_LOG_ERROR_ARGS("on_Basc_ActSenMode_Ntf_ActSenFunEn_data_available dds_take_next faild rc=[%d]", rc);
			//printf("dds_take_next failed!\n");
        }
		if (infos[0].valid_data){
            data = (carCabin_Basc_ActSenMode_Ntf*)samples[0];
            ASF_LOG_DEBUG_ARGS("on_Basc_ActSenMode_Ntf_ActSenFunEn_data_available, hashId=[%d]", data->data._d);
			DDSClient::execute(Basc_ActSenMode_Ntf_ActSenFunEn_trigger,data);
			return;
		}
		carCabin_Basc_ActSenMode_Ntf_free(samples[0],DDS_FREE_ALL);
	}
    void on_Basc_ActSenMode_Ntf_SdcardSenErrTrig_data_available(int32_t reader, void* arg){
        ASF_LOG_DEBUG_ARGS("on_Basc_ActSenMode_Ntf_SdcardSenErrTrig_data_available");
    	dds_return_t rc;
		carCabin_Basc_ActSenMode_Ntf* data;
		void* samples[1];
		samples[0] = carCabin_Basc_ActSenMode_Ntf__alloc();
		dds_sample_info_t infos[1];
		rc = dds_take_next(reader, samples, infos);
		if (rc < 0){
			ASF_LOG_ERROR_ARGS("on_Basc_ActSenMode_Ntf_SdcardSenErrTrig_data_available dds_take_next faild rc=[%d]", rc);
			//printf("dds_take_next failed!\n");
        }
		if (infos[0].valid_data){
            data = (carCabin_Basc_ActSenMode_Ntf*)samples[0];
            ASF_LOG_DEBUG_ARGS("on_Basc_ActSenMode_Ntf_SdcardSenErrTrig_data_available, hashId=[%d]", data->data._d);
			DDSClient::execute(Basc_ActSenMode_Ntf_SdcardSenErrTrig_trigger,data);
			return;
		}
		carCabin_Basc_ActSenMode_Ntf_free(samples[0],DDS_FREE_ALL);
	}
    void on_Basc_ActSenMode_Ntf_ActCampSwitSet_data_available(int32_t reader, void* arg){
        ASF_LOG_DEBUG_ARGS("on_Basc_ActSenMode_Ntf_ActCampSwitSet_data_available");
    	dds_return_t rc;
		carCabin_Basc_ActSenMode_Ntf* data;
		void* samples[1];
		samples[0] = carCabin_Basc_ActSenMode_Ntf__alloc();
		dds_sample_info_t infos[1];
		rc = dds_take_next(reader, samples, infos);
		if (rc < 0){
			ASF_LOG_ERROR_ARGS("on_Basc_ActSenMode_Ntf_ActCampSwitSet_data_available dds_take_next faild rc=[%d]", rc);
			//printf("dds_take_next failed!\n");
        }
		if (infos[0].valid_data){
            data = (carCabin_Basc_ActSenMode_Ntf*)samples[0];
            ASF_LOG_DEBUG_ARGS("on_Basc_ActSenMode_Ntf_ActCampSwitSet_data_available, hashId=[%d]", data->data._d);
			DDSClient::execute(Basc_ActSenMode_Ntf_ActCampSwitSet_trigger,data);
			return;
		}
		carCabin_Basc_ActSenMode_Ntf_free(samples[0],DDS_FREE_ALL);
	}
    void on_Basc_ActSenMode_Ntf_CampRangeSet_data_available(int32_t reader, void* arg){
        ASF_LOG_DEBUG_ARGS("on_Basc_ActSenMode_Ntf_CampRangeSet_data_available");
    	dds_return_t rc;
		carCabin_Basc_ActSenMode_Ntf* data;
		void* samples[1];
		samples[0] = carCabin_Basc_ActSenMode_Ntf__alloc();
		dds_sample_info_t infos[1];
		rc = dds_take_next(reader, samples, infos);
		if (rc < 0){
			ASF_LOG_ERROR_ARGS("on_Basc_ActSenMode_Ntf_CampRangeSet_data_available dds_take_next faild rc=[%d]", rc);
			//printf("dds_take_next failed!\n");
        }
		if (infos[0].valid_data){
            data = (carCabin_Basc_ActSenMode_Ntf*)samples[0];
            ASF_LOG_DEBUG_ARGS("on_Basc_ActSenMode_Ntf_CampRangeSet_data_available, hashId=[%d]", data->data._d);
			DDSClient::execute(Basc_ActSenMode_Ntf_CampRangeSet_trigger,data);
			return;
		}
		carCabin_Basc_ActSenMode_Ntf_free(samples[0],DDS_FREE_ALL);
	}
    void on_Basc_ActSenMode_Ntf_SenWarningSetSwitchEarly_data_available(int32_t reader, void* arg){
        ASF_LOG_DEBUG_ARGS("on_Basc_ActSenMode_Ntf_SenWarningSetSwitchEarly_data_available");
    	dds_return_t rc;
		carCabin_Basc_ActSenMode_Ntf* data;
		void* samples[1];
		samples[0] = carCabin_Basc_ActSenMode_Ntf__alloc();
		dds_sample_info_t infos[1];
		rc = dds_take_next(reader, samples, infos);
		if (rc < 0){
			ASF_LOG_ERROR_ARGS("on_Basc_ActSenMode_Ntf_SenWarningSetSwitchEarly_data_available dds_take_next faild rc=[%d]", rc);
			//printf("dds_take_next failed!\n");
        }
		if (infos[0].valid_data){
            data = (carCabin_Basc_ActSenMode_Ntf*)samples[0];
            ASF_LOG_DEBUG_ARGS("on_Basc_ActSenMode_Ntf_SenWarningSetSwitchEarly_data_available, hashId=[%d]", data->data._d);
			DDSClient::execute(Basc_ActSenMode_Ntf_SenWarningSetSwitchEarly_trigger,data);
			return;
		}
		carCabin_Basc_ActSenMode_Ntf_free(samples[0],DDS_FREE_ALL);
	}
    void on_Basc_ActSenMode_Ntf_SenWarningSetSwitchCollision_data_available(int32_t reader, void* arg){
        ASF_LOG_DEBUG_ARGS("on_Basc_ActSenMode_Ntf_SenWarningSetSwitchCollision_data_available");
    	dds_return_t rc;
		carCabin_Basc_ActSenMode_Ntf* data;
		void* samples[1];
		samples[0] = carCabin_Basc_ActSenMode_Ntf__alloc();
		dds_sample_info_t infos[1];
		rc = dds_take_next(reader, samples, infos);
		if (rc < 0){
			ASF_LOG_ERROR_ARGS("on_Basc_ActSenMode_Ntf_SenWarningSetSwitchCollision_data_available dds_take_next faild rc=[%d]", rc);
			//printf("dds_take_next failed!\n");
        }
		if (infos[0].valid_data){
            data = (carCabin_Basc_ActSenMode_Ntf*)samples[0];
            ASF_LOG_DEBUG_ARGS("on_Basc_ActSenMode_Ntf_SenWarningSetSwitchCollision_data_available, hashId=[%d]", data->data._d);
			DDSClient::execute(Basc_ActSenMode_Ntf_SenWarningSetSwitchCollision_trigger,data);
			return;
		}
		carCabin_Basc_ActSenMode_Ntf_free(samples[0],DDS_FREE_ALL);
	}
    void on_Basc_ActSenMode_Ntf_SenWarningSetSwitchTheft_data_available(int32_t reader, void* arg){
        ASF_LOG_DEBUG_ARGS("on_Basc_ActSenMode_Ntf_SenWarningSetSwitchTheft_data_available");
    	dds_return_t rc;
		carCabin_Basc_ActSenMode_Ntf* data;
		void* samples[1];
		samples[0] = carCabin_Basc_ActSenMode_Ntf__alloc();
		dds_sample_info_t infos[1];
		rc = dds_take_next(reader, samples, infos);
		if (rc < 0){
			ASF_LOG_ERROR_ARGS("on_Basc_ActSenMode_Ntf_SenWarningSetSwitchTheft_data_available dds_take_next faild rc=[%d]", rc);
			//printf("dds_take_next failed!\n");
        }
		if (infos[0].valid_data){
            data = (carCabin_Basc_ActSenMode_Ntf*)samples[0];
            ASF_LOG_DEBUG_ARGS("on_Basc_ActSenMode_Ntf_SenWarningSetSwitchTheft_data_available, hashId=[%d]", data->data._d);
			DDSClient::execute(Basc_ActSenMode_Ntf_SenWarningSetSwitchTheft_trigger,data);
			return;
		}
		carCabin_Basc_ActSenMode_Ntf_free(samples[0],DDS_FREE_ALL);
	}
    void on_Basc_ActSenMode_Ntf_CampWarningSetSwitchS_data_available(int32_t reader, void* arg){
        ASF_LOG_DEBUG_ARGS("on_Basc_ActSenMode_Ntf_CampWarningSetSwitchS_data_available");
    	dds_return_t rc;
		carCabin_Basc_ActSenMode_Ntf* data;
		void* samples[1];
		samples[0] = carCabin_Basc_ActSenMode_Ntf__alloc();
		dds_sample_info_t infos[1];
		rc = dds_take_next(reader, samples, infos);
		if (rc < 0){
			ASF_LOG_ERROR_ARGS("on_Basc_ActSenMode_Ntf_CampWarningSetSwitchS_data_available dds_take_next faild rc=[%d]", rc);
			//printf("dds_take_next failed!\n");
        }
		if (infos[0].valid_data){
            data = (carCabin_Basc_ActSenMode_Ntf*)samples[0];
            ASF_LOG_DEBUG_ARGS("on_Basc_ActSenMode_Ntf_CampWarningSetSwitchS_data_available, hashId=[%d]", data->data._d);
			DDSClient::execute(Basc_ActSenMode_Ntf_CampWarningSetSwitchS_trigger,data);
			return;
		}
		carCabin_Basc_ActSenMode_Ntf_free(samples[0],DDS_FREE_ALL);
	}
    void on_Basc_ActSenMode_Ntf_CampWarningSetSwitchM_data_available(int32_t reader, void* arg){
        ASF_LOG_DEBUG_ARGS("on_Basc_ActSenMode_Ntf_CampWarningSetSwitchM_data_available");
    	dds_return_t rc;
		carCabin_Basc_ActSenMode_Ntf* data;
		void* samples[1];
		samples[0] = carCabin_Basc_ActSenMode_Ntf__alloc();
		dds_sample_info_t infos[1];
		rc = dds_take_next(reader, samples, infos);
		if (rc < 0){
			ASF_LOG_ERROR_ARGS("on_Basc_ActSenMode_Ntf_CampWarningSetSwitchM_data_available dds_take_next faild rc=[%d]", rc);
			//printf("dds_take_next failed!\n");
        }
		if (infos[0].valid_data){
            data = (carCabin_Basc_ActSenMode_Ntf*)samples[0];
            ASF_LOG_DEBUG_ARGS("on_Basc_ActSenMode_Ntf_CampWarningSetSwitchM_data_available, hashId=[%d]", data->data._d);
			DDSClient::execute(Basc_ActSenMode_Ntf_CampWarningSetSwitchM_trigger,data);
			return;
		}
		carCabin_Basc_ActSenMode_Ntf_free(samples[0],DDS_FREE_ALL);
	}
    void on_Basc_ActSenMode_Ntf_CampWarningSetSwitchL_data_available(int32_t reader, void* arg){
        ASF_LOG_DEBUG_ARGS("on_Basc_ActSenMode_Ntf_CampWarningSetSwitchL_data_available");
    	dds_return_t rc;
		carCabin_Basc_ActSenMode_Ntf* data;
		void* samples[1];
		samples[0] = carCabin_Basc_ActSenMode_Ntf__alloc();
		dds_sample_info_t infos[1];
		rc = dds_take_next(reader, samples, infos);
		if (rc < 0){
			ASF_LOG_ERROR_ARGS("on_Basc_ActSenMode_Ntf_CampWarningSetSwitchL_data_available dds_take_next faild rc=[%d]", rc);
			//printf("dds_take_next failed!\n");
        }
		if (infos[0].valid_data){
            data = (carCabin_Basc_ActSenMode_Ntf*)samples[0];
            ASF_LOG_DEBUG_ARGS("on_Basc_ActSenMode_Ntf_CampWarningSetSwitchL_data_available, hashId=[%d]", data->data._d);
			DDSClient::execute(Basc_ActSenMode_Ntf_CampWarningSetSwitchL_trigger,data);
			return;
		}
		carCabin_Basc_ActSenMode_Ntf_free(samples[0],DDS_FREE_ALL);
	}
    void on_Basc_ActSenMode_Ntf_SenRecordCameraSet_data_available(int32_t reader, void* arg){
        ASF_LOG_DEBUG_ARGS("on_Basc_ActSenMode_Ntf_SenRecordCameraSet_data_available");
    	dds_return_t rc;
		carCabin_Basc_ActSenMode_Ntf* data;
		void* samples[1];
		samples[0] = carCabin_Basc_ActSenMode_Ntf__alloc();
		dds_sample_info_t infos[1];
		rc = dds_take_next(reader, samples, infos);
		if (rc < 0){
			ASF_LOG_ERROR_ARGS("on_Basc_ActSenMode_Ntf_SenRecordCameraSet_data_available dds_take_next faild rc=[%d]", rc);
			//printf("dds_take_next failed!\n");
        }
		if (infos[0].valid_data){
            data = (carCabin_Basc_ActSenMode_Ntf*)samples[0];
            ASF_LOG_DEBUG_ARGS("on_Basc_ActSenMode_Ntf_SenRecordCameraSet_data_available, hashId=[%d]", data->data._d);
			DDSClient::execute(Basc_ActSenMode_Ntf_SenRecordCameraSet_trigger,data);
			return;
		}
		carCabin_Basc_ActSenMode_Ntf_free(samples[0],DDS_FREE_ALL);
	}
    void on_Basc_ActSenMode_Ntf_CampRecordCameraSet_data_available(int32_t reader, void* arg){
        ASF_LOG_DEBUG_ARGS("on_Basc_ActSenMode_Ntf_CampRecordCameraSet_data_available");
    	dds_return_t rc;
		carCabin_Basc_ActSenMode_Ntf* data;
		void* samples[1];
		samples[0] = carCabin_Basc_ActSenMode_Ntf__alloc();
		dds_sample_info_t infos[1];
		rc = dds_take_next(reader, samples, infos);
		if (rc < 0){
			ASF_LOG_ERROR_ARGS("on_Basc_ActSenMode_Ntf_CampRecordCameraSet_data_available dds_take_next faild rc=[%d]", rc);
			//printf("dds_take_next failed!\n");
        }
		if (infos[0].valid_data){
            data = (carCabin_Basc_ActSenMode_Ntf*)samples[0];
            ASF_LOG_DEBUG_ARGS("on_Basc_ActSenMode_Ntf_CampRecordCameraSet_data_available, hashId=[%d]", data->data._d);
			DDSClient::execute(Basc_ActSenMode_Ntf_CampRecordCameraSet_trigger,data);
			return;
		}
		carCabin_Basc_ActSenMode_Ntf_free(samples[0],DDS_FREE_ALL);
	}
    void on_Basc_ActSenMode_Ntf_ActCampTrig_data_available(int32_t reader, void* arg){
        ASF_LOG_DEBUG_ARGS("on_Basc_ActSenMode_Ntf_ActCampTrig_data_available");
    	dds_return_t rc;
		carCabin_Basc_ActSenMode_Ntf* data;
		void* samples[1];
		samples[0] = carCabin_Basc_ActSenMode_Ntf__alloc();
		dds_sample_info_t infos[1];
		rc = dds_take_next(reader, samples, infos);
		if (rc < 0){
			ASF_LOG_ERROR_ARGS("on_Basc_ActSenMode_Ntf_ActCampTrig_data_available dds_take_next faild rc=[%d]", rc);
			//printf("dds_take_next failed!\n");
        }
		if (infos[0].valid_data){
            data = (carCabin_Basc_ActSenMode_Ntf*)samples[0];
            ASF_LOG_DEBUG_ARGS("on_Basc_ActSenMode_Ntf_ActCampTrig_data_available, hashId=[%d]", data->data._d);
			DDSClient::execute(Basc_ActSenMode_Ntf_ActCampTrig_trigger,data);
			return;
		}
		carCabin_Basc_ActSenMode_Ntf_free(samples[0],DDS_FREE_ALL);
	}
	void on_carCabin_Basc_ActSenMode_reply_data_available(int32_t reader, void* arg) {
		ASF_LOG_DEBUG_ARGS("on_carCabin_Basc_ActSenMode_reply_data_available");
		dds_return_t rc;
		carCabin_Basc_ActSenMode_Reply* reply;
		void* samples[MAX_SAMPLES];
		dds_sample_info_t infos[MAX_SAMPLES];
		samples[0] = carCabin_Basc_ActSenMode_Reply__alloc();
		rc = dds_take_next(reader, samples, infos);
		if (rc < 0) {
			ASF_LOG_ERROR_ARGS("on_carCabin_Basc_ActSenMode_reply_data_available dds_take_next faild rc=[%d]", rc);
			//printf("dds_take_next failed!\n");
		}
		if (infos[0].valid_data) {
			reply = (carCabin_Basc_ActSenMode_Reply*)samples[0];
			auto sp = std::shared_ptr<void>{
				samples[0],
				[](void* ptr) {
					carCabin_Basc_ActSenMode_Reply_free(ptr,DDS_FREE_ALL);
				}
			};
			int32_t funID = reply->data._d;
			ASF_LOG_DEBUG_ARGS("on_carCabin_Basc_ActSenMode_reply_data_available, hashId=[%d], reqId=[%d]", funID, reply->header.relatedRequestId.sequence_number.low);
			switch (funID) {
				case carCabin_Basc_ActSenMode_RR_ActSenMoSwitSet_Hash:
				case carCabin_Basc_ActSenMode_RR_ActSenMoInfoSet_Hash:
				case carCabin_Basc_ActSenMode_Get__ActSenMoSwitSt_Hash:
				case carCabin_Basc_ActSenMode_Get_ActSenFunEnSt_Hash:
				case carCabin_Basc_ActSenMode_Get__ActSenMoInfoSet_Hash:
				case carCabin_Basc_ActSenMode_RR_ActSenWarningSet_Hash:
				case carCabin_Basc_ActSenMode_RR_ActCampSwitSet_Hash:
				case carCabin_Basc_ActSenMode_RR_ActCampWarningSet_Hash:
				case carCabin_Basc_ActSenMode_RR_ActCampRangeSet_Hash:
				case carCabin_Basc_ActSenMode_Get_ActCampSwitSet_Hash:
				case carCabin_Basc_ActSenMode_RR_SenRecordCameraSet_Hash:
				case carCabin_Basc_ActSenMode_RR_CampRecordCameraSet_Hash:
				{
					uint64_t key = reply->header.relatedRequestId.sequence_number.low;
					com::changan::rpc_service::DDSClient::release(key, sp);
					break;
				}
				default:
				{
					uint64_t key = reply->header.relatedRequestId.sequence_number.low;
					com::changan::rpc_service::DDSClient::release(key, sp);
					break;
				}
			}
		}
	}

	Basc_ActSenMode_Proxy::Basc_ActSenMode_Proxy(){

    }

    void on_Basc_ActSenMode_request_publication_matched_cb(dds_entity_t writer, const dds_publication_matched_status_t  status, void* arg) {
		ASF_LOG_DEBUG_ARGS("on_Basc_ActSenMode_request_publication_matched_cb, writer=[%d], current_count=[%d]", writer, status.current_count);
		Basc_ActSenMode_Proxy *pTmp = &Basc_ActSenMode_Proxy::get_instance();
		auto handler=Basc_ActSenMode_Proxy::get_instance().get_provider_matched_handler();
		if(NULL!=handler){
			ProviderMatchedStatus data=DDSUtil::get_provider_matched_status(writer,status);
			if(data.is_online == true)
            {
                pTmp->add_link_count();
            }
			else
            {
                pTmp->subtract_link_count();
            }
            if(pTmp->get_link_count() < 2)
            {
               data.is_online = false;
            }
            handler(data);
		}
	}
	
	void on_Basc_ActSenMode_reply_sublication_matched_cb(dds_entity_t reader, const dds_subscription_matched_status_t  status, void* arg) {
		ASF_LOG_DEBUG_ARGS("on_Basc_ActSenMode_reply_sublication_matched_cb, reader=[%d], current_count=[%d]", reader, status.current_count);
		Basc_ActSenMode_Proxy *pTmp = &Basc_ActSenMode_Proxy::get_instance();
        auto handler = pTmp->get_provider_matched_handler();
        if(NULL!=handler){
            ConsumerMatchedStatus ConsumerData=DDSUtil::get_consumer_matched_status(reader,status);
            ProviderMatchedStatus ProviderData;
			ProviderData.is_online = false;
            if(ConsumerData.is_online == true)
            {
                pTmp->add_link_count();
            }
            else
            {
                pTmp->subtract_link_count();
            }
            
            if(pTmp->get_link_count() == 2)
            {
                ProviderData.is_online = true;
            }
            handler(ProviderData);
        }
    }


	void Basc_ActSenMode_Proxy::wait_server_online()
	{
		this->wait_for_sub_online(dds_rpc_reply_handle.reader);
	}

	bool Basc_ActSenMode_Proxy::init(std::string config) {
	    std::lock_guard<std::mutex> guard(init_mutex);
	    if(this->init_flag){
	        return true;
	    }
		logconfig_Skeleton::get_instance().init(config);
		DDSUtil::event_sub_init(DDS_DOMAIN_ID,
			this->get_service_name()+"_"+this->Ntf_ActSenMoSwitSt.get_name(),
		    &carCabin_Basc_ActSenMode_Ntf_desc,
			&on_Basc_ActSenMode_Ntf_ActSenMoSwitSt_data_available,
			NULL,
			&dds_Ntf_ActSenMoSwitSt_handle,
			NULL,{PROXY_TOKEN, PROXY_TOKEN, ""},{},config);
		DDSUtil::event_sub_init(DDS_DOMAIN_ID,
			this->get_service_name()+"_"+this->Ntf_ActSenFunEnSt.get_name(),
		    &carCabin_Basc_ActSenMode_Ntf_desc,
			&on_Basc_ActSenMode_Ntf_ActSenFunEnSt_data_available,
			NULL,
			&dds_Ntf_ActSenFunEnSt_handle,
			NULL,{PROXY_TOKEN, PROXY_TOKEN, ""},{},config);
		DDSUtil::event_sub_init(DDS_DOMAIN_ID,
			this->get_service_name()+"_"+this->Ntf__ActSenMoInfoSet.get_name(),
		    &carCabin_Basc_ActSenMode_Ntf_desc,
			&on_Basc_ActSenMode_Ntf__ActSenMoInfoSet_data_available,
			NULL,
			&dds_Ntf__ActSenMoInfoSet_handle,
			NULL,{PROXY_TOKEN, PROXY_TOKEN, ""},{},config);
		DDSUtil::event_sub_init(DDS_DOMAIN_ID,
			this->get_service_name()+"_"+this->Ntf_UserNotiConfir.get_name(),
		    &carCabin_Basc_ActSenMode_Ntf_desc,
			&on_Basc_ActSenMode_Ntf_UserNotiConfir_data_available,
			NULL,
			&dds_Ntf_UserNotiConfir_handle,
			NULL,{PROXY_TOKEN, PROXY_TOKEN, ""},{},config);
		DDSUtil::event_sub_init(DDS_DOMAIN_ID,
			this->get_service_name()+"_"+this->Ntf_ActSenTrig.get_name(),
		    &carCabin_Basc_ActSenMode_Ntf_desc,
			&on_Basc_ActSenMode_Ntf_ActSenTrig_data_available,
			NULL,
			&dds_Ntf_ActSenTrig_handle,
			NULL,{PROXY_TOKEN, PROXY_TOKEN, ""},{},config);
		DDSUtil::event_sub_init(DDS_DOMAIN_ID,
			this->get_service_name()+"_"+this->Ntf_ActSenFunEn.get_name(),
		    &carCabin_Basc_ActSenMode_Ntf_desc,
			&on_Basc_ActSenMode_Ntf_ActSenFunEn_data_available,
			NULL,
			&dds_Ntf_ActSenFunEn_handle,
			NULL,{PROXY_TOKEN, PROXY_TOKEN, ""},{},config);
		DDSUtil::event_sub_init(DDS_DOMAIN_ID,
			this->get_service_name()+"_"+this->Ntf_SdcardSenErrTrig.get_name(),
		    &carCabin_Basc_ActSenMode_Ntf_desc,
			&on_Basc_ActSenMode_Ntf_SdcardSenErrTrig_data_available,
			NULL,
			&dds_Ntf_SdcardSenErrTrig_handle,
			NULL,{PROXY_TOKEN, PROXY_TOKEN, ""},{},config);
		DDSUtil::event_sub_init(DDS_DOMAIN_ID,
			this->get_service_name()+"_"+this->Ntf_ActCampSwitSet.get_name(),
		    &carCabin_Basc_ActSenMode_Ntf_desc,
			&on_Basc_ActSenMode_Ntf_ActCampSwitSet_data_available,
			NULL,
			&dds_Ntf_ActCampSwitSet_handle,
			NULL,{PROXY_TOKEN, PROXY_TOKEN, ""},{},config);
		DDSUtil::event_sub_init(DDS_DOMAIN_ID,
			this->get_service_name()+"_"+this->Ntf_CampRangeSet.get_name(),
		    &carCabin_Basc_ActSenMode_Ntf_desc,
			&on_Basc_ActSenMode_Ntf_CampRangeSet_data_available,
			NULL,
			&dds_Ntf_CampRangeSet_handle,
			NULL,{PROXY_TOKEN, PROXY_TOKEN, ""},{},config);
		DDSUtil::event_sub_init(DDS_DOMAIN_ID,
			this->get_service_name()+"_"+this->Ntf_SenWarningSetSwitchEarly.get_name(),
		    &carCabin_Basc_ActSenMode_Ntf_desc,
			&on_Basc_ActSenMode_Ntf_SenWarningSetSwitchEarly_data_available,
			NULL,
			&dds_Ntf_SenWarningSetSwitchEarly_handle,
			NULL,{PROXY_TOKEN, PROXY_TOKEN, ""},{},config);
		DDSUtil::event_sub_init(DDS_DOMAIN_ID,
			this->get_service_name()+"_"+this->Ntf_SenWarningSetSwitchCollision.get_name(),
		    &carCabin_Basc_ActSenMode_Ntf_desc,
			&on_Basc_ActSenMode_Ntf_SenWarningSetSwitchCollision_data_available,
			NULL,
			&dds_Ntf_SenWarningSetSwitchCollision_handle,
			NULL,{PROXY_TOKEN, PROXY_TOKEN, ""},{},config);
		DDSUtil::event_sub_init(DDS_DOMAIN_ID,
			this->get_service_name()+"_"+this->Ntf_SenWarningSetSwitchTheft.get_name(),
		    &carCabin_Basc_ActSenMode_Ntf_desc,
			&on_Basc_ActSenMode_Ntf_SenWarningSetSwitchTheft_data_available,
			NULL,
			&dds_Ntf_SenWarningSetSwitchTheft_handle,
			NULL,{PROXY_TOKEN, PROXY_TOKEN, ""},{},config);
		DDSUtil::event_sub_init(DDS_DOMAIN_ID,
			this->get_service_name()+"_"+this->Ntf_CampWarningSetSwitchS.get_name(),
		    &carCabin_Basc_ActSenMode_Ntf_desc,
			&on_Basc_ActSenMode_Ntf_CampWarningSetSwitchS_data_available,
			NULL,
			&dds_Ntf_CampWarningSetSwitchS_handle,
			NULL,{PROXY_TOKEN, PROXY_TOKEN, ""},{},config);
		DDSUtil::event_sub_init(DDS_DOMAIN_ID,
			this->get_service_name()+"_"+this->Ntf_CampWarningSetSwitchM.get_name(),
		    &carCabin_Basc_ActSenMode_Ntf_desc,
			&on_Basc_ActSenMode_Ntf_CampWarningSetSwitchM_data_available,
			NULL,
			&dds_Ntf_CampWarningSetSwitchM_handle,
			NULL,{PROXY_TOKEN, PROXY_TOKEN, ""},{},config);
		DDSUtil::event_sub_init(DDS_DOMAIN_ID,
			this->get_service_name()+"_"+this->Ntf_CampWarningSetSwitchL.get_name(),
		    &carCabin_Basc_ActSenMode_Ntf_desc,
			&on_Basc_ActSenMode_Ntf_CampWarningSetSwitchL_data_available,
			NULL,
			&dds_Ntf_CampWarningSetSwitchL_handle,
			NULL,{PROXY_TOKEN, PROXY_TOKEN, ""},{},config);
		DDSUtil::event_sub_init(DDS_DOMAIN_ID,
			this->get_service_name()+"_"+this->Ntf_SenRecordCameraSet.get_name(),
		    &carCabin_Basc_ActSenMode_Ntf_desc,
			&on_Basc_ActSenMode_Ntf_SenRecordCameraSet_data_available,
			NULL,
			&dds_Ntf_SenRecordCameraSet_handle,
			NULL,{PROXY_TOKEN, PROXY_TOKEN, ""},{},config);
		DDSUtil::event_sub_init(DDS_DOMAIN_ID,
			this->get_service_name()+"_"+this->Ntf_CampRecordCameraSet.get_name(),
		    &carCabin_Basc_ActSenMode_Ntf_desc,
			&on_Basc_ActSenMode_Ntf_CampRecordCameraSet_data_available,
			NULL,
			&dds_Ntf_CampRecordCameraSet_handle,
			NULL,{PROXY_TOKEN, PROXY_TOKEN, ""},{},config);
		DDSUtil::event_sub_init(DDS_DOMAIN_ID,
			this->get_service_name()+"_"+this->Ntf_ActCampTrig.get_name(),
		    &carCabin_Basc_ActSenMode_Ntf_desc,
			&on_Basc_ActSenMode_Ntf_ActCampTrig_data_available,
			NULL,
			&dds_Ntf_ActCampTrig_handle,
			NULL,{PROXY_TOKEN, PROXY_TOKEN, ""},{},config);
		DDSUtil::event_sub_init(DDS_DOMAIN_ID,
			this->service_name + "_reply",
			&carCabin_Basc_ActSenMode_Reply_desc,
			&on_carCabin_Basc_ActSenMode_reply_data_available,
			NULL,
			&dds_rpc_reply_handle,
			&on_Basc_ActSenMode_reply_sublication_matched_cb,{PROXY_TOKEN, PROXY_TOKEN, ""},{},config
		);
		DDSUtil::event_pub_init(DDS_DOMAIN_ID,
			this->service_name + "_request",
			&carCabin_Basc_ActSenMode_Request_desc,
			&dds_rpc_request_handle,
            &on_Basc_ActSenMode_request_publication_matched_cb,{PROXY_TOKEN, PROXY_TOKEN, ""},config
		);

		this->init_flag = true;
		return true;
	}

	bool Basc_ActSenMode_Proxy::destroy() {
		ASF_LOG_DEBUG_ARGS("Basc_ActSenMode_Proxy::destroy");
		std::lock_guard<std::mutex> guard(init_mutex);
	    if (!this->init_flag) {
			return true;
		}
		if (!DDSUtil::dds_client_destroy(&dds_Ntf_ActSenMoSwitSt_handle)) {
			return false;
		}
		if (!DDSUtil::dds_client_destroy(&dds_Ntf_ActSenFunEnSt_handle)) {
			return false;
		}
		if (!DDSUtil::dds_client_destroy(&dds_Ntf__ActSenMoInfoSet_handle)) {
			return false;
		}
		if (!DDSUtil::dds_client_destroy(&dds_Ntf_UserNotiConfir_handle)) {
			return false;
		}
		if (!DDSUtil::dds_client_destroy(&dds_Ntf_ActSenTrig_handle)) {
			return false;
		}
		if (!DDSUtil::dds_client_destroy(&dds_Ntf_ActSenFunEn_handle)) {
			return false;
		}
		if (!DDSUtil::dds_client_destroy(&dds_Ntf_SdcardSenErrTrig_handle)) {
			return false;
		}
		if (!DDSUtil::dds_client_destroy(&dds_Ntf_ActCampSwitSet_handle)) {
			return false;
		}
		if (!DDSUtil::dds_client_destroy(&dds_Ntf_CampRangeSet_handle)) {
			return false;
		}
		if (!DDSUtil::dds_client_destroy(&dds_Ntf_SenWarningSetSwitchEarly_handle)) {
			return false;
		}
		if (!DDSUtil::dds_client_destroy(&dds_Ntf_SenWarningSetSwitchCollision_handle)) {
			return false;
		}
		if (!DDSUtil::dds_client_destroy(&dds_Ntf_SenWarningSetSwitchTheft_handle)) {
			return false;
		}
		if (!DDSUtil::dds_client_destroy(&dds_Ntf_CampWarningSetSwitchS_handle)) {
			return false;
		}
		if (!DDSUtil::dds_client_destroy(&dds_Ntf_CampWarningSetSwitchM_handle)) {
			return false;
		}
		if (!DDSUtil::dds_client_destroy(&dds_Ntf_CampWarningSetSwitchL_handle)) {
			return false;
		}
		if (!DDSUtil::dds_client_destroy(&dds_Ntf_SenRecordCameraSet_handle)) {
			return false;
		}
		if (!DDSUtil::dds_client_destroy(&dds_Ntf_CampRecordCameraSet_handle)) {
			return false;
		}
		if (!DDSUtil::dds_client_destroy(&dds_Ntf_ActCampTrig_handle)) {
			return false;
		}
		if (!DDSUtil::dds_client_destroy(&dds_rpc_reply_handle)) {
			return false;
		}
		if (!DDSUtil::dds_client_destroy(&dds_rpc_request_handle)) {
			return false;
		}
		this->init_flag = false;
		return true;
	}

	Msg<SwitSetResult> Basc_ActSenMode_Proxy::RR_ActSenMoSwitSet(const SentrySwitchParam &sentrySwitchParam, size_t dds_rpc_time_out) {
		Msg<SwitSetResult> _rpc_result;
		carCabin_Basc_ActSenMode_Request* _rpc_request = carCabin_Basc_ActSenMode_Request__alloc();

		dds_guid_t _temp_guid = { 0 };
		dds_return_t rc = dds_get_guid(dds_rpc_request_handle.writer, &_temp_guid);
		if (DDS_RETCODE_OK != rc)
		{
			ASF_LOG_ERROR_ARGS("Basc_ActSenMode_Proxy::RR_ActSenMoSwitSet dds_get_guid faild rc=[%d], writer=[%d]", rc, dds_rpc_request_handle.writer);
			_rpc_result.code = DDS_RPC_REMOTE_EX_UNSUPPORTED;
			return _rpc_result;
		}

		memcpy(&_rpc_request->header.requestId, &_temp_guid, sizeof(dds_guid_t));
		DDS_SequenceNumber_t _rpc_client_sn = com::changan::rpc_service::DDSClient::get_rpc_request_id();
		_rpc_request->header.requestId.sequence_number = _rpc_client_sn;
		_rpc_request->data._u.RR_ActSenMoSwitSet.sentrySwitchParam = sentrySwitchParam;

		_rpc_request->data._d = carCabin_Basc_ActSenMode_RR_ActSenMoSwitSet_Hash;
		ASF_LOG_DEBUG_ARGS("Basc_ActSenMode_Proxy::RR_ActSenMoSwitSet pre async_call, hashId=[%d], reqId=[%d]", carCabin_Basc_ActSenMode_RR_ActSenMoSwitSet_Hash, _rpc_client_sn.low);
		auto _rpc_future = com::changan::rpc_service::DDSClient::async_call(_rpc_client_sn.low, dds_rpc_request_handle.writer, _rpc_request);
		carCabin_Basc_ActSenMode_Request_free(_rpc_request, DDS_FREE_ALL);

		auto _rpc_status = _rpc_future.wait_for(std::chrono::milliseconds(dds_rpc_time_out));
		if (_rpc_status == std::future_status::timeout ||
			_rpc_status == std::future_status::deferred) {
			_rpc_result.code = DDS_RPC_REMOTE_TIMEOUT_EXCEPTION;
			return _rpc_result;
		}
		auto sp =_rpc_future.get();
		auto _rpc_ret = (carCabin_Basc_ActSenMode_Reply*)sp.get();

		_rpc_result.code = _rpc_ret->header.remoteEx;
		if (_rpc_result.code == DDS_RPC_REMOTE_EX_OK) {
			_rpc_result.data = _rpc_ret->data._u.RR_ActSenMoSwitSet.return_;
			_rpc_result.autoFreePtr = sp;
		}
		return _rpc_result;
	}
	Msg<InfoSetResult> Basc_ActSenMode_Proxy::RR_ActSenMoInfoSet(const SenMoInfoSet &SenMoInfoSet_, size_t dds_rpc_time_out) {
		Msg<InfoSetResult> _rpc_result;
		carCabin_Basc_ActSenMode_Request* _rpc_request = carCabin_Basc_ActSenMode_Request__alloc();

		dds_guid_t _temp_guid = { 0 };
		dds_return_t rc = dds_get_guid(dds_rpc_request_handle.writer, &_temp_guid);
		if (DDS_RETCODE_OK != rc)
		{
			ASF_LOG_ERROR_ARGS("Basc_ActSenMode_Proxy::RR_ActSenMoInfoSet dds_get_guid faild rc=[%d], writer=[%d]", rc, dds_rpc_request_handle.writer);
			_rpc_result.code = DDS_RPC_REMOTE_EX_UNSUPPORTED;
			return _rpc_result;
		}

		memcpy(&_rpc_request->header.requestId, &_temp_guid, sizeof(dds_guid_t));
		DDS_SequenceNumber_t _rpc_client_sn = com::changan::rpc_service::DDSClient::get_rpc_request_id();
		_rpc_request->header.requestId.sequence_number = _rpc_client_sn;
		_rpc_request->data._u.RR_ActSenMoInfoSet.SenMoInfoSet = SenMoInfoSet_;

		_rpc_request->data._d = carCabin_Basc_ActSenMode_RR_ActSenMoInfoSet_Hash;
		ASF_LOG_DEBUG_ARGS("Basc_ActSenMode_Proxy::RR_ActSenMoInfoSet pre async_call, hashId=[%d], reqId=[%d]", carCabin_Basc_ActSenMode_RR_ActSenMoInfoSet_Hash, _rpc_client_sn.low);
		auto _rpc_future = com::changan::rpc_service::DDSClient::async_call(_rpc_client_sn.low, dds_rpc_request_handle.writer, _rpc_request);
		carCabin_Basc_ActSenMode_Request_free(_rpc_request, DDS_FREE_ALL);

		auto _rpc_status = _rpc_future.wait_for(std::chrono::milliseconds(dds_rpc_time_out));
		if (_rpc_status == std::future_status::timeout ||
			_rpc_status == std::future_status::deferred) {
			_rpc_result.code = DDS_RPC_REMOTE_TIMEOUT_EXCEPTION;
			return _rpc_result;
		}
		auto sp =_rpc_future.get();
		auto _rpc_ret = (carCabin_Basc_ActSenMode_Reply*)sp.get();

		_rpc_result.code = _rpc_ret->header.remoteEx;
		if (_rpc_result.code == DDS_RPC_REMOTE_EX_OK) {
			_rpc_result.data = _rpc_ret->data._u.RR_ActSenMoInfoSet.return_;
			_rpc_result.autoFreePtr = sp;
		}
		return _rpc_result;
	}
	Msg<uint8_t> Basc_ActSenMode_Proxy::Get__ActSenMoSwitSt( size_t dds_rpc_time_out) {
		Msg<uint8_t> _rpc_result;
		carCabin_Basc_ActSenMode_Request* _rpc_request = carCabin_Basc_ActSenMode_Request__alloc();

		dds_guid_t _temp_guid = { 0 };
		dds_return_t rc = dds_get_guid(dds_rpc_request_handle.writer, &_temp_guid);
		if (DDS_RETCODE_OK != rc)
		{
			ASF_LOG_ERROR_ARGS("Basc_ActSenMode_Proxy::Get__ActSenMoSwitSt dds_get_guid faild rc=[%d], writer=[%d]", rc, dds_rpc_request_handle.writer);
			_rpc_result.code = DDS_RPC_REMOTE_EX_UNSUPPORTED;
			return _rpc_result;
		}

		memcpy(&_rpc_request->header.requestId, &_temp_guid, sizeof(dds_guid_t));
		DDS_SequenceNumber_t _rpc_client_sn = com::changan::rpc_service::DDSClient::get_rpc_request_id();
		_rpc_request->header.requestId.sequence_number = _rpc_client_sn;

		_rpc_request->data._d = carCabin_Basc_ActSenMode_Get__ActSenMoSwitSt_Hash;
		ASF_LOG_DEBUG_ARGS("Basc_ActSenMode_Proxy::Get__ActSenMoSwitSt pre async_call, hashId=[%d], reqId=[%d]", carCabin_Basc_ActSenMode_Get__ActSenMoSwitSt_Hash, _rpc_client_sn.low);
		auto _rpc_future = com::changan::rpc_service::DDSClient::async_call(_rpc_client_sn.low, dds_rpc_request_handle.writer, _rpc_request);
		carCabin_Basc_ActSenMode_Request_free(_rpc_request, DDS_FREE_ALL);

		auto _rpc_status = _rpc_future.wait_for(std::chrono::milliseconds(dds_rpc_time_out));
		if (_rpc_status == std::future_status::timeout ||
			_rpc_status == std::future_status::deferred) {
			_rpc_result.code = DDS_RPC_REMOTE_TIMEOUT_EXCEPTION;
			return _rpc_result;
		}
		auto sp =_rpc_future.get();
		auto _rpc_ret = (carCabin_Basc_ActSenMode_Reply*)sp.get();

		_rpc_result.code = _rpc_ret->header.remoteEx;
		if (_rpc_result.code == DDS_RPC_REMOTE_EX_OK) {
			_rpc_result.data = _rpc_ret->data._u.Get__ActSenMoSwitSt.return_;
			_rpc_result.autoFreePtr = sp;
		}
		return _rpc_result;
	}
	Msg<uint8_t> Basc_ActSenMode_Proxy::Get_ActSenFunEnSt( size_t dds_rpc_time_out) {
		Msg<uint8_t> _rpc_result;
		carCabin_Basc_ActSenMode_Request* _rpc_request = carCabin_Basc_ActSenMode_Request__alloc();

		dds_guid_t _temp_guid = { 0 };
		dds_return_t rc = dds_get_guid(dds_rpc_request_handle.writer, &_temp_guid);
		if (DDS_RETCODE_OK != rc)
		{
			ASF_LOG_ERROR_ARGS("Basc_ActSenMode_Proxy::Get_ActSenFunEnSt dds_get_guid faild rc=[%d], writer=[%d]", rc, dds_rpc_request_handle.writer);
			_rpc_result.code = DDS_RPC_REMOTE_EX_UNSUPPORTED;
			return _rpc_result;
		}

		memcpy(&_rpc_request->header.requestId, &_temp_guid, sizeof(dds_guid_t));
		DDS_SequenceNumber_t _rpc_client_sn = com::changan::rpc_service::DDSClient::get_rpc_request_id();
		_rpc_request->header.requestId.sequence_number = _rpc_client_sn;

		_rpc_request->data._d = carCabin_Basc_ActSenMode_Get_ActSenFunEnSt_Hash;
		ASF_LOG_DEBUG_ARGS("Basc_ActSenMode_Proxy::Get_ActSenFunEnSt pre async_call, hashId=[%d], reqId=[%d]", carCabin_Basc_ActSenMode_Get_ActSenFunEnSt_Hash, _rpc_client_sn.low);
		auto _rpc_future = com::changan::rpc_service::DDSClient::async_call(_rpc_client_sn.low, dds_rpc_request_handle.writer, _rpc_request);
		carCabin_Basc_ActSenMode_Request_free(_rpc_request, DDS_FREE_ALL);

		auto _rpc_status = _rpc_future.wait_for(std::chrono::milliseconds(dds_rpc_time_out));
		if (_rpc_status == std::future_status::timeout ||
			_rpc_status == std::future_status::deferred) {
			_rpc_result.code = DDS_RPC_REMOTE_TIMEOUT_EXCEPTION;
			return _rpc_result;
		}
		auto sp =_rpc_future.get();
		auto _rpc_ret = (carCabin_Basc_ActSenMode_Reply*)sp.get();

		_rpc_result.code = _rpc_ret->header.remoteEx;
		if (_rpc_result.code == DDS_RPC_REMOTE_EX_OK) {
			_rpc_result.data = _rpc_ret->data._u.Get_ActSenFunEnSt.return_;
			_rpc_result.autoFreePtr = sp;
		}
		return _rpc_result;
	}
	Msg<SenMoInfoSet> Basc_ActSenMode_Proxy::Get__ActSenMoInfoSet( size_t dds_rpc_time_out) {
		Msg<SenMoInfoSet> _rpc_result;
		carCabin_Basc_ActSenMode_Request* _rpc_request = carCabin_Basc_ActSenMode_Request__alloc();

		dds_guid_t _temp_guid = { 0 };
		dds_return_t rc = dds_get_guid(dds_rpc_request_handle.writer, &_temp_guid);
		if (DDS_RETCODE_OK != rc)
		{
			ASF_LOG_ERROR_ARGS("Basc_ActSenMode_Proxy::Get__ActSenMoInfoSet dds_get_guid faild rc=[%d], writer=[%d]", rc, dds_rpc_request_handle.writer);
			_rpc_result.code = DDS_RPC_REMOTE_EX_UNSUPPORTED;
			return _rpc_result;
		}

		memcpy(&_rpc_request->header.requestId, &_temp_guid, sizeof(dds_guid_t));
		DDS_SequenceNumber_t _rpc_client_sn = com::changan::rpc_service::DDSClient::get_rpc_request_id();
		_rpc_request->header.requestId.sequence_number = _rpc_client_sn;

		_rpc_request->data._d = carCabin_Basc_ActSenMode_Get__ActSenMoInfoSet_Hash;
		ASF_LOG_DEBUG_ARGS("Basc_ActSenMode_Proxy::Get__ActSenMoInfoSet pre async_call, hashId=[%d], reqId=[%d]", carCabin_Basc_ActSenMode_Get__ActSenMoInfoSet_Hash, _rpc_client_sn.low);
		auto _rpc_future = com::changan::rpc_service::DDSClient::async_call(_rpc_client_sn.low, dds_rpc_request_handle.writer, _rpc_request);
		carCabin_Basc_ActSenMode_Request_free(_rpc_request, DDS_FREE_ALL);

		auto _rpc_status = _rpc_future.wait_for(std::chrono::milliseconds(dds_rpc_time_out));
		if (_rpc_status == std::future_status::timeout ||
			_rpc_status == std::future_status::deferred) {
			_rpc_result.code = DDS_RPC_REMOTE_TIMEOUT_EXCEPTION;
			return _rpc_result;
		}
		auto sp =_rpc_future.get();
		auto _rpc_ret = (carCabin_Basc_ActSenMode_Reply*)sp.get();

		_rpc_result.code = _rpc_ret->header.remoteEx;
		if (_rpc_result.code == DDS_RPC_REMOTE_EX_OK) {
			_rpc_result.data = _rpc_ret->data._u.Get__ActSenMoInfoSet.return_;
			_rpc_result.autoFreePtr = sp;
		}
		return _rpc_result;
	}
	Msg<SwitSetResult> Basc_ActSenMode_Proxy::RR_ActSenWarningSet(const SenWarningSet &SenWarningSet_, size_t dds_rpc_time_out) {
		Msg<SwitSetResult> _rpc_result;
		carCabin_Basc_ActSenMode_Request* _rpc_request = carCabin_Basc_ActSenMode_Request__alloc();

		dds_guid_t _temp_guid = { 0 };
		dds_return_t rc = dds_get_guid(dds_rpc_request_handle.writer, &_temp_guid);
		if (DDS_RETCODE_OK != rc)
		{
			ASF_LOG_ERROR_ARGS("Basc_ActSenMode_Proxy::RR_ActSenWarningSet dds_get_guid faild rc=[%d], writer=[%d]", rc, dds_rpc_request_handle.writer);
			_rpc_result.code = DDS_RPC_REMOTE_EX_UNSUPPORTED;
			return _rpc_result;
		}

		memcpy(&_rpc_request->header.requestId, &_temp_guid, sizeof(dds_guid_t));
		DDS_SequenceNumber_t _rpc_client_sn = com::changan::rpc_service::DDSClient::get_rpc_request_id();
		_rpc_request->header.requestId.sequence_number = _rpc_client_sn;
		_rpc_request->data._u.RR_ActSenWarningSet.SenWarningSet = SenWarningSet_;

		_rpc_request->data._d = carCabin_Basc_ActSenMode_RR_ActSenWarningSet_Hash;
		ASF_LOG_DEBUG_ARGS("Basc_ActSenMode_Proxy::RR_ActSenWarningSet pre async_call, hashId=[%d], reqId=[%d]", carCabin_Basc_ActSenMode_RR_ActSenWarningSet_Hash, _rpc_client_sn.low);
		auto _rpc_future = com::changan::rpc_service::DDSClient::async_call(_rpc_client_sn.low, dds_rpc_request_handle.writer, _rpc_request);
		carCabin_Basc_ActSenMode_Request_free(_rpc_request, DDS_FREE_ALL);

		auto _rpc_status = _rpc_future.wait_for(std::chrono::milliseconds(dds_rpc_time_out));
		if (_rpc_status == std::future_status::timeout ||
			_rpc_status == std::future_status::deferred) {
			_rpc_result.code = DDS_RPC_REMOTE_TIMEOUT_EXCEPTION;
			return _rpc_result;
		}
		auto sp =_rpc_future.get();
		auto _rpc_ret = (carCabin_Basc_ActSenMode_Reply*)sp.get();

		_rpc_result.code = _rpc_ret->header.remoteEx;
		if (_rpc_result.code == DDS_RPC_REMOTE_EX_OK) {
			_rpc_result.data = _rpc_ret->data._u.RR_ActSenWarningSet.return_;
			_rpc_result.autoFreePtr = sp;
		}
		return _rpc_result;
	}
	Msg<SwitSetResult> Basc_ActSenMode_Proxy::RR_ActCampSwitSet(const SentrySwitchParam &campSwitchParam, size_t dds_rpc_time_out) {
		Msg<SwitSetResult> _rpc_result;
		carCabin_Basc_ActSenMode_Request* _rpc_request = carCabin_Basc_ActSenMode_Request__alloc();

		dds_guid_t _temp_guid = { 0 };
		dds_return_t rc = dds_get_guid(dds_rpc_request_handle.writer, &_temp_guid);
		if (DDS_RETCODE_OK != rc)
		{
			ASF_LOG_ERROR_ARGS("Basc_ActSenMode_Proxy::RR_ActCampSwitSet dds_get_guid faild rc=[%d], writer=[%d]", rc, dds_rpc_request_handle.writer);
			_rpc_result.code = DDS_RPC_REMOTE_EX_UNSUPPORTED;
			return _rpc_result;
		}

		memcpy(&_rpc_request->header.requestId, &_temp_guid, sizeof(dds_guid_t));
		DDS_SequenceNumber_t _rpc_client_sn = com::changan::rpc_service::DDSClient::get_rpc_request_id();
		_rpc_request->header.requestId.sequence_number = _rpc_client_sn;
		_rpc_request->data._u.RR_ActCampSwitSet.campSwitchParam = campSwitchParam;

		_rpc_request->data._d = carCabin_Basc_ActSenMode_RR_ActCampSwitSet_Hash;
		ASF_LOG_DEBUG_ARGS("Basc_ActSenMode_Proxy::RR_ActCampSwitSet pre async_call, hashId=[%d], reqId=[%d]", carCabin_Basc_ActSenMode_RR_ActCampSwitSet_Hash, _rpc_client_sn.low);
		auto _rpc_future = com::changan::rpc_service::DDSClient::async_call(_rpc_client_sn.low, dds_rpc_request_handle.writer, _rpc_request);
		carCabin_Basc_ActSenMode_Request_free(_rpc_request, DDS_FREE_ALL);

		auto _rpc_status = _rpc_future.wait_for(std::chrono::milliseconds(dds_rpc_time_out));
		if (_rpc_status == std::future_status::timeout ||
			_rpc_status == std::future_status::deferred) {
			_rpc_result.code = DDS_RPC_REMOTE_TIMEOUT_EXCEPTION;
			return _rpc_result;
		}
		auto sp =_rpc_future.get();
		auto _rpc_ret = (carCabin_Basc_ActSenMode_Reply*)sp.get();

		_rpc_result.code = _rpc_ret->header.remoteEx;
		if (_rpc_result.code == DDS_RPC_REMOTE_EX_OK) {
			_rpc_result.data = _rpc_ret->data._u.RR_ActCampSwitSet.return_;
			_rpc_result.autoFreePtr = sp;
		}
		return _rpc_result;
	}
	Msg<SwitSetResult> Basc_ActSenMode_Proxy::RR_ActCampWarningSet(const CampWarningSet &CampWarningSet_, size_t dds_rpc_time_out) {
		Msg<SwitSetResult> _rpc_result;
		carCabin_Basc_ActSenMode_Request* _rpc_request = carCabin_Basc_ActSenMode_Request__alloc();

		dds_guid_t _temp_guid = { 0 };
		dds_return_t rc = dds_get_guid(dds_rpc_request_handle.writer, &_temp_guid);
		if (DDS_RETCODE_OK != rc)
		{
			ASF_LOG_ERROR_ARGS("Basc_ActSenMode_Proxy::RR_ActCampWarningSet dds_get_guid faild rc=[%d], writer=[%d]", rc, dds_rpc_request_handle.writer);
			_rpc_result.code = DDS_RPC_REMOTE_EX_UNSUPPORTED;
			return _rpc_result;
		}

		memcpy(&_rpc_request->header.requestId, &_temp_guid, sizeof(dds_guid_t));
		DDS_SequenceNumber_t _rpc_client_sn = com::changan::rpc_service::DDSClient::get_rpc_request_id();
		_rpc_request->header.requestId.sequence_number = _rpc_client_sn;
		_rpc_request->data._u.RR_ActCampWarningSet.CampWarningSet = CampWarningSet_;

		_rpc_request->data._d = carCabin_Basc_ActSenMode_RR_ActCampWarningSet_Hash;
		ASF_LOG_DEBUG_ARGS("Basc_ActSenMode_Proxy::RR_ActCampWarningSet pre async_call, hashId=[%d], reqId=[%d]", carCabin_Basc_ActSenMode_RR_ActCampWarningSet_Hash, _rpc_client_sn.low);
		auto _rpc_future = com::changan::rpc_service::DDSClient::async_call(_rpc_client_sn.low, dds_rpc_request_handle.writer, _rpc_request);
		carCabin_Basc_ActSenMode_Request_free(_rpc_request, DDS_FREE_ALL);

		auto _rpc_status = _rpc_future.wait_for(std::chrono::milliseconds(dds_rpc_time_out));
		if (_rpc_status == std::future_status::timeout ||
			_rpc_status == std::future_status::deferred) {
			_rpc_result.code = DDS_RPC_REMOTE_TIMEOUT_EXCEPTION;
			return _rpc_result;
		}
		auto sp =_rpc_future.get();
		auto _rpc_ret = (carCabin_Basc_ActSenMode_Reply*)sp.get();

		_rpc_result.code = _rpc_ret->header.remoteEx;
		if (_rpc_result.code == DDS_RPC_REMOTE_EX_OK) {
			_rpc_result.data = _rpc_ret->data._u.RR_ActCampWarningSet.return_;
			_rpc_result.autoFreePtr = sp;
		}
		return _rpc_result;
	}
	Msg<SwitSetResult> Basc_ActSenMode_Proxy::RR_ActCampRangeSet(const uint8_t &CampRangeSet, size_t dds_rpc_time_out) {
		Msg<SwitSetResult> _rpc_result;
		carCabin_Basc_ActSenMode_Request* _rpc_request = carCabin_Basc_ActSenMode_Request__alloc();

		dds_guid_t _temp_guid = { 0 };
		dds_return_t rc = dds_get_guid(dds_rpc_request_handle.writer, &_temp_guid);
		if (DDS_RETCODE_OK != rc)
		{
			ASF_LOG_ERROR_ARGS("Basc_ActSenMode_Proxy::RR_ActCampRangeSet dds_get_guid faild rc=[%d], writer=[%d]", rc, dds_rpc_request_handle.writer);
			_rpc_result.code = DDS_RPC_REMOTE_EX_UNSUPPORTED;
			return _rpc_result;
		}

		memcpy(&_rpc_request->header.requestId, &_temp_guid, sizeof(dds_guid_t));
		DDS_SequenceNumber_t _rpc_client_sn = com::changan::rpc_service::DDSClient::get_rpc_request_id();
		_rpc_request->header.requestId.sequence_number = _rpc_client_sn;
		_rpc_request->data._u.RR_ActCampRangeSet.CampRangeSet = CampRangeSet;

		_rpc_request->data._d = carCabin_Basc_ActSenMode_RR_ActCampRangeSet_Hash;
		ASF_LOG_DEBUG_ARGS("Basc_ActSenMode_Proxy::RR_ActCampRangeSet pre async_call, hashId=[%d], reqId=[%d]", carCabin_Basc_ActSenMode_RR_ActCampRangeSet_Hash, _rpc_client_sn.low);
		auto _rpc_future = com::changan::rpc_service::DDSClient::async_call(_rpc_client_sn.low, dds_rpc_request_handle.writer, _rpc_request);
		carCabin_Basc_ActSenMode_Request_free(_rpc_request, DDS_FREE_ALL);

		auto _rpc_status = _rpc_future.wait_for(std::chrono::milliseconds(dds_rpc_time_out));
		if (_rpc_status == std::future_status::timeout ||
			_rpc_status == std::future_status::deferred) {
			_rpc_result.code = DDS_RPC_REMOTE_TIMEOUT_EXCEPTION;
			return _rpc_result;
		}
		auto sp =_rpc_future.get();
		auto _rpc_ret = (carCabin_Basc_ActSenMode_Reply*)sp.get();

		_rpc_result.code = _rpc_ret->header.remoteEx;
		if (_rpc_result.code == DDS_RPC_REMOTE_EX_OK) {
			_rpc_result.data = _rpc_ret->data._u.RR_ActCampRangeSet.return_;
			_rpc_result.autoFreePtr = sp;
		}
		return _rpc_result;
	}
	Msg<uint8_t> Basc_ActSenMode_Proxy::Get_ActCampSwitSet( size_t dds_rpc_time_out) {
		Msg<uint8_t> _rpc_result;
		carCabin_Basc_ActSenMode_Request* _rpc_request = carCabin_Basc_ActSenMode_Request__alloc();

		dds_guid_t _temp_guid = { 0 };
		dds_return_t rc = dds_get_guid(dds_rpc_request_handle.writer, &_temp_guid);
		if (DDS_RETCODE_OK != rc)
		{
			ASF_LOG_ERROR_ARGS("Basc_ActSenMode_Proxy::Get_ActCampSwitSet dds_get_guid faild rc=[%d], writer=[%d]", rc, dds_rpc_request_handle.writer);
			_rpc_result.code = DDS_RPC_REMOTE_EX_UNSUPPORTED;
			return _rpc_result;
		}

		memcpy(&_rpc_request->header.requestId, &_temp_guid, sizeof(dds_guid_t));
		DDS_SequenceNumber_t _rpc_client_sn = com::changan::rpc_service::DDSClient::get_rpc_request_id();
		_rpc_request->header.requestId.sequence_number = _rpc_client_sn;

		_rpc_request->data._d = carCabin_Basc_ActSenMode_Get_ActCampSwitSet_Hash;
		ASF_LOG_DEBUG_ARGS("Basc_ActSenMode_Proxy::Get_ActCampSwitSet pre async_call, hashId=[%d], reqId=[%d]", carCabin_Basc_ActSenMode_Get_ActCampSwitSet_Hash, _rpc_client_sn.low);
		auto _rpc_future = com::changan::rpc_service::DDSClient::async_call(_rpc_client_sn.low, dds_rpc_request_handle.writer, _rpc_request);
		carCabin_Basc_ActSenMode_Request_free(_rpc_request, DDS_FREE_ALL);

		auto _rpc_status = _rpc_future.wait_for(std::chrono::milliseconds(dds_rpc_time_out));
		if (_rpc_status == std::future_status::timeout ||
			_rpc_status == std::future_status::deferred) {
			_rpc_result.code = DDS_RPC_REMOTE_TIMEOUT_EXCEPTION;
			return _rpc_result;
		}
		auto sp =_rpc_future.get();
		auto _rpc_ret = (carCabin_Basc_ActSenMode_Reply*)sp.get();

		_rpc_result.code = _rpc_ret->header.remoteEx;
		if (_rpc_result.code == DDS_RPC_REMOTE_EX_OK) {
			_rpc_result.data = _rpc_ret->data._u.Get_ActCampSwitSet.return_;
			_rpc_result.autoFreePtr = sp;
		}
		return _rpc_result;
	}
	Msg<uint8_t> Basc_ActSenMode_Proxy::RR_SenRecordCameraSet(const uint32_t &camera, size_t dds_rpc_time_out) {
		Msg<uint8_t> _rpc_result;
		carCabin_Basc_ActSenMode_Request* _rpc_request = carCabin_Basc_ActSenMode_Request__alloc();

		dds_guid_t _temp_guid = { 0 };
		dds_return_t rc = dds_get_guid(dds_rpc_request_handle.writer, &_temp_guid);
		if (DDS_RETCODE_OK != rc)
		{
			ASF_LOG_ERROR_ARGS("Basc_ActSenMode_Proxy::RR_SenRecordCameraSet dds_get_guid faild rc=[%d], writer=[%d]", rc, dds_rpc_request_handle.writer);
			_rpc_result.code = DDS_RPC_REMOTE_EX_UNSUPPORTED;
			return _rpc_result;
		}

		memcpy(&_rpc_request->header.requestId, &_temp_guid, sizeof(dds_guid_t));
		DDS_SequenceNumber_t _rpc_client_sn = com::changan::rpc_service::DDSClient::get_rpc_request_id();
		_rpc_request->header.requestId.sequence_number = _rpc_client_sn;
		_rpc_request->data._u.RR_SenRecordCameraSet.camera = camera;

		_rpc_request->data._d = carCabin_Basc_ActSenMode_RR_SenRecordCameraSet_Hash;
		ASF_LOG_DEBUG_ARGS("Basc_ActSenMode_Proxy::RR_SenRecordCameraSet pre async_call, hashId=[%d], reqId=[%d]", carCabin_Basc_ActSenMode_RR_SenRecordCameraSet_Hash, _rpc_client_sn.low);
		auto _rpc_future = com::changan::rpc_service::DDSClient::async_call(_rpc_client_sn.low, dds_rpc_request_handle.writer, _rpc_request);
		carCabin_Basc_ActSenMode_Request_free(_rpc_request, DDS_FREE_ALL);

		auto _rpc_status = _rpc_future.wait_for(std::chrono::milliseconds(dds_rpc_time_out));
		if (_rpc_status == std::future_status::timeout ||
			_rpc_status == std::future_status::deferred) {
			_rpc_result.code = DDS_RPC_REMOTE_TIMEOUT_EXCEPTION;
			return _rpc_result;
		}
		auto sp =_rpc_future.get();
		auto _rpc_ret = (carCabin_Basc_ActSenMode_Reply*)sp.get();

		_rpc_result.code = _rpc_ret->header.remoteEx;
		if (_rpc_result.code == DDS_RPC_REMOTE_EX_OK) {
			_rpc_result.data = _rpc_ret->data._u.RR_SenRecordCameraSet.return_;
			_rpc_result.autoFreePtr = sp;
		}
		return _rpc_result;
	}
	Msg<uint8_t> Basc_ActSenMode_Proxy::RR_CampRecordCameraSet(const uint32_t &camera, size_t dds_rpc_time_out) {
		Msg<uint8_t> _rpc_result;
		carCabin_Basc_ActSenMode_Request* _rpc_request = carCabin_Basc_ActSenMode_Request__alloc();

		dds_guid_t _temp_guid = { 0 };
		dds_return_t rc = dds_get_guid(dds_rpc_request_handle.writer, &_temp_guid);
		if (DDS_RETCODE_OK != rc)
		{
			ASF_LOG_ERROR_ARGS("Basc_ActSenMode_Proxy::RR_CampRecordCameraSet dds_get_guid faild rc=[%d], writer=[%d]", rc, dds_rpc_request_handle.writer);
			_rpc_result.code = DDS_RPC_REMOTE_EX_UNSUPPORTED;
			return _rpc_result;
		}

		memcpy(&_rpc_request->header.requestId, &_temp_guid, sizeof(dds_guid_t));
		DDS_SequenceNumber_t _rpc_client_sn = com::changan::rpc_service::DDSClient::get_rpc_request_id();
		_rpc_request->header.requestId.sequence_number = _rpc_client_sn;
		_rpc_request->data._u.RR_CampRecordCameraSet.camera = camera;

		_rpc_request->data._d = carCabin_Basc_ActSenMode_RR_CampRecordCameraSet_Hash;
		ASF_LOG_DEBUG_ARGS("Basc_ActSenMode_Proxy::RR_CampRecordCameraSet pre async_call, hashId=[%d], reqId=[%d]", carCabin_Basc_ActSenMode_RR_CampRecordCameraSet_Hash, _rpc_client_sn.low);
		auto _rpc_future = com::changan::rpc_service::DDSClient::async_call(_rpc_client_sn.low, dds_rpc_request_handle.writer, _rpc_request);
		carCabin_Basc_ActSenMode_Request_free(_rpc_request, DDS_FREE_ALL);

		auto _rpc_status = _rpc_future.wait_for(std::chrono::milliseconds(dds_rpc_time_out));
		if (_rpc_status == std::future_status::timeout ||
			_rpc_status == std::future_status::deferred) {
			_rpc_result.code = DDS_RPC_REMOTE_TIMEOUT_EXCEPTION;
			return _rpc_result;
		}
		auto sp =_rpc_future.get();
		auto _rpc_ret = (carCabin_Basc_ActSenMode_Reply*)sp.get();

		_rpc_result.code = _rpc_ret->header.remoteEx;
		if (_rpc_result.code == DDS_RPC_REMOTE_EX_OK) {
			_rpc_result.data = _rpc_ret->data._u.RR_CampRecordCameraSet.return_;
			_rpc_result.autoFreePtr = sp;
		}
		return _rpc_result;
	}
    Basc_ActSenMode_Proxy::~Basc_ActSenMode_Proxy(){

    }

	Basc_ActSenMode_Proxy& Basc_ActSenMode_Proxy::get_instance()
	{
		static Basc_ActSenMode_Proxy instance;
		return instance;
	}
}
}
}
}
}


/****************************************************************
  Generated by ChangAn Code Generator,Do Not Modify
  AppVersion： mADC_Application_Service-V1.5
  ServiceVersion: 
  CmVersion： v2.0.3
  ServiceLatestModifyTime: 
  Generate Time: 2023-12-11 18:07:58
*****************************************************************/
#include "changan/Car_Control_fr_Skeleton.hpp"
#include "changan/dds_server.hpp"
#include <iostream>
#include <thread>
#include <string.h>
#include "changan/string_util.hpp"
#include "changan/business_util.h"
#include "changan/Cnr_RiMirrLaneLED_Skeleton.hpp"
namespace com {
	namespace changan {
		namespace carControl {
			namespace skeleton {
				using namespace com::changan::rpc_service;
				using namespace com::changan::soa_log::skeleton;
				void reply_fr_service_no_register(DDS_SampleIdentity requestId) {
					carControl_Car_Control_Reply* reply_msg = carControl_Car_Control_Reply__alloc();
					reply_msg->header.relatedRequestId = requestId;
					reply_msg->header.remoteEx = DDS_RPC_REMOTE_SERVICE_NOT_REGISTER;
				  	CarControlFRSkeleton::get_instance().send_reply(reply_msg);
					carControl_Car_Control_Reply_free(reply_msg, DDS_FREE_ALL);
				}
				void carControl_Car_Control_Cnr_RiMirrLaneLED_RR_MirrLaneLEDCrl(carControl_Car_Control_Request * request){
					using Cnr_RiMirrLaneLED_Skeleton = com::changan::carControl::RearViewMirror::skeleton::Cnr_RiMirrLaneLED_Skeleton;
				Cnr_RiMirrLaneLED_Skeleton* skeleton = (Cnr_RiMirrLaneLED_Skeleton*)com::changan::rpc_service::DDSServer::get_service("Cnr_RiMirrLaneLED_skeleton");
					if(NULL==skeleton){
						reply_fr_service_no_register(request->header.requestId);
						carControl_Car_Control_Request_free(request, DDS_FREE_ALL);
						return;
					}
					ASF_LOG_DEBUG_ARGS("pre skeleton->RR_MirrLaneLEDCrl");
				ResponseInfo ret = skeleton->RR_MirrLaneLEDCrl(request->data._u.Cnr_RiMirrLaneLED_RR_MirrLaneLEDCrl.MirrLaneLEDCrl,request->data._u.Cnr_RiMirrLaneLED_RR_MirrLaneLEDCrl.RequestInfo);
					ASF_LOG_DEBUG_ARGS("after skeleton->RR_MirrLaneLEDCrl");
					carControl_Car_Control_Reply* reply_msg = carControl_Car_Control_Reply__alloc();
					reply_msg->header.relatedRequestId = request->header.requestId;
					reply_msg->data._d = carControl_Car_Control_Cnr_RiMirrLaneLED_RR_MirrLaneLEDCrl_Hash;
					reply_msg->header.remoteEx = DDS_RPC_REMOTE_EX_OK;
					reply_msg->data._u.Cnr_RiMirrLaneLED_RR_MirrLaneLEDCrl.return_ = ret;
					dds_return_t rc = CarControlFRSkeleton::get_instance().send_reply(reply_msg);
					ASF_LOG_DEBUG_ARGS("CarControlFRSkeleton::send_reply, hashId=[%d], reqId=[%d], rc=[%d]", carControl_Car_Control_Cnr_RiMirrLaneLED_RR_MirrLaneLEDCrl_Hash, reply_msg->header.relatedRequestId.sequence_number.low, rc);
					carControl_Car_Control_Reply_free(reply_msg, DDS_FREE_ALL);
				}
				void carControl_Car_Control_Cnr_RiMirrLaneLED_Get_SrvOperInfo(carControl_Car_Control_Request * request){
					using Cnr_RiMirrLaneLED_Skeleton = com::changan::carControl::RearViewMirror::skeleton::Cnr_RiMirrLaneLED_Skeleton;
				Cnr_RiMirrLaneLED_Skeleton* skeleton = (Cnr_RiMirrLaneLED_Skeleton*)com::changan::rpc_service::DDSServer::get_service("Cnr_RiMirrLaneLED_skeleton");
					if(NULL==skeleton){
						reply_fr_service_no_register(request->header.requestId);
						carControl_Car_Control_Request_free(request, DDS_FREE_ALL);
						return;
					}
					ASF_LOG_DEBUG_ARGS("pre skeleton->Get_SrvOperInfo");
				OperationInfo ret = skeleton->Get_SrvOperInfo();
					ASF_LOG_DEBUG_ARGS("after skeleton->Get_SrvOperInfo");
					carControl_Car_Control_Reply* reply_msg = carControl_Car_Control_Reply__alloc();
					reply_msg->header.relatedRequestId = request->header.requestId;
					reply_msg->data._d = carControl_Car_Control_Cnr_RiMirrLaneLED_Get_SrvOperInfo_Hash;
					reply_msg->header.remoteEx = DDS_RPC_REMOTE_EX_OK;
					reply_msg->data._u.Cnr_RiMirrLaneLED_Get_SrvOperInfo.return_ = ret;
					dds_return_t rc = CarControlFRSkeleton::get_instance().send_reply(reply_msg);
					ASF_LOG_DEBUG_ARGS("CarControlFRSkeleton::send_reply, hashId=[%d], reqId=[%d], rc=[%d]", carControl_Car_Control_Cnr_RiMirrLaneLED_Get_SrvOperInfo_Hash, reply_msg->header.relatedRequestId.sequence_number.low, rc);
					carControl_Car_Control_Reply_free(reply_msg, DDS_FREE_ALL);
				}
				void on_carControl_fr_request_data_available(int32_t reader, void* arg) {
					ASF_LOG_DEBUG_ARGS("on_carControl_fr_request_data_available");
					dds_return_t rc;
					//printf("RPC server on data available!\n");
					carControl_Car_Control_Request* request;
					void* samples[1];
					dds_sample_info_t infos[1];
					samples[0] = carControl_Car_Control_Request__alloc();
					rc = dds_take_next(reader, samples, infos);
					if (rc < 0) {
						ASF_LOG_ERROR_ARGS("on_carControl_fr_request_data_available, dds_take_next faild, rc=[%d]",rc);
						DDS_FATAL("dds_take_next failed!\n");
					}
					if (infos[0].valid_data)
					{
						request = (carControl_Car_Control_Request*)samples[0];
						int32_t funID = request->data._d;
						ASF_LOG_DEBUG_ARGS("on_carControl_fr_request_data_available, hashId=[%d], reqId=[%d]", funID,  request->header.requestId.sequence_number.low);
						switch (funID) {
						case carControl_Car_Control_Cnr_RiMirrLaneLED_RR_MirrLaneLEDCrl_Hash:
						{
							DDSServer::execute(carControl_Car_Control_Cnr_RiMirrLaneLED_RR_MirrLaneLEDCrl, request);
				            return;
				        }
						case carControl_Car_Control_Cnr_RiMirrLaneLED_Get_SrvOperInfo_Hash:
						{
							DDSServer::execute(carControl_Car_Control_Cnr_RiMirrLaneLED_Get_SrvOperInfo, request);
				            return;
				        }
						default:
							carControl_Car_Control_Reply* reply_msg = carControl_Car_Control_Reply__alloc();
							reply_msg->header.relatedRequestId = request->header.requestId;
							reply_msg->header.remoteEx = DDS_RPC_REMOTE_METHOD_NOT_FOUND;
				  			CarControlFRSkeleton::get_instance().send_reply(reply_msg);
							carControl_Car_Control_Reply_free(reply_msg, DDS_FREE_ALL);
							break;
						}
					}
					carControl_Car_Control_Request_free(samples[0], DDS_FREE_ALL);
				}
				CarControlFRSkeleton::CarControlFRSkeleton() {}

				void on_CarControlFRSkeleton_request_subscription_matched_cb(dds_entity_t reader, const dds_subscription_matched_status_t  status, void* arg) {
					ASF_LOG_DEBUG_ARGS("on_CarControlFRSkeleton_request_subscription_matched_cb, reader=[%d], current_count=[%d]", reader, status.current_count);
					auto handlers=CarControlFRSkeleton::get_instance().get_registered_consumer_matched_handler();
					ConsumerMatchedStatus data=DDSUtil::get_consumer_matched_status(reader,status);
				  	CarControlFRSkeleton::get_instance().set_last_consumer_matched_status(data);
					for (const auto& it : handlers) {
						it.second(data);
					}
				}

				void CarControlFRSkeleton::wait_client_online()
				{
					this->wait_for_pub_online(dds_mcu_rpc_handle.writer);

				}

				void CarControlFRSkeleton::init(std::string config) {
					std::lock_guard<std::mutex> guard(init_mutex);
					if (this->init_flag) {
						return;
					}
					logconfig_Skeleton::get_instance().init(config);
					DDSUtil::event_pub_init(VIU_DDS_DOMAIN_ID,
						"viu_fr_mcu_notify",
						&carControl_Car_Control_Ntf_desc,
						&this->dds_mcu_notify_handle,
					  	NULL, {LOCAL_VIU_TOKEN, DIRECT_AND_LOCAL_VIU_TOKEN, "*ntf"},
						config);

					uint8_t  service_id_array[364] = {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10};
					DDSUtil::event_sub_init(VIU_DDS_DOMAIN_ID,
						"viu_fr_mcu_rpc_service_request",
						&carControl_Car_Control_Request_desc,
					  	&on_carControl_fr_request_data_available,
						NULL,
						&this->dds_mcu_rpc_handle,
						&on_CarControlFRSkeleton_request_subscription_matched_cb,
						{LOCAL_VIU_TOKEN, DIRECT_AND_LOCAL_VIU_TOKEN, "rpc"},
						{364,service_id_array},
						config
					);

					DDSUtil::event_pub_init(VIU_DDS_DOMAIN_ID,
						"viu_fr_mcu_rpc_service_reply",
						&carControl_Car_Control_Reply_desc,
						&this->dds_mcu_rpc_handle,
						NULL, {LOCAL_VIU_TOKEN, DIRECT_AND_LOCAL_VIU_TOKEN, "rpc"},
					  	config
					);


					this->init_flag = true;
				}

				CarControlFRSkeleton& CarControlFRSkeleton::get_instance() {
					static CarControlFRSkeleton instance;
					return instance;
				}
				int32_t CarControlFRSkeleton::send(const void* data) {
					return DDSUtil::send(this->dds_mcu_notify_handle.writer, data);
				}
				int32_t CarControlFRSkeleton::send_reply(const void* data) {
					return DDSUtil::send(this->dds_mcu_rpc_handle.writer, data);
				}
				void CarControlFRSkeleton::register_consumer_matched_handler(std::string name,EventReceiveHandler<const ConsumerMatchedStatus&> handler){
					if(NULL==handler || name.empty()){
						return;
					}
					consumer_matched_handler_map[name]=handler;
					if(this->init_flag && this->consumer_matched_status.current_count>0){
					  	handler(this->consumer_matched_status);
					}
				}
				std::unordered_map<std::string, EventReceiveHandler<const ConsumerMatchedStatus&>> CarControlFRSkeleton::get_registered_consumer_matched_handler(){
					return this->consumer_matched_handler_map;
				}
				void CarControlFRSkeleton::set_last_consumer_matched_status(ConsumerMatchedStatus status){
					this->consumer_matched_status=status;
				}
			}
		}
	}
}


/****************************************************************
  Generated by ChangAn Code Generator,Do Not Modify
  AppVersion： mADC_Application_Service-V1.5
  ServiceVersion: 
  CmVersion： v2.0.3
  ServiceLatestModifyTime: 
  Generate Time: 2023-12-11 18:07:58
*****************************************************************/
#include "Car_Control_r_Proxy.hpp"
#include "changan/Car_Control.h"
#include "changan/dds_util.h"
#include "changan/dds_client.hpp"
#include "changan/Basc_EleAirSuspModSet_Proxy.hpp"
#include "changan/Basc_EleAirSuspModSts_Proxy.hpp"
#include "changan/Basc_RearWiperFltSts_Proxy.hpp"
#include "changan/Basc_TailGateSts_Proxy.hpp"
namespace com {
	namespace changan {
		namespace carControl {
			namespace proxy {
				using namespace com::changan::soa_log::skeleton;
	  			void on_carControl_r_rpc_reply_data_available(int32_t reader, void* arg) {
	  				ASF_LOG_DEBUG_ARGS("on_carControl_r_rpc_reply_data_available");
			    	dds_return_t rc;
					carControl_Car_Control_Reply* reply;
					void* samples[MAX_SAMPLES];
					dds_sample_info_t infos[MAX_SAMPLES];
					samples[0] = carControl_Car_Control_Reply__alloc();
					rc = dds_take_next(reader, samples, infos);
					if (rc < 0) {
						ASF_LOG_ERROR_ARGS("on_carControl_rpc_reply_data_available dds_take_next faild rc=[%d]", rc);
						//printf("dds_take_next failed!\n");
					}
					if (infos[0].valid_data) {
						reply = (carControl_Car_Control_Reply*)samples[0];
						auto sp = std::shared_ptr<void>{
							samples[0],
							[](void* ptr) {
								carControl_Car_Control_Reply_free(ptr,DDS_FREE_ALL);
							}
						};
						// 不存在的methodId也需要立即释放，不阻塞客户端
						uint64_t key = reply->header.relatedRequestId.sequence_number.low;
						ASF_LOG_DEBUG_ARGS("on_carControl_rpc_reply_data_available, hashId=[%d], reqId=[%d]", reply->data._d, key);
						com::changan::rpc_service::DDSClient::release(key, sp);
					}
				}
			    void on_carControl_r_notify_data_available(int32_t reader, void* arg) {
			    	dds_return_t rc;
					carControl_Car_Control_Ntf* data;
					void* samples[MAX_SAMPLES];
					dds_sample_info_t infos[MAX_SAMPLES];
					samples[0] = carControl_Car_Control_Ntf__alloc();
					rc = dds_take_next(reader, samples, infos);
					if (rc < 0) {
						ASF_LOG_ERROR_ARGS("dds_take_next failed!");
					}
					if (infos[0].valid_data) {
						data = (carControl_Car_Control_Ntf*)samples[0];
						int event_id = data->data._d;
						switch (event_id)
						{
						case carControl_Car_Control_Basc_EleAirSuspModSet_Ntf_EleAirSuspHighModSet_Hash:
						{
						    using Basc_EleAirSuspModSet_Proxy = com::changan::carControl::CHS_SUSP::proxy::Basc_EleAirSuspModSet_Proxy;
							if(Basc_EleAirSuspModSet_Proxy::get_instance().is_init()){
								Basc_EleAirSuspModSet_Proxy::get_instance().Ntf_EleAirSuspHighModSet.trigger(data->data._u.Car_Control_Basc_EleAirSuspModSet_Ntf_EleAirSuspHighModSet);
							}
							break;
						}
						case carControl_Car_Control_Basc_EleAirSuspModSet_Ntf_EleAirSuspIntenModSet_Hash:
						{
						    using Basc_EleAirSuspModSet_Proxy = com::changan::carControl::CHS_SUSP::proxy::Basc_EleAirSuspModSet_Proxy;
							if(Basc_EleAirSuspModSet_Proxy::get_instance().is_init()){
								Basc_EleAirSuspModSet_Proxy::get_instance().Ntf_EleAirSuspIntenModSet.trigger(data->data._u.Car_Control_Basc_EleAirSuspModSet_Ntf_EleAirSuspIntenModSet);
							}
							break;
						}
						case carControl_Car_Control_Basc_EleAirSuspModSet_Ntf_EleAirSuspAutoModSet_Hash:
						{
						    using Basc_EleAirSuspModSet_Proxy = com::changan::carControl::CHS_SUSP::proxy::Basc_EleAirSuspModSet_Proxy;
							if(Basc_EleAirSuspModSet_Proxy::get_instance().is_init()){
								Basc_EleAirSuspModSet_Proxy::get_instance().Ntf_EleAirSuspAutoModSet.trigger(data->data._u.Car_Control_Basc_EleAirSuspModSet_Ntf_EleAirSuspAutoModSet);
							}
							break;
						}
						case carControl_Car_Control_Basc_EleAirSuspModSts_Ntf_EleAirSuspIntenModSts_Hash:
						{
						    using Basc_EleAirSuspModSts_Proxy = com::changan::carControl::CHS_SUSP::proxy::Basc_EleAirSuspModSts_Proxy;
							if(Basc_EleAirSuspModSts_Proxy::get_instance().is_init()){
								Basc_EleAirSuspModSts_Proxy::get_instance().Ntf_EleAirSuspIntenModSts.trigger(data->data._u.Car_Control_Basc_EleAirSuspModSts_Ntf_EleAirSuspIntenModSts);
							}
							break;
						}
						case carControl_Car_Control_Basc_EleAirSuspModSts_Ntf_EleAirSuspHighModSts_Hash:
						{
						    using Basc_EleAirSuspModSts_Proxy = com::changan::carControl::CHS_SUSP::proxy::Basc_EleAirSuspModSts_Proxy;
							if(Basc_EleAirSuspModSts_Proxy::get_instance().is_init()){
								Basc_EleAirSuspModSts_Proxy::get_instance().Ntf_EleAirSuspHighModSts.trigger(data->data._u.Car_Control_Basc_EleAirSuspModSts_Ntf_EleAirSuspHighModSts);
							}
							break;
						}
						case carControl_Car_Control_Basc_EleAirSuspModSts_Ntf_EleAirSuspHighModCHASts_Hash:
						{
						    using Basc_EleAirSuspModSts_Proxy = com::changan::carControl::CHS_SUSP::proxy::Basc_EleAirSuspModSts_Proxy;
							if(Basc_EleAirSuspModSts_Proxy::get_instance().is_init()){
								Basc_EleAirSuspModSts_Proxy::get_instance().Ntf_EleAirSuspHighModCHASts.trigger(data->data._u.Car_Control_Basc_EleAirSuspModSts_Ntf_EleAirSuspHighModCHASts);
							}
							break;
						}
						case carControl_Car_Control_Basc_EleAirSuspModSts_Ntf_EleAirSuspAutoModSts_Hash:
						{
						    using Basc_EleAirSuspModSts_Proxy = com::changan::carControl::CHS_SUSP::proxy::Basc_EleAirSuspModSts_Proxy;
							if(Basc_EleAirSuspModSts_Proxy::get_instance().is_init()){
								Basc_EleAirSuspModSts_Proxy::get_instance().Ntf_EleAirSuspAutoModSts.trigger(data->data._u.Car_Control_Basc_EleAirSuspModSts_Ntf_EleAirSuspAutoModSts);
							}
							break;
						}
						case carControl_Car_Control_Basc_RearWiperFltSts_Ntf_WiperFltSts_Hash:
						{
						    using Basc_RearWiperFltSts_Proxy = com::changan::carControl::WiperWasher::proxy::Basc_RearWiperFltSts_Proxy;
							if(Basc_RearWiperFltSts_Proxy::get_instance().is_init()){
								Basc_RearWiperFltSts_Proxy::get_instance().Ntf_WiperFltSts.trigger(data->data._u.Car_Control_Basc_RearWiperFltSts_Ntf_WiperFltSts);
							}
							break;
						}
						case carControl_Car_Control_Basc_TailGateSts_Ntf_LockSt_Hash:
						{
						    using Basc_TailGateSts_Proxy = com::changan::carControl::Tailgate::proxy::Basc_TailGateSts_Proxy;
							if(Basc_TailGateSts_Proxy::get_instance().is_init()){
								Basc_TailGateSts_Proxy::get_instance().Ntf_LockSt.trigger(data->data._u.Car_Control_Basc_TailGateSts_Ntf_LockSt);
							}
							break;
						}
						case carControl_Car_Control_Basc_TailGateSts_Ntf_TailGateSysSt_Hash:
						{
						    using Basc_TailGateSts_Proxy = com::changan::carControl::Tailgate::proxy::Basc_TailGateSts_Proxy;
							if(Basc_TailGateSts_Proxy::get_instance().is_init()){
								Basc_TailGateSts_Proxy::get_instance().Ntf_TailGateSysSt.trigger(data->data._u.Car_Control_Basc_TailGateSts_Ntf_TailGateSysSt);
							}
							break;
						}
						case carControl_Car_Control_Basc_TailGateSts_Ntf_MotCurPosVIT_Hash:
						{
						    using Basc_TailGateSts_Proxy = com::changan::carControl::Tailgate::proxy::Basc_TailGateSts_Proxy;
							if(Basc_TailGateSts_Proxy::get_instance().is_init()){
								Basc_TailGateSts_Proxy::get_instance().Ntf_MotCurPosVIT.trigger(data->data._u.Car_Control_Basc_TailGateSts_Ntf_MotCurPosVIT);
							}
							break;
						}
						case carControl_Car_Control_Basc_TailGateSts_Ntf_TailGateWinSt_Hash:
						{
						    using Basc_TailGateSts_Proxy = com::changan::carControl::Tailgate::proxy::Basc_TailGateSts_Proxy;
							if(Basc_TailGateSts_Proxy::get_instance().is_init()){
								Basc_TailGateSts_Proxy::get_instance().Ntf_TailGateWinSt.trigger(data->data._u.Car_Control_Basc_TailGateSts_Ntf_TailGateWinSt);
							}
							break;
						}
						case carControl_Car_Control_Basc_TailGateSts_Ntf_WinCurPosVIT_Hash:
						{
						    using Basc_TailGateSts_Proxy = com::changan::carControl::Tailgate::proxy::Basc_TailGateSts_Proxy;
							if(Basc_TailGateSts_Proxy::get_instance().is_init()){
								Basc_TailGateSts_Proxy::get_instance().Ntf_WinCurPosVIT.trigger(data->data._u.Car_Control_Basc_TailGateSts_Ntf_WinCurPosVIT);
							}
							break;
						}
						case carControl_Car_Control_Basc_TailGateSts_Ntf_TailGateSysSwSt_Hash:
						{
						    using Basc_TailGateSts_Proxy = com::changan::carControl::Tailgate::proxy::Basc_TailGateSts_Proxy;
							if(Basc_TailGateSts_Proxy::get_instance().is_init()){
								Basc_TailGateSts_Proxy::get_instance().Ntf_TailGateSysSwSt.trigger(data->data._u.Car_Control_Basc_TailGateSts_Ntf_TailGateSysSwSt);
							}
							break;
						}
						case carControl_Car_Control_Basc_TailGateSts_Ntf_TailGateSysSwFltSt_Hash:
						{
						    using Basc_TailGateSts_Proxy = com::changan::carControl::Tailgate::proxy::Basc_TailGateSts_Proxy;
							if(Basc_TailGateSts_Proxy::get_instance().is_init()){
								Basc_TailGateSts_Proxy::get_instance().Ntf_TailGateSysSwFltSt.trigger(data->data._u.Car_Control_Basc_TailGateSts_Ntf_TailGateSysSwFltSt);
							}
							break;
						}
						default:
							break;
						}
					}
					carControl_Car_Control_Ntf_free(samples[0], DDS_FREE_ALL);
				}
		  		CarControlRProxy::CarControlRProxy() {
				}

				dds_rpc_handle_t CarControlRProxy::get_rpc_handle() {
					return this->dds_mcu_rpc_handle;
				}

		  		void CarControlRProxy::register_provider_matched_handler(std::string name,uint16_t serviceId, EventReceiveHandler<const ProviderMatchedStatus&> handler){
					if(NULL==handler || name.empty() || serviceId == 0){
			  			return;
			  		}
			  		//provider_matched_handler_map[name]=handler;
                    //解析的bitmap获取服务在线信息
					bool online = false;
					T_topicdata_bitmap *topic_bitmap = get_topicdata_bitmap();
					if(topic_bitmap != NULL)
					{
                        online = get_servive_online(serviceId,topic_bitmap->topicdata_bitmap, topic_bitmap->topicdata_bitmap_len);
					    topicdata_checkable_handler_map[serviceId].bOnline = online;
					}

			  		if(this->init_flag && this->provider_matched_status.is_online){
						ProviderMatchedStatus provider_matched_status={};
                        provider_matched_status.is_online = online;
						handler(provider_matched_status);
			  			//handler(this->provider_matched_status);
						auto it = topicdata_checkable_handler_map.find(serviceId);
						if (it != topicdata_checkable_handler_map.end())
						{
                            topicdata_checkable_handler_map[serviceId].preOnline = provider_matched_status.is_online;
						}
						
			  		}
			  	}

			  	//std::unordered_map<std::string, EventReceiveHandler<const ProviderMatchedStatus&>> CarControlRProxy::get_registered_provider_matched_handler(){
				//  	return this->provider_matched_handler_map;
				//}

				void CarControlRProxy::set_last_provider_match_status(ProviderMatchedStatus status){
				  	this->provider_matched_status=status;
				}

				std::future<std::shared_ptr<void>> CarControlRProxy::call(uint64_t fu_id,const void* data) {
					return com::changan::rpc_service::DDSClient::async_call(fu_id, this->dds_mcu_rpc_handle.writer, data);
				}
				
				void CarControlRProxy::register_topicdata_checkable_handler(uint16_t serviceId, EventReceiveHandler<const ProviderMatchedStatus&> handler) {
					if (NULL == handler || serviceId == 0) {
						return;
					}

					ViuStatus vs;
					vs.handler = handler;
					vs.bOnline = false;
					topicdata_checkable_handler_map[serviceId] = vs;
				}

				std::unordered_map<uint16_t, ViuStatus>& CarControlRProxy::get_registered_topicdata_checkable_handler() {
					return this->topicdata_checkable_handler_map;
				}
				
				bool CarControlRProxy::get_topicdata_online(uint16_t serviceId)
				{
                    auto it = topicdata_checkable_handler_map.find(serviceId);
					if (it != topicdata_checkable_handler_map.end())
					{
                       return topicdata_checkable_handler_map[serviceId].bOnline;
					}
					return false;
				}

				void CarControlRProxy::set_topicdata_online(uint16_t serviceId, bool online)
				{
					auto it = topicdata_checkable_handler_map.find(serviceId);
					if (it != topicdata_checkable_handler_map.end())
					{
                        topicdata_checkable_handler_map[serviceId].bOnline = online;
					}	
				}

				bool CarControlRProxy::get_servive_online(uint16_t serviceId, const unsigned char* topicdata_value, uint32_t topicdata_len)
				{
                    bool bOnline = false;
					uint32_t byteIdx = (uint32_t)(serviceId + 7) / 8 - 1;
				
					if (byteIdx <= topicdata_len) {
						uint32_t bitIdx = (serviceId - 1) % 8;
						uint8_t u8 = (uint8_t)topicdata_value[byteIdx];
						bOnline = u8 & (((uint8_t)1) << (8 - bitIdx - 1));							
					}
					return bOnline;
				}

				T_topicdata_bitmap * CarControlRProxy::get_topicdata_bitmap()
				{
					return &(this->topic_bitmap);
				}
			}
		}
	}
}

